
from django.shortcuts import render,redirect,HttpResponse
from .models import *
from django.views.decorators.csrf import csrf_exempt
from django.contrib.auth import authenticate,login
import csv
from django.shortcuts import render
from django.shortcuts import get_object_or_404
from django.contrib.auth.models import User, auth
from django.contrib import messages
from django.core.mail import send_mail
from django.conf import settings
import random
import string
import json
from calendar import month_name

from datetime import date, timedelta
from datetime import datetime, timedelta, date
from django.utils.timezone import now

from django.http import JsonResponse
import os
import time
from datetime import date
from django.contrib.auth.decorators import login_required
from decimal import Decimal
from django.contrib.auth import login
from datetime import datetime  # Import the datetime module
import requests
from base64 import b64encode
from datetime import datetime
from django.core.exceptions import ObjectDoesNotExist
from django.db.models import Sum
import pytz
import calendar
from django.http import HttpResponse
from django.db import connection
from django.db.models import Q
from django.utils import timezone
from datetime import timedelta
import openpyxl
from django.db.models import F, Value
from django.db.models.functions import Concat
from django.db.models import Case, When, Value, IntegerField
from collections import defaultdict
import logging 
from .utils import *
import calendar
from django.db.models import Q
from django.db.models.functions import ExtractMonth, ExtractYear
from django.http import HttpResponseRedirect
from django.urls import reverse

from google.auth.transport import requests as google_requests
from django.shortcuts import redirect
from django.template.loader import render_to_string

from collections import defaultdict
from django.db.models import Max
import re

from django.db.models import Count


from django.http import HttpRequest

import os.path
from django.shortcuts import redirect
from django.http import HttpRequest, HttpResponse
from django.conf import settings
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError


import csv
from django.http import HttpResponse

import os
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import Flow
from googleapiclient.discovery import build
from django.shortcuts import redirect
from django.conf import settings
from Database_Educated_System.settings import LIVE_URL





@login_required(login_url='/')
def admin_dashboard(request):
    print("Admin dashboard accessed by user")
    active = [''] * 15
    active[0] = 'active'

    selected_month = request.session.get('month')

    if selected_month:
        # current_month = datetime.strptime(selected_month, "%B").month
        current_month = int(selected_month)
    else:
        current_month = 2

    if current_month ==1:
        last_month=12
    else:
        last_month=current_month-1

    print(current_month)
    print(last_month)

    selected_year = request.session.get('year')
    from datetime import datetime, timedelta
    if selected_year:
        # current_month = datetime.strptime(selected_month, "%B").month
        current_year = int(selected_year)
    else:
        current_year = datetime.now().year

    if current_month ==1:
        last_year=current_year-1
    else:
        last_year=current_year
    # Filter client_contract_work records for the given month and year
    contract_works = Client_contract_work.objects.filter(
        date__year=current_year,
        date__month=current_month
    )


    user_name = request.session.get('user_name')
    print(user_name)
    employee1 = employee.objects.get(user_name=user_name)
    employee_id = employee1.toggl_user_id

    loggedin_employee_id = employee1.id
    total_working_hours = 0

    # Find client_id where the current employee worked
    working_inputs = contract_works.filter(
        working_input__icontains=f'"{loggedin_employee_id}"'  # Check if employee_id exists in JSON field
    ).values_list('working_input', flat=True)

    # Get all employee IDs who worked for the same clients
    employee_ids = set()
    for working_input in working_inputs:
        if working_input:
            employee_ids.update(json.loads(working_input).keys())

            working_data = json.loads(working_input)
            
            # If logged-in employee ID exists in the working data, add their hours
            if str(loggedin_employee_id) in working_data:
                try:
                    total_working_hours += float(working_data[str(loggedin_employee_id)])
                except Exception as e:
                    print(e)
    total_working_hours = round(total_working_hours, 2)

    # Convert employee_ids to a list
    employee_ids = list(employee_ids)

    # Remove the current employee's ID from the list
    employee_ids.remove(str(employee_id)) if str(employee_id) in employee_ids else None




    # Get today's date
    today_date = datetime.now().date()

    # Calculate the start and end of the current week (Monday to Sunday)
    start_of_week = today_date - timedelta(days=today_date.weekday())  # Monday
    end_of_week = start_of_week + timedelta(days=6)  # Sunday

    running_year = datetime.now().year
    # Fetch leaves for the logged-in employee that fall within the current week
    all_leaves = leave.objects.filter(
        employee_id=loggedin_employee_id,
        start_date__year=running_year,
        start_date__gte=today_date
    ).order_by('start_date')

    # Since we're fetching for a single employee, we don't need custom ordering by `employee_ids`
    # Directly fetch employee details
    emp_details = employee.objects.filter(id=loggedin_employee_id).first()
    print(f"preparing leave details with employee information")

    # Prepare leave details with employee information
    leaves_with_employees = []
    for leave_obj in all_leaves:
        leave_data = {
            'id': leave_obj.id,
            'employee_id': leave_obj.employee_id,
            'status': leave_obj.status,
            'start_date': leave_obj.start_date,
            'end_date': leave_obj.end_date,
        }
        
        if emp_details:
            leave_data.update({
                'employee_name': f"{emp_details.first_name} {emp_details.last_name}",
                'employee_email': emp_details.email,  # Include other fields if needed
                'image_url': emp_details.image_url,  # Include other fields if needed
            })
        else:
            leave_data['employee_name'] = "Unknown Employee"
        
        leaves_with_employees.append(leave_data)

    from datetime import date, timedelta
    import calendar
    from datetime import date


    today_date = date.today()  # Today's date
    next_30_days_date = today_date + timedelta(days=30)  # 30 days from today

    # Fetch leaves that fall within the next 30 days
    all_leaves_of_month = leave.objects.filter(
        start_date__lte=next_30_days_date,  # Leaves that start before or on the next 30 days date
        end_date__gte=today_date           # Leaves that end after or on today
    ).exclude(
        employee_id=loggedin_employee_id    # Exclude the logged-in employee's leaves
    )

  

    all_leaves_of_month = all_leaves_of_month.annotate(
        custom_order=Case(
            *[
                When(employee_id=emp_id, then=Value(index))
                for index, emp_id in enumerate(employee_ids)
            ],
            default=Value(len(employee_ids)),  # Non-prioritized leaves go to the end
            output_field=IntegerField()
        )
    ).order_by('start_date__month', 'start_date__day')
    
    month_leaves_with_employees = []
    for leave_obj in all_leaves_of_month:
        emp_details = employee.objects.filter(id=leave_obj.employee_id).first()
        leave_data = {
            'id': leave_obj.id,
            'employee_id': leave_obj.employee_id,
            'status': leave_obj.status,
            'start_date': leave_obj.start_date,
            'end_date': leave_obj.end_date,
        }
        
        if emp_details:
            leave_data.update({
                'employee_name': f"{emp_details.first_name} {emp_details.last_name}",
                'employee_email': emp_details.email,  # Include other fields if needed
                'image_url': emp_details.image_url,  # Include other fields if needed
            })
        else:
            leave_data['employee_name'] = "Unknown Employee"
        
        month_leaves_with_employees.append(leave_data)

    today = date.today()
    tomorrow = today + timedelta(days=1)


    birthdays_today = employee.objects.filter(date_of_birth__month=today.month, date_of_birth__day=today.day)
    birthdays_tomorrow = employee.objects.filter(date_of_birth__month=tomorrow.month, date_of_birth__day=tomorrow.day)

    
    ninety_days_later = today + timedelta(days=120)
    print(f"ninety_days_later: {ninety_days_later}")
    # Fetch birthdays for the next 90 days, excluding today and tomorrow
    future_birthdays = employee.objects.filter(
        Q(date_of_birth__month__gt=today.month) | 
        (Q(date_of_birth__month=today.month) & Q(date_of_birth__day__gt=today.day)),
        Q(date_of_birth__month__lt=ninety_days_later.month) | 
        (Q(date_of_birth__month=ninety_days_later.month) & Q(date_of_birth__day__lte=ninety_days_later.day)),
        status=1  # Include status=1 as a keyword argument
    ).exclude(
        Q(date_of_birth__month=tomorrow.month, date_of_birth__day=tomorrow.day)  # Exclude tomorrow's birthdays
    ).order_by('date_of_birth__month', 'date_of_birth__day')

    # Handle date_of_births spanning across the year boundary
    if today.month > ninety_days_later.month:
        future_birthdays = employee.objects.filter(
            Q(date_of_birth__month__gte=today.month) | Q(date_of_birth__month__lte=ninety_days_later.month),
        ).exclude(
            Q(date_of_birth__month=tomorrow.month, date_of_birth__day=tomorrow.day)  # Exclude tomorrow's birthdays
        )

    project_start_date = date(2025, 1, 1)
    project_list2 = project.objects.filter(created_at__gte=project_start_date).order_by('-id')[:5]
    print("Vinod project_list2")
    print(project_list2)

    project_data_with_employees = []
    import ast
    for project_data in project_list2:
        employee_details_by_role = {
            'L': [],
            'S': [],
            'A': []
        }

        working_roles = ast.literal_eval(project_data.working_role)

        for employee_id, role in working_roles.items():
            if role not in employee_details_by_role:
                continue

            if employee_id not in [emp['id'] for emp in employee_details_by_role[role]]:
                try:
                    employee_data = employee.objects.get(id=employee_id)
                    employee_details_by_role[role].append({
                        'name': f"{employee_data.first_name} {employee_data.last_name}",
                        'id': employee_data.id,
                        'image_url': employee_data.image_url,
                        'role': role
                    })
                except employee.DoesNotExist:
                    continue

        project_data_with_employees.append({
            'project': project_data,
            'employee_details_by_role': employee_details_by_role
        })

    # Calculate the start and end dates of the current week
    today = date.today()
    start_of_week = today - timedelta(days=today.weekday())  # Monday
    end_of_week = start_of_week + timedelta(days=6)         # Sunday

    # Filter timesheets within the current week
    timesheet_data = timeSheet.objects.filter(
        time_entries_start_date__gte=start_of_week,
        time_entries_stop_date__lte=end_of_week
    ).values('employee_id').annotate(
        total_time_seconds=Sum('time_entries_seconds')
    )

    # Map employee data to the timesheet data
    employees = employee.objects.all()
    employee_map = {
        emp.id: {
            'name': f"{emp.first_name} {emp.last_name}",
            'image_url': emp.image_url
        }
        for emp in employees
    }

    print(f"employee_map: {employee_map}")

    # Combine employee names with total working times
    total_working_time_per_employee = sorted([
        {
            'employee_name': employee_map.get(entry['employee_id'], {}).get('name', 'Unknown'),
            'image_url': employee_map.get(entry['employee_id'], {}).get('image_url', ''),
            'total_time_seconds': entry['total_time_seconds'],
            'total_time_formatted': str(timedelta(seconds=entry['total_time_seconds']))
        }
        for entry in timesheet_data
        ],
        key=lambda x: x['total_time_seconds'],  # Sort by total_time_seconds
        reverse=True
    )

    # Calculate the overall total working time for the week
    total_working_time_all_employees = sum(
        entry['total_time_seconds'] or 0 for entry in timesheet_data
    )

    recent_client_info = client.objects.all().order_by('-id')[:5]


    
    # Assuming the employee_id is passed from the session or obtained dynamically
    employee_id = loggedin_employee_id  # Replace this with the actual employee identification logic

    # Calculate today's hours
    today = now().date()
    total_seconds_today = timeSheet.objects.filter(
        employee_id=loggedin_employee_id,
        time_entries_start_date=today
    ).aggregate(Sum('time_entries_seconds'))['time_entries_seconds__sum'] or 0
    total_hours_today = total_seconds_today / 3600  # Convert to hours

    # Calculate this week's hours
    start_of_week = today - timedelta(days=today.weekday())  # Monday
    end_of_week = start_of_week + timedelta(days=6)  # Sunday
    total_seconds_week = timeSheet.objects.filter(
        employee_id=loggedin_employee_id,
        time_entries_start_date__range=[start_of_week, end_of_week]
    ).aggregate(Sum('time_entries_seconds'))['time_entries_seconds__sum'] or 0
    total_hours_week = total_seconds_week / 3600  # Convert to hours

    # Calculate this month's hours
    start_of_month = today.replace(day=1)
    today_date = date.today()
    total_seconds_month = timeSheet.objects.filter(
        employee_id=loggedin_employee_id,
        time_entries_start_date__range=[start_of_month, today_date]
    ).aggregate(Sum('time_entries_seconds'))['time_entries_seconds__sum'] or 0
    total_hours_month = round(total_seconds_month / 3600,2)  # Convert to hours

    
    # Get the current year
    running_year = datetime.now().year

    if employee1.country_id:
        country_id = employee1.country_id
    else:
        country_id = 1
    country_detail = Country.objects.get(id=country_id)

    # Fetch all leaves for the current year, excluding declined ones
    all_leaves = leave.objects.filter(
        employee_id=loggedin_employee_id,
        start_date__year=running_year  # Filter by current year
    ).exclude(status='declined')

    # Initialize total taken days and other leave details
    total_taken_days = 0
    total_count = all_leaves.count()  # Total leave entries (for record-keeping)

    # Function to count days excluding weekends
    def count_days_excluding_weekends(start_date, end_date):
        day_count = 0
        current_date = start_date
        while current_date <= end_date:
            if current_date.weekday() < 4:  # Weekdays are 0-4 (Mon-Fri)
                day_count += 1
            current_date += timedelta(days=1)
        return day_count

    # Calculate total taken days
    for leave_detail in all_leaves:
        start_date = leave_detail.start_date
        end_date = leave_detail.end_date
        if start_date and end_date:
            duration = count_days_excluding_weekends(start_date, end_date)
            total_taken_days += duration
        elif start_date:  # Handle single-day leave
            total_taken_days += 1

    # Calculate remaining and total leave
    if hasattr(country_detail, 'paid_leave') and country_detail.paid_leave:
        total_leave = country_detail.paid_leave  # Total leave assigned to the employee
    else:
        total_leave = 12  # Default total leave if not defined

    remaining_leave = total_leave - total_taken_days

    # Format the data for display
    leave_summary = f"{total_taken_days}/{total_leave}"


    project_start_date = date(2025, 1, 1)
    project_count = project.objects.filter(created_at__gte=project_start_date).count()


    group = None

    if request.user.groups.exists():
        group = request.user.groups.all()
        print("exist group")
        print(group[0] if group else "No groups")

        if group[0].name == 'admin' or group[0].name == 'super_user':
            employee_count = employee.objects.filter(status=1).count()
            client_count = client.objects.count()
            
            selected_month = request.session.get('month')

            if selected_month:
                # current_month = datetime.strptime(selected_month, "%B").month
                current_month = int(selected_month)
            else:
                current_month = 2

            if current_month ==1:
                last_month=12
            else:
                last_month=current_month-1
            print("ssssssssssssssssssssssssssssssssssssss")
            print(current_month)
            print(last_month)

            selected_year = request.session.get('year')

            if selected_year:
                # current_month = datetime.strptime(selected_month, "%B").month
                current_year = int(selected_year)
            else:
                current_year = 2026

            if current_month ==1:
                last_year=current_year-1
            else:
                last_year=current_year
            print("gggggggggggggggggggggggggggggggggggggg")
            print(current_year)
            print(last_year)

           
            start_date = date(current_year, current_month, 1)
            end_date = date(current_year, current_month, calendar.monthrange(current_year, current_month)[1])
            
            client_contract_work = Client_contract_work.objects.filter(date__gte=start_date, date__lte=end_date)

            # Fetch client information for each client contract work
            client_contract_work_with_client_info = []
            logged_in_employee_clients = []

            user_name = request.session.get('user_name')
            employee1 = employee.objects.get(user_name=user_name)

            logged_in_employee_id = employee1.id

            for work in client_contract_work:
                client_info = client.objects.get(id=work.client_id)
                client_contract_work_with_client_info.append((work, client_info))

                working_roles = json.loads(work.working_role)  # Parse JSON string into a dictionary
                
                # Check if the logged-in employee is associated with this client
                if str(logged_in_employee_id) in working_roles:
                    client_info = client.objects.get(id=work.client_id)  # Fetch client information
                    role = working_roles[str(logged_in_employee_id)]  # Get the role for this employee
                    logged_in_employee_clients.append({"client": client_info, "role": role})


            # Extract client objects from the list
            client_list = [client_info for _, client_info in client_contract_work_with_client_info]

            client_count= len(client_list)

            # Count logged-in employee's clients
            logged_in_employee_client_count = len(logged_in_employee_clients)

            try:
                role_order = {'C': 0, 'A': 1, 'B': 2}
                # Sort using the custom order
                logged_in_employee_clients = sorted(logged_in_employee_clients, key=lambda x: role_order.get(x['role'], float('inf')))
            except Exception as e:
                pass

            context={"employee_count":employee_count,
                "client_count":client_count,
                "logged_in_employee_client_count":logged_in_employee_client_count,
                "project_count":project_count,
                'current_month':current_month,
                'active':active,
                'leaves_with_employees':leaves_with_employees,
                'month_leaves_with_employees':month_leaves_with_employees,
                'current_year':current_year,
                'birthdays_today': birthdays_today,
                'birthdays_tomorrow': birthdays_tomorrow,
                'future_birthdays': future_birthdays,
                'total_working_time_per_employee': total_working_time_per_employee,
                'total_working_time_all_employees': total_working_time_all_employees,
                'start_of_week': start_of_week,
                'end_of_week': end_of_week,
                'recent_client_info': recent_client_info,
                'total_hours_today': total_hours_today,
                'total_hours_week': total_hours_week,
                'total_hours_month': total_hours_month,
                'leave_summary': leave_summary,
                'logged_in_employee_id': logged_in_employee_id,
                'logged_in_employee_clients': logged_in_employee_clients,
                'total_working_hours': total_working_hours,
                'project_data_with_employees': project_data_with_employees,
            }
            return render(request, "admin-dashboard.html",context)
    else:

        user_name = request.session.get('user_name')
        print(user_name)
        employee1 = employee.objects.get(user_name=user_name)
        employee_id = employee1.toggl_user_id
        print(employee_id)
        selected_month = request.session.get('month')

        if selected_month:
            # current_month = datetime.strptime(selected_month, "%B").month
            current_month = int(selected_month)
        else:
            current_month = 2

        if current_month ==1:
            last_month=12
        else:
            last_month=current_month-1
        print("ssssssssssssssssssssssssssssssssssssss")
        print(current_month)
        print(last_month)

        selected_year = request.session.get('year')

        if selected_year:
            # current_month = datetime.strptime(selected_month, "%B").month
            current_year = int(selected_year)
        else:
            current_year = 2026

        if current_month ==1:
            last_year=current_year-1
        else:
            last_year=current_year

        # Get the project IDs for the employee
        project_ids = toggl_user_detail.objects.filter(user_id=employee_id).values_list('project_id', flat=True).distinct()
        # Query to get the unique client IDs for the projects
        unique_client_ids = project.objects.filter(toggl_project_id__in=project_ids).values('toggl_client_id').distinct()
        print(unique_client_ids)
        # Count the number of unique clients
        total_unique_clients = unique_client_ids.count()
        print(f"Total Unique Clients for Employee {user_name}: {total_unique_clients}")

        total_employees = employee.objects.filter(status=1).count()
        print(f"Total Number of Employees: {total_employees}")
                

        start_date = date(current_year, current_month, 1)
        end_date = date(current_year, current_month, calendar.monthrange(current_year, current_month)[1])
        
        client_contract_work = Client_contract_work.objects.filter(date__gte=start_date, date__lte=end_date)

        # Fetch client information for each client contract work
        client_contract_work_with_client_info = []
        logged_in_employee_clients = []

        user_name = request.session.get('user_name')
        employee1 = employee.objects.get(user_name=user_name)

        logged_in_employee_id = employee1.id
        for work in client_contract_work:
            client_info = client.objects.get(id=work.client_id)
            client_contract_work_with_client_info.append((work, client_info))

            working_roles = json.loads(work.working_role)  # Parse JSON string into a dictionary
            
            # Check if the logged-in employee is associated with this client
            if str(logged_in_employee_id) in working_roles:
                client_info = client.objects.get(id=work.client_id)  # Fetch client information
                role = working_roles[str(logged_in_employee_id)]  # Get the role for this employee
                logged_in_employee_clients.append({"client": client_info, "role": role})


        # Extract client objects from the list
        client_list = [client_info for _, client_info in client_contract_work_with_client_info]

        client_count= len(client_list)

        # Count logged-in employee's clients
        logged_in_employee_client_count = len(logged_in_employee_clients)

        try:
            role_order = {'C': 0, 'A': 1, 'B': 2}
            # Sort using the custom order
            logged_in_employee_clients = sorted(logged_in_employee_clients, key=lambda x: role_order.get(x['role'], float('inf')))
        except Exception as e:
            pass


        context={
            "project_count":project_count,
            # "client_count":total_unique_clients,
            "client_count":client_count,
            "logged_in_employee_client_count":logged_in_employee_client_count,
            "employee_count":total_employees,
            'current_month':current_month,
            'active':active,
            'leaves_with_employees':leaves_with_employees,
            'month_leaves_with_employees':month_leaves_with_employees,
            'current_year':current_year,
            'birthdays_today': birthdays_today,
            'birthdays_tomorrow': birthdays_tomorrow,
            'future_birthdays': future_birthdays,
            'total_working_time_per_employee': total_working_time_per_employee,
            'total_working_time_all_employees': total_working_time_all_employees,
            'start_of_week': start_of_week,
            'end_of_week': end_of_week,
            'recent_client_info': recent_client_info,
            'total_hours_today': total_hours_today,
            'total_hours_week': total_hours_week,
            'total_hours_month': total_hours_month,
            'leave_summary': leave_summary,
            'logged_in_employee_id': logged_in_employee_id,
            'logged_in_employee_clients': logged_in_employee_clients,
            'total_working_hours': total_working_hours,
            'project_data_with_employees': project_data_with_employees,
        }

        return render(request, "admin-dashboard.html",context)

def final_calculation(request):

    selected_month = request.session.get('month')

    if selected_month:
        # current_month = datetime.strptime(selected_month, "%B").month
        current_month = int(selected_month)
    else:
        current_month = 2

    if current_month ==1:
        last_month=12
    else:
        last_month=current_month-1
    print("ssssssssssssssssssssssssssssssssssssss")
    print(current_month)
    print(last_month)

    selected_year = request.session.get('year')

    if selected_year:
        # current_month = datetime.strptime(selected_month, "%B").month
        current_year = int(selected_year)
    else:
        current_year = 2026

    if current_month ==1:
        last_year=current_year-1
    else:
        last_year=current_year
    print("gggggggggggggggggggggggggggggggggggggg")
    print(current_year)
    print(last_year)
    # from django.http import HttpResponse
    # return HttpResponse(current_month)
     # Calculate the sum of rates for all clients
   # Calculate the sum of rates for all clients and get formatted sums
    formatted_sum_of_employee_cost_current,formatted_sum_of_contracted_employee_cost_current,formatted_sum_one_project_rate_current,formatted_sum_of_employee_cost_previous, formatted_sum_of_contracted_employee_cost_previous,formatted_sum_one_project_rate_previous= calculate_rates(request)

    # Convert strings to floats
    try:
        sum_of_employee_cost_current = float(formatted_sum_of_employee_cost_current)
        sum_of_contracted_employee_cost_current = float(formatted_sum_of_contracted_employee_cost_current)
        sum_one_project_rate_current = float(formatted_sum_one_project_rate_current)
        sum_of_employee_cost_previous = float(formatted_sum_of_employee_cost_previous)
        sum_of_contracted_employee_cost_previous= float(formatted_sum_of_contracted_employee_cost_previous)
        sum_one_project_rate_previous = float(formatted_sum_one_project_rate_previous)
    except ValueError:
        # Handle the case where conversion fails
        print("Error: Unable to convert strings to float")

     # Calculate profits for the current month
    profit_current = sum_one_project_rate_current - sum_of_employee_cost_current
    contracted_profit_current = sum_one_project_rate_current - sum_of_contracted_employee_cost_current

    # Calculate profits for the previous month
    profit_previous = sum_one_project_rate_previous - sum_of_employee_cost_previous
    contracted_profit_previous = sum_one_project_rate_previous - sum_of_contracted_employee_cost_previous

    #upto 2 decimal
    profit_current = "{:.2f}".format(profit_current)
    profit_previous = "{:.2f}".format(profit_previous)
    contracted_profit_current = "{:.2f}".format(contracted_profit_current)
    contracted_profit_previous = "{:.2f}".format(contracted_profit_previous)
    print("profit current")
    print(sum_one_project_rate_current)
    print(profit_current)
    print(contracted_profit_current)

    print("profit previous")
    print(sum_one_project_rate_previous)
    print(profit_previous)
    print(contracted_profit_previous)

    return HttpResponse("Calculated")






@csrf_exempt
@login_required(login_url='/')
def employees(request):
    active = [''] * 15
    active[1] = 'active'
    if request.method == 'POST':
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        user_name = request.POST.get('user_name')
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        doe = request.POST.get('doe')
        joining_date = request.POST.get('joining_date')
        phone = request.POST.get('phone')
        company = request.POST.get('company')
        department = request.POST.get('department')
        designation = request.POST.get('designation')
        reports_to = request.POST.get('reports_to')
        address = request.POST.get('address')
        gender = request.POST.get('gender')

        if password != confirm_password:
            messages.error(request, "Passwords do not match.")
            return redirect("admin-dashboard")  # Redirect back to the registration page

        # Check if the email is already in use
        if User.objects.filter(username=user_name).exists():
            messages.error(request, "This username is already in use.")
            return redirect("admin-dashboard")

        user = User.objects.create_user(
            username=user_name,
            email=email,
            password=password
        )
        user.save()

        new_employee = employee(
            first_name=first_name,
            last_name=last_name,
            user_name=user_name,
            date_of_birth=doe,
            joining_date=joining_date,
            phone=phone,
            company=company,
            department=department,
            designation=designation,
            reports_to=reports_to,
            address=address,
            gender=gender,
            email=email

        )
        new_employee.save()

    if request.user.groups.exists():
        group = request.user.groups.all()
        print("exist group")
        print(group)

        if group[0].name == 'admin' or group[0].name == 'super_admin' or group[0].name == 'super_user':
    # if request.user.username == 'Sbhutra' and request.user.id == 6:
            print("super_admin or superadmin")
            # Admin can see all employees
            employee_list = employee.objects.filter(status=1).all().order_by('image_url')
            # Assuming 'designation' is the field representing designations in your Employee model
            unique_designations = employee.objects.filter(status=1).exclude(designation=None).values_list('designation', flat=True).distinct().order_by('designation')
            # Assuming 'country_id' is the field in the Employee model representing the country ID
            unique_country_ids = employee.objects.filter(status=1, country_id__isnull=False).values_list('country_id', flat=True).distinct().order_by('country_id')

            # Retrieve country names for the unique country IDs
            unique_country_names = Country.objects.filter(id__in=unique_country_ids).order_by('name')
            print("sssssssssssss")
            print(unique_country_names)

            toggl_user_ids = [employee.toggl_user_id for employee in employee_list]
            print(toggl_user_ids)
            ids = [employee.id for employee in employee_list]
            print(ids)
            selected_month = request.session.get('month')

            if selected_month:
                # current_month = datetime.strptime(selected_month, "%B").month
                current_month = int(selected_month)
            else:
                current_month = 2

            if current_month ==1:
                last_month=12
            else:
                last_month=current_month-1
            print("ssssssssssssssssssssssssssssssssssssss")
            print(current_month)
            print(last_month)

            selected_year = request.session.get('year')

            if selected_year:
                # current_month = datetime.strptime(selected_month, "%B").month
                current_year = int(selected_year)
            else:
                current_year = 2026

            if current_month ==1:
                last_year=current_year-1
            else:
                last_year=current_year

            print("gggggggggggggggggggggggggggggggggggggg")
            print(current_year)
            print(last_year)
            if current_year == 2023 and 9 <= current_month <= 12:
                contracted_employee_for_month = contracted_employee.objects.filter(employee_id__in=toggl_user_ids,month__month=current_month, month__year=current_year
                )
                print(contracted_employee_for_month)
                contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}
                print("fffffffffffffffffffffffffffffffffffffffffffffffffffff")
                print(contracted_employee_dict)

                for emp in employee_list:
                    emp.contracted_employee_info = contracted_employee_dict.get(emp.toggl_user_id, None)

                print('muskan')
                print(employee_list)
            else:
                contracted_employee_for_month = Client_contract_employee.objects.filter(employee_id__in=ids,date__month=current_month, date__year=current_year
                )
                print(contracted_employee_for_month)
                contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}
                print("iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii")
                print(contracted_employee_dict)

                for emp in employee_list:
                    emp.contracted_employee_info = contracted_employee_dict.get(emp.id, None)

                print('muskan')
                print(employee_list)


            context={
                "employee_list": employee_list,
                 "current_year":current_year,
                "current_month":current_month,
                "month_list":[],
                # "contracted_employee_for_month": contracted_employee_for_month,
                "unique_designations":unique_designations,
                "unique_country_names":unique_country_names

            }
            return render(request, "employees/employees.html", context)

    group = None

    # if request.user.groups.exists():
    #     group = request.user.groups.all()
    #     print("exist group")
    #     print(group)

    #     if group[0].name == 'admin' or group[0].name == 'super_admin':
    print("admin")
    # Admin can see all employees
    employee_list = employee.objects.filter(status=1).all().order_by('image_url')
    # Assuming 'designation' is the field representing designations in your Employee model
    unique_designations = employee.objects.filter(status=1).exclude(designation=None).values_list('designation', flat=True).distinct().order_by('designation')
    # Assuming 'country_id' is the field in the Employee model representing the country ID
    unique_country_ids = employee.objects.filter(status=1, country_id__isnull=False).values_list('country_id', flat=True).distinct().order_by('country_id')

    # Retrieve country names for the unique country IDs
    unique_country_names = Country.objects.filter(id__in=unique_country_ids).order_by('name')

    toggl_user_ids = [employee.toggl_user_id for employee in employee_list]
    print(toggl_user_ids)
    ids = [employee.id for employee in employee_list]
    print(ids)
    selected_month = request.session.get('month')

    if selected_month:
        # current_month = datetime.strptime(selected_month, "%B").month
        current_month = int(selected_month)
    else:
        current_month = 2

    if current_month ==1:
        last_month=12
    else:
        last_month=current_month-1
    print("ssssssssssssssssssssssssssssssssssssss")
    print(current_month)
    print(last_month)

    selected_year = request.session.get('year')

    if selected_year:
        # current_month = datetime.strptime(selected_month, "%B").month
        current_year = int(selected_year)
    else:
        current_year = 2026

    if current_month ==1:
        last_year=current_year-1
    else:
        last_year=current_year
    if current_year == 2023 and 9 <= current_month <= 12:
        contracted_employee_for_month = contracted_employee.objects.filter(employee_id__in=toggl_user_ids,month__month=current_month,month__year=current_year
        )
        print(contracted_employee_for_month)
        contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}

        for emp in employee_list:
            emp.contracted_employee_info = contracted_employee_dict.get(emp.toggl_user_id, None)

        print('muskan')
        print(employee_list)
    else:
        contracted_employee_for_month = Client_contract_employee.objects.filter(employee_id__in=ids,date__month=current_month, date__year=current_year
        )
        # print(contracted_employee_for_month)
        contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}
        print("iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii")
        # print(contracted_employee_dict)

        for emp in employee_list:
            emp.contracted_employee_info = contracted_employee_dict.get(emp.id, None)

        print("muskan33333333333333333333333333333333333333333333")
        # print(employee_list)
        print(current_month)

    context={
        "employee_list": employee_list,
        "current_year":current_year,
        "current_month":current_month,
        "month_list":[],
        # "contracted_employee_for_month": contracted_employee_for_month,
        "unique_designations":unique_designations,
        "unique_country_names":unique_country_names,
        'active':active

    }
    return render(request, "employees/employees.html", context)



@csrf_exempt
@login_required(login_url='/')
def old_employees(request):
    active = [''] * 15
    active[2] = 'active'
    if request.user.groups.exists():
        group = request.user.groups.all()
        print("exist group")
        print(group)

        if group[0].name == 'admin' or group[0].name == 'super_admin' or group[0].name == 'super_user':
        # if request.user.username == 'Sbhutra' and request.user.id == 6:
            print("super_admin")
            # Admin can see all employees
            employee_list = employee.objects.filter(status=2).all().order_by('image_url')
            # Assuming 'designation' is the field representing designations in your Employee model
            unique_designations = employee.objects.filter(status=2).exclude(designation=None).values_list('designation', flat=True).distinct().order_by('designation')
            # Assuming 'country_id' is the field in the Employee model representing the country ID
            unique_country_ids = employee.objects.filter(status=2, country_id__isnull=False).values_list('country_id', flat=True).distinct().order_by('country_id')

            # Retrieve country names for the unique country IDs
            unique_country_names = Country.objects.filter(id__in=unique_country_ids).order_by('name')
            toggl_user_ids = [employee.toggl_user_id for employee in employee_list]
            print(toggl_user_ids)
            ids = [employee.id for employee in employee_list]
            print(ids)
            selected_month = request.session.get('month')

            if selected_month:
                # current_month = datetime.strptime(selected_month, "%B").month
                current_month = int(selected_month)
            else:
                current_month = 2

            if current_month ==1:
                last_month=12
            else:
                last_month=current_month-1
            print("ssssssssssssssssssssssssssssssssssssss")
            print(current_month)
            print(last_month)

            selected_year = request.session.get('year')

            if selected_year:
                # current_month = datetime.strptime(selected_month, "%B").month
                current_year = int(selected_year)
            else:
                current_year = 2026

            if current_month ==1:
                last_year=current_year-1
            else:
                last_year=current_year

            print("gggggggggggggggggggggggggggggggggggggg")
            print(current_year)
            print(last_year)
            if current_year == 2023 and 9 <= current_month <= 12:
                contracted_employee_for_month = contracted_employee.objects.filter(employee_id__in=toggl_user_ids,month__month=current_month, month__year=current_year
                )
                print(contracted_employee_for_month)
                contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}
                print("fffffffffffffffffffffffffffffffffffffffffffffffffffff")
                print(contracted_employee_dict)

                for emp in employee_list:
                    emp.contracted_employee_info = contracted_employee_dict.get(emp.toggl_user_id, None)

                print('muskan')
                print(employee_list)
            else:
                contracted_employee_for_month = Client_contract_employee.objects.filter(employee_id__in=ids,date__month=current_month, date__year=current_year
                )
                print(contracted_employee_for_month)
                contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}
                print("iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii")
                print(contracted_employee_dict)

                for emp in employee_list:
                    emp.contracted_employee_info = contracted_employee_dict.get(emp.id, None)

                print('muskan')
                print(employee_list)


            context={
                "employee_list": employee_list,
                "current_year":current_year,
                "current_month":current_month,
                "month_list":[],
                # "contracted_employee_for_month": contracted_employee_for_month,
                "unique_designations":unique_designations,
                "unique_country_names":unique_country_names,
                "active":active

            }
            return render(request, "employees/old_employees.html", context)

    group = None

    if request.user.groups.exists():
        group = request.user.groups.all()
        print("exist group")
        print(group)

        if group[0].name == 'admin' or group[0].name == 'super_admin' or group[0].name == 'super_user':
            print("admin")
            # Admin can see all employees
            employee_list = employee.objects.filter(status=2).all().order_by('image_url')
            # Assuming 'designation' is the field representing designations in your Employee model
            unique_designations = employee.objects.filter(status=2).exclude(designation=None).values_list('designation', flat=True).distinct().order_by('designation')
            # Assuming 'country_id' is the field in the Employee model representing the country ID
            unique_country_ids = employee.objects.filter(status=2, country_id__isnull=False).values_list('country_id', flat=True).distinct().order_by('country_id')

            # Retrieve country names for the unique country IDs
            unique_country_names = Country.objects.filter(id__in=unique_country_ids).order_by('name')
            toggl_user_ids = [employee.toggl_user_id for employee in employee_list]
            print(toggl_user_ids)
            ids = [employee.id for employee in employee_list]
            print(ids)
            selected_month = request.session.get('month')

            if selected_month:
                # current_month = datetime.strptime(selected_month, "%B").month
                current_month = int(selected_month)
            else:
                current_month = 2

            if current_month ==1:
                last_month=12
            else:
                last_month=current_month-1
            print("ssssssssssssssssssssssssssssssssssssss")
            print(current_month)
            print(last_month)

            selected_year = request.session.get('year')

            if selected_year:
                # current_month = datetime.strptime(selected_month, "%B").month
                current_year = int(selected_year)
            else:
                current_year = 2026

            if current_month ==1:
                last_year=current_year-1
            else:
                last_year=current_year
            if current_year == 2023 and 9 <= current_month <= 12:
                contracted_employee_for_month = contracted_employee.objects.filter(employee_id__in=toggl_user_ids,month__month=current_month,month__year=current_year
                )
                print(contracted_employee_for_month)
                contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}

                for emp in employee_list:
                    emp.contracted_employee_info = contracted_employee_dict.get(emp.toggl_user_id, None)

                print('muskan')
                print(employee_list)
            else:
                contracted_employee_for_month = Client_contract_employee.objects.filter(employee_id__in=ids,date__month=current_month, date__year=current_year
                )
                print(contracted_employee_for_month)
                contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}
                print("iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii")
                print(contracted_employee_dict)

                for emp in employee_list:
                    emp.contracted_employee_info = contracted_employee_dict.get(emp.id, None)

                print('muskan')
                print(employee_list)

            context={
                "employee_list": employee_list,
                "current_year":current_year,
                "current_month":current_month,
                "month_list":[],
                # "contracted_employee_for_month": contracted_employee_for_month,
                "unique_designations":unique_designations,
                "unique_country_names":unique_country_names,
                "active":active

            }
            return render(request, "employees/old_employees.html", context)


@csrf_exempt
@login_required(login_url='/')
def update_employee_status_2(request):
    if request.method == 'POST':
        print("iffffffffffffff")
        employee_id = request.POST.get('id')
        new_status = request.POST.get('status')

        print(employee_id)
        print(new_status)

        try:
            employee1 = employee.objects.get(id=employee_id)
            employee1.status = new_status
            employee1.save()
            return JsonResponse({'message': 'Employee status updated successfully.'})
        except employee.DoesNotExist:
            return JsonResponse({'error': 'Employee not found.'}, status=404)

    return JsonResponse({'error': 'Invalid request.'}, status=400)

@csrf_exempt
@login_required(login_url='/')
def update_employee_status_1(request):
    if request.method == 'POST':
        print("iffffffffffffff")
        employee_id = request.POST.get('id')
        new_status = request.POST.get('status')

        print(employee_id)
        print(new_status)

        try:
            employee1 = employee.objects.get(id=employee_id)
            employee1.status = new_status
            employee1.save()
            return JsonResponse({'message': 'Employee status updated successfully.'})
        except employee.DoesNotExist:
            return JsonResponse({'error': 'Employee not found.'}, status=404)

    return JsonResponse({'error': 'Invalid request.'}, status=400)




@csrf_exempt
@login_required(login_url='/')
def employees_id(request):
    if request.method == 'GET':

        print("ss")

        import requests
        from base64 import b64encode

        # Replace placeholders with your actual data
        workspace_id = '4007366'
        email = 'jharna.agrawal@brickwin.com'
        password = 'Newsystem@1234'

        # Define the API URL with the workspace_id placeholder replaced
        url = f'https://api.track.toggl.com/api/v9/workspaces/{workspace_id}/workspace_users'

        # Encode the email and password for Basic Authentication
        auth_header = 'Basic ' + b64encode(f"{email}:{password}".encode("ascii")).decode("ascii")

        # Make the POST request with headers and JSON data
        response = requests.get(url, headers={'Content-Type': 'application/json', 'Authorization': auth_header})

        if response.status_code == 200:  # Check if the request was successful (status code 200)
            response_data = response.json()  # Parse the JSON content of the response
            print(response_data)

            for entry in response_data:
                uid = entry.get('uid')
                email = entry.get('email')
                name = entry.get('name')

                print(f"User ID: {uid}")
                print(f"Email: {email}")
                print(f"Username: {name}")

                # Check if the employee with the same UID exists in the database
                existing_employee = employee.objects.filter(toggl_user_id=uid).first()

                if not existing_employee:
                    # If the employee with the same UID doesn't exist, create a new employee in the database
                    new_employee = employee(toggl_user_id=uid, email=email, user_name=name)
                    new_employee.save()

        else:
            print(f"Failed to fetch data. Status code: {response.status_code}")

    return render(request,"employees_id.html",{})

@csrf_exempt
@login_required(login_url='/')
def profile(request, employee_id,my_profile_tab=None):
    import calendar
    from datetime import date
    if request.method == 'POST':
        form_type = request.POST.get('form_type')
        action = request.POST.get('action')
        print(form_type)
        print(action)
        # Handle image upload
        if form_type == 'form1':
            profile_picture = request.FILES.get('profile_picture')

            if profile_picture:
                # Generate a unique filename based on employee_id and timestamp in seconds
                timestamp = int(time.time())  # Get the current time in seconds
                filename = f'{employee_id}_{timestamp}.jpeg'  # You can change the file extension as needed
                # Define the path where the profile picture will be saved in the "static" folder
                file_path = os.path.join(settings.STATICFILES_DIRS[0], 'img', 'user', filename)

                # Open the file for writing and save the uploaded image with the desired filename
                with open(file_path, 'wb') as destination:
                    for chunk in profile_picture.chunks():
                        destination.write(chunk)

                # Update the employee's profile picture URL in the database
                employee_info = employee.objects.get(pk=employee_id)
                employee_info.image_url = os.path.join(settings.STATIC_URL, 'assets', 'img', 'user', filename)
                employee_info.save()

                # You can also process other form fields here as needed

                return HttpResponse("Image uploaded and form data saved successfully")
        elif form_type == 'form2':
            start_date = request.POST.get('start_date')
            end_date = request.POST.get('end_date')
            print(start_date)
            print(end_date)
            if action == 'Call API':
                try:
                    toggl_user_record = employee.objects.get(id=employee_id)
                    toggl_user_id = toggl_user_record.toggl_user_id
                    print(toggl_user_id)

                    workspace_id = '4007366'
                    email = 'jharna.agrawal@brickwin.com'
                    password = 'Newsystem@1234'
                    page_size = 600
                    user_id = [toggl_user_id]

                    # Define the request JSON data with your specific parameters
                    request_data = {
                        "start_date": start_date,
                        "end_date": end_date,
                        "page_size": page_size,
                        "user_ids": user_id
                    }

                    # Define the API URL with the workspace_id placeholder replaced
                    url = f'https://api.track.toggl.com/reports/api/v3/workspace/{workspace_id}/search/time_entries'

                    # Encode the email and password for Basic Authentication
                    auth_header = 'Basic ' + b64encode(f"{email}:{password}".encode("ascii")).decode("ascii")

                    # Make the POST request with headers and JSON data
                    response = requests.post(url, json=request_data,
                                             headers={'Content-Type': 'application/json', 'Authorization': auth_header})

                    # Parse the JSON response and store it in response_data
                    response_data = response.json()
                    print("response")
                    print(response_data)

                    for entry in response_data:
                        try:
                            user_id = entry['user_id']
                            username = entry['username']
                            project_id = entry['project_id']

                            if project_id is None:
                                # If no project_id, you can skip the rest of the code for this entry
                                continue
                            task_id = entry['task_id']
                            billable = entry['billable']
                            description = entry['description']
                            tag_ids = entry['tag_ids']
                            billable_amount_in_cents = entry['billable_amount_in_cents']
                            hourly_rate_in_cents = entry['hourly_rate_in_cents']
                            currency = entry['currency']
                            time_entries = entry['time_entries']  # This is a list of time entries
                            #
                            print(f"User ID: {user_id}")
                            print(f"Username: {username}")
                            print(f"Project ID: {project_id}")
                            print(f"Task ID: {task_id}")
                            print(f"Billable: {billable}")
                            print(f"Description: {description}")
                            print(f"Tag IDs: {tag_ids}")
                            print(f"Billable Amount (in cents): {billable_amount_in_cents}")
                            print(f"Hourly Rate (in cents): {hourly_rate_in_cents}")
                            print(f"Currency: {currency}")
                            print(time_entries)

                            try:
                                toggl_project = project.objects.get(toggl_project_id=project_id)
                                toggl_projectid = toggl_project.toggl_project_id
                                toggl_client = toggl_project.toggl_client_id
                                toggl_name = toggl_project.toggl_project_name
                                # print(toggl_projectid)
                                # print(toggl_client)
                                print(toggl_name)
                                toggl_client = client.objects.get(toggl_client_id=toggl_client)
                                toggl_clientname = toggl_client.toggl_client_name
                                print(toggl_clientname)

                            except employee.DoesNotExist:
                                # Handle the case where the toggl_user does not exist
                                return HttpResponse("Toggl user not found")

                            # Loop through time entries for this entry
                            for time_entry in time_entries:
                                entry_id = time_entry['id']
                                seconds = time_entry['seconds']
                                start = time_entry['start']
                                stop = time_entry['stop']
                                at = time_entry['at']
                                # Parse the start time and stop time into datetime objects
                                start_time = datetime.fromisoformat(start)
                                stop_time = datetime.fromisoformat(stop)
                                at_time = datetime.fromisoformat(at)

                                # Extract the date and time components
                                start_date = start_time.strftime('%Y-%m-%d')
                                start_time_of_day = start_time.strftime('%H:%M:%S')
                                stop_date = stop_time.strftime('%Y-%m-%d')
                                stop_time_of_day = stop_time.strftime('%H:%M:%S')
                                at_date = at_time.strftime('%Y-%m-%d')
                                at_time_of_day = at_time.strftime('%H:%M:%S')
                                # Get the time zone offset as a string (e.g., '-04:00')
                                start_time_zone_offset = start_time.strftime('%z')
                                start_time_zone_offset = f"{start_time_zone_offset[:-2]}:{start_time_zone_offset[-2:]}"
                                stop_time_zone_offset = stop_time.strftime('%z')
                                stop_time_zone_offset = f"{stop_time_zone_offset[:-2]}:{stop_time_zone_offset[-2:]}"
                                at_time_zone_offset = at_time.strftime('%z')
                                at_time_zone_offset = f"{at_time_zone_offset[:-2]}:{at_time_zone_offset[-2:]}"

                                print(f"Time Entry ID: {entry_id}")
                                print(f"Seconds: {seconds}")
                                print(f"Start Date: {start_date}")
                                print(f"Start Time: {start_time_of_day}")
                                print(f"Start Time Zone Offset: {start_time_zone_offset}")
                                print(f"Stop Date: {stop_date}")
                                print(f"Stop Time: {stop_time_of_day}")
                                print(f"Stop Time Zone Offset: {stop_time_zone_offset}")
                                print(f"Stop Date: {at_date}")
                                print(f"Stop Time: {at_time_of_day}")
                                print(f"Stop Time Zone Offset: {at_time_zone_offset}")
                                print(f"Project Id: {project_id}")

                                existing_record = toggl_user_detail.objects.filter(
                                    employee_id=employee_id,
                                    user_id=user_id,
                                    username=username,
                                    project_id=project_id,
                                    task_id=task_id,
                                    billable=billable,
                                    description=description,
                                    tag_ids=tag_ids,
                                    billable_amount_in_cents=billable_amount_in_cents,
                                    hourly_rate_in_cents=hourly_rate_in_cents,
                                    currency=currency,
                                    time_entries_id=entry_id,
                                    time_entries_seconds=seconds,
                                    time_entries_start_date=start_date,
                                    time_entries_start_time=start_time_of_day,
                                    time_entries_start_time_utc=start_time_zone_offset,
                                    time_entries_stop_date=stop_date,
                                    time_entries_stop_time=stop_time_of_day,
                                    time_entries_stop_time_utc=stop_time_zone_offset,
                                    time_entries_at_date=at_date,
                                    time_entries_at_time=at_time_of_day,
                                    time_entries_at_time_utc=at_time_zone_offset,
                                ).first()
                                print(f"Toggle Details: {project_id}")
                                if not existing_record:
                                    toggl_user1 = toggl_user_detail.objects.create(
                                        employee_id=employee_id,
                                        user_id=user_id,
                                        username=username,
                                        project_id=project_id,
                                        task_id=task_id,
                                        billable=billable,
                                        description=description,
                                        tag_ids=tag_ids,
                                        billable_amount_in_cents=billable_amount_in_cents,
                                        hourly_rate_in_cents=hourly_rate_in_cents,
                                        currency=currency,
                                        time_entries_id=entry_id,
                                        time_entries_seconds=seconds,
                                        time_entries_start_date=start_date,
                                        time_entries_start_time=start_time_of_day,
                                        time_entries_start_time_utc=start_time_zone_offset,
                                        time_entries_stop_date=stop_date,
                                        time_entries_stop_time=stop_time_of_day,
                                        time_entries_stop_time_utc=stop_time_zone_offset,
                                        time_entries_at_date=at_date,
                                        time_entries_at_time=at_time_of_day,
                                        time_entries_at_time_utc=at_time_zone_offset,
                                    )
                                    toggl_user1.save()
                        except Exception as e:
                            pass

                except Exception as e:
                    # Handle other exceptions, you may want to log the error for debugging
                    print(f"An error occurred: {str(e)}")
                    return HttpResponse("An error occurred")
                    # Parse the start and end dates into datetime objects

            elif action == 'Fetch from Database':
                start_date = datetime.strptime(start_date, '%Y-%m-%d')
                end_date = datetime.strptime(end_date, '%Y-%m-%d')
                print("muksna")
                print(start_date)
                print(end_date)
                print(employee_id)

                # Filter records based on the selected date range
                filtered_records = toggl_user_detail.objects.filter(
                    employee_id=employee_id,
                    time_entries_start_date__range=(start_date, end_date)
                    # time_entries_start_date=start_date.strftime('%Y-%m-%d'),
                    # time_entries_stop_date=end_date.strftime('%Y-%m-%d')
                )
                print("filete")
                print(filtered_records)
                # for printing toggl rows
                # Create a list to store the detailed records
                detailed_records = []

                # Iterate through filtered records
                for record in filtered_records:
                    project_id = record.project_id
                    print(project_id)
                    # project_detail = toggl_project_detail.objects.filter(toggl_project_id=project_id).first()
                    # print(project_detail)
                    toggl_project = project.objects.get(toggl_project_id=project_id)
                    toggl_projectid = toggl_project.toggl_project_id
                    toggl_client = toggl_project.toggl_client_id
                    toggl_projectname = toggl_project.toggl_project_name
                    # print(toggl_projectid)
                    # print(toggl_client)
                    print(toggl_projectname)
                    toggl_client = client.objects.get(toggl_client_id=toggl_client)
                    toggl_clientname = toggl_client.toggl_client_name
                    print(toggl_clientname)

                    # Create a dictionary to store the detailed record
                    detailed_record = {
                        'record': record,
                        'toggl_projectname': toggl_projectname,
                        'toggl_clientname': toggl_clientname
                    }

                    # Append the detailed record to the list
                    detailed_records.append(detailed_record)

                print(detailed_records)

                # Create a dictionary to store the total time spent per client and project
                total_time_spent = {}
                project_rate = {}

                for record in filtered_records:
                    # Fetch project details from toggl_project_detail
                    project_id_1 = record.project_id
                    # project_id_2 = project.objects.filter(toggl_project_id=project_id_1).first()
                    # project_id = project_id_2.id
                    time_seconds = record.time_entries_seconds

                    # new
                    project_id_3 = project.objects.get(toggl_project_id=project_id_1)
                    project_salary = project_id_3.rate

                    if project_id_1:
                        client_project_key_1 = int(project_id_1)
                        if client_project_key_1 not in project_rate:
                            # If the key doesn't exist, create it
                            project_rate[client_project_key_1] = project_salary

                    if project_id:
                        client_project_key = int(project_id_1)
                        if client_project_key in total_time_spent:
                            total_time_spent[client_project_key] += time_seconds
                        else:
                            # If the key doesn't exist, create it
                            total_time_spent[client_project_key] = time_seconds
                # Now, total_time_spent dictionary contains the total time spent per client and project
                # You can iterate through it to display the results
                print("fghjbnmkl")
                print(total_time_spent)
                print(project_rate)
                #
                # Convert the total time spent in seconds to hours, minutes, and seconds
                total_time_spent_formatted = {}
                for key, seconds in total_time_spent.items():
                    hours, remainder = divmod(seconds, 3600)
                    minutes, seconds = divmod(remainder, 60)
                    total_time_spent_formatted[key] = f"{hours:02d}:{minutes:02d}:{seconds:02d}"

                # Now, total_time_spent_formatted dictionary contains the total time spent per client and project in HH:MM:SS format
                # You can iterate through it to display the results
                print(total_time_spent_formatted)
                for key, formatted_time in total_time_spent_formatted.items():
                    print(f"Project {key}: {formatted_time}")
                #
                # Initialize dictionaries to store results
                total_time_spent_hours = {}
                project_rate_per_hour = {}

                # Iterate through each project
                for project_id, time_spent in total_time_spent.items():
                    # Convert total_time_spent from seconds to hours
                    time_spent_hours = time_spent / 3600
                    total_time_spent_hours[project_id] = str(time_spent_hours)

                    project_id_2 = project.objects.filter(toggl_project_id=project_id).first()
                    rate = project_id_2.rate

                    if rate:
                        print("if")
                        rate_without_comma = rate.replace(",", "")
                        rate = float(rate_without_comma)
                        hourly_rate = rate / 11
                        total_rate = hourly_rate * time_spent_hours
                        # Format total_rate to have 2 decimal places
                        total_rate_formatted = "{:.2f}".format(total_rate)
                        project_rate_per_hour[project_id] = str(total_rate_formatted)
                    else:
                        print("else")
                        rate = 1000.0
                        hourly_rate = rate / 11
                        total_rate = hourly_rate * time_spent_hours
                        # Format total_rate to have 2 decimal places
                        total_rate_formatted = "{:.2f}".format(total_rate)
                        project_rate_per_hour[project_id] = str(total_rate_formatted)

                    # Print the results
                print("Total Time Spent in Hours:")
                print(total_time_spent_hours)

                print("Project Rate per Hour:")
                print(project_rate_per_hour)

                # Initialize a variable to store the sum of rates
                sum_of_rates = 0.0

                # Iterate through the "Project Rate per Hour" dictionary and add up the rates
                for project_id, rate in project_rate_per_hour.items():
                    sum_of_rates += float(rate)

                sum_of_rates = "{:.2f}".format(sum_of_rates)
                # Print the sum of rates
                print("Sum of Rates:", sum_of_rates)

                # new for employee cost on project
                user = employee.objects.get(id=employee_id)
                user_salary = user.salary
                print(user_salary)

                total_time_spent_employee = {}
                employee_rate_per_hour = {}

                # Iterate through each project
                for project_id, time_spent in total_time_spent.items():
                    # Convert total_time_spent from seconds to hours
                    time_spent_hours = time_spent / 3600
                    total_time_spent_employee[project_id] = str(time_spent_hours)

                    # Divide project_rate by total_time_spent in hours
                    rate = float(user_salary)  # Extract the rate as a float
                    working_days_per_month = 22
                    hours_per_day = 8
                    hourly_rate = rate / (working_days_per_month * hours_per_day)
                    total_rate = hourly_rate * time_spent_hours
                    # Format total_rate to have 2 decimal places
                    total_rate_formatted = "{:.2f}".format(total_rate)
                    employee_rate_per_hour[project_id] = str(total_rate_formatted)

                    # Print the results
                print("total_time_spent_employee:")
                print(total_time_spent_employee)

                print("employee_rate_per_hour:")
                print(employee_rate_per_hour)

                # Initialize a variable to store the sum of rates
                sum_of_rates_employee = 0.0

                # Iterate through the "Project Rate per Hour" dictionary and add up the rates
                for project_id, rate in employee_rate_per_hour.items():
                    sum_of_rates_employee += float(rate)

                # Format total_rate to have 2 decimal places
                sum_of_rates_employee = "{:.2f}".format(sum_of_rates_employee)
                # Print the sum of rates
                print("Sum of Rates Employee:", sum_of_rates_employee)

                employee_info = employee.objects.get(pk=employee_id)
                # # new
                employee_id = employee_info.toggl_user_id

                project_details = toggl_user_detail.objects.filter(user_id=employee_id)
                project_ids = []

                # Iterate through the Toggl user details and collect project IDs
                for detail in project_details:
                    project_id = detail.project_id
                    if project_id not in project_ids:
                        project_ids.append(project_id)

                # Initialize lists to store project and client details
                # project_ids=[]
                project_names = []
                client_names = []

                # Fetch project details based on project IDs
                for project_id in project_ids:
                    project_instance = project.objects.get(toggl_project_id=project_id)
                    # project_ids.append(project_id)
                    project_names.append(project_instance.toggl_project_name)
                    project_client_id = project_instance.toggl_client_id
                    client_instance = client.objects.get(toggl_client_id=project_client_id)
                    client_name = client_instance.toggl_client_name
                    client_names.append(client_name)
                print("kkl")
                print(project_ids)
                print(project_names)
                print(client_names)

                context = {
                    'employee': employee_info,
                    'filtered_records': filtered_records,
                    'detailed_records': detailed_records,
                    'total_time_spent_formatted': total_time_spent_formatted,
                    'projects': projects,
                    'project_rate_per_hour': project_rate_per_hour,
                    'sum_of_rates': sum_of_rates,
                    'employee_rate_per_hour': employee_rate_per_hour,
                    'sum_of_rates_employee': sum_of_rates_employee,
                    'projects_and_clients': zip(project_ids, project_names, client_names),

                }
                return render(request, 'profile.html', context)



    employee_info = employee.objects.get(pk=employee_id)
    employee_detail_instance = None  # Initialize to None before the try block
    try:
        # Fetch the employee_detail instance using the employee_id field
        employee_detail_instance = employee_detail.objects.get(employee_id=employee_id)
    except ObjectDoesNotExist:
        pass

    # Fetch all ContractedHours objects
    if request.method == 'POST':
        from datetime import datetime, timedelta
        from_to_date = request.POST.get('from_to_date', None)

        # Split the string into "from" and "to" dates
        from_date_str, to_date_str = from_to_date.split(" - ")

        # Convert the date strings to datetime objects
        from_date = datetime.strptime(from_date_str, "%m/%d/%Y").date()
        to_date = datetime.strptime(to_date_str, "%m/%d/%Y").date()

        from datetime import datetime

        # Convert from_date and to_date to strings
        from_date_str = from_date.strftime('%Y-%m-%d')
        to_date_str = to_date.strftime('%Y-%m-%d')

        # Convert start_date_str and end_date_str to datetime objects
        start_date = datetime.strptime(from_date_str, '%Y-%m-%d')
        end_date = datetime.strptime(to_date_str, '%Y-%m-%d')


        # Extract the year from the datetime objects
        current_month = start_date.month
        current_year = start_date.year

        start_date_str = start_date.strftime('%Y-%m-%d')
        end_date_str = end_date.strftime('%Y-%m-%d')

        start_year, start_month = from_date.year, from_date.month
        end_year, end_month = to_date.year, to_date.month

        if start_year == end_year:
            all_hours = Client_contract_work.objects.filter(
                date__year=start_year,
                date__month__range=[start_month, end_month],
            )
        else:
            all_hours = Client_contract_work.objects.filter(
                date__year=start_year,
                date__month__gte=start_month,
            ) | Client_contract_work.objects.filter(
                date__year=end_year,
                date__month__lte=end_month,
            )
    else:
        selected_month = request.session.get('month')

        if selected_month:
            current_month = int(selected_month)
        else:
            current_month = 2

        if current_month ==1:
            last_month=12
        else:
            last_month=current_month-1

        selected_year = request.session.get('year')

        if selected_year:
            current_year = int(selected_year)
        else:
            current_year = 2026

        if current_month ==1:
            last_year=current_year-1
        else:
            last_year=current_year


        import calendar
        from datetime import datetime as dt, date

        start_date = date(current_year, current_month, 1)

        # Calculate end date
        if current_month == dt.now().month:  # Ongoing month
            end_date = dt.now().date()

        else:
            end_date=date(current_year, current_month, calendar.monthrange(current_year, current_month)[1])

        start_date_str = start_date.strftime('%Y-%m-%d')
        end_date_str = end_date.strftime('%Y-%m-%d')

        start_month = start_date.month
        end_month = end_date.month

        all_hours = Client_contract_work.objects.filter(date__year=current_year,date__month__range=[start_month, end_month])


    from datetime import date
    project_start_date = date(2025, 1, 1)
    project_list = project.objects.filter(created_at__gte=project_start_date).order_by('-id')
    
    project_data_with_employees = []
    role_mapping = {
        'L': 'Leader',
        'S': 'Support',
        'A': 'Advisor'
    }

    import ast
    for project_data in project_list:
        try:
            roles = ast.literal_eval(project_data.working_role)  # safely convert string to dictionary
        except (ValueError, SyntaxError):
            roles = {}

        role = roles.get(employee_id)

        if role:
            full_role = role_mapping.get(role, role)
            project_data_with_employees.append({
                'project_name': project_data.project_name,
                'company': project_data.company,
                'rate': project_data.rate,
                'role': full_role,
                'start_date': project_data.start_date,
            })

    print("Vinod project_data_with_employees")
    print(project_data_with_employees)
    working_days = count_working_days_in_month(current_month, current_year)

    start_month = start_date.month
    end_month = end_date.month

    weeks=0

    filtered_records={}
    employee_rate_per_hour={}
    total_time_spent_formatted={}
    sum_of_rates_employee=0.0
    client_total_hours={}
    client_hours = {}
    client_data_list = []
    client_revenue={}
    contracted_employee_rate_per_hour={}
    merged_ui_employee={}
    merged_ui_employee3={}
    import calendar
    from datetime import datetime

    for hours in all_hours:            
        try:
            working_input_dict = json.loads(hours.working_input)
            role_dict = json.loads(hours.working_role)
            total_contracted_hours=hours.total_working_hours
            cost=hours.cost
            date=hours.date
            target_month=date.month


            employee1 = employee.objects.get(id=employee_id)
            # employee_salary= employee1.salary
            employee_salary = get_salary_for_date(employee1, date)
            last_name=""
            if employee1.last_name:
                last_name = employee1.last_name
                
            employee_name = employee1.first_name + " " + last_name

            employee_id1=employee_id

            working_input_dict = {key.strip(): value for key, value in working_input_dict.items()}

            if str(employee_id1) in working_input_dict:
                if target_month < start_date.month:  # If target_month is earlier in the year
                    target_year = start_date.year + 1  # Next year
                else:
                    target_year = start_date.year  # Same year

                # Calculate target_month_start
                target_month_start = start_date.replace(year=target_year, month=target_month, day=1)

                # Determine the start_date_in_target_month
                start_date_in_target_month = max(start_date, target_month_start)

                if start_date_in_target_month.month == target_month:
                    from datetime import datetime, timedelta
                    if target_month == 12:
                        next_month_date = start_date_in_target_month.replace(year=start_date_in_target_month.year + 1, month=1, day=1)
                    else:
                        next_month_date = start_date_in_target_month.replace(month=target_month + 1, day=1)

                    target_month_end = min(next_month_date - timedelta(days=1), end_date)
                else:
                    if target_month < start_date_in_target_month.month:
                        target_year = start_date_in_target_month.year + 1
                    else:
                        target_year = start_date_in_target_month.year

                    target_month_start = datetime(target_year, target_month, 1)
                    target_month_end = min(target_month_start - datetime.resolution, end_date)

                if target_month_end.month == start_date_in_target_month.month:
                    total_days_between = (target_month_end - start_date_in_target_month).days + 1
                else:
                    total_days_between = (target_month_end - start_date_in_target_month).days

                date_difference=total_days_between
                # Get the number of days in that month
                days_in_month = calendar.monthrange(date.year, date.month)[1]
                ui_total_weeks = round(days_in_month / 7, 2)

                if date_difference==days_in_month:
                    weeks = round(days_in_month / 7, 2)
                else:
                    weeks = round(date_difference / 7,2)

                hours_for_employee = float(working_input_dict[str(employee_id1)])

                total_hours = float(hours_for_employee) * weeks

                if hours.client_id in client_hours:
                    client_hours[hours.client_id]['total_hours'] += total_hours
                else:
                    client_hours[hours.client_id] = {'total_hours': total_hours}

                # Convert total hours to total seconds
                total_seconds = int(client_hours[hours.client_id]['total_hours'] * 3600)

                # Extracting hours, minutes, and seconds
                hoursss, remainder = divmod(total_seconds, 3600)
                minutes, seconds = divmod(remainder, 60)

                # Formatting the time
                formatted_time = f"{hoursss:02d}:{minutes:02d}:{seconds:02d}"
                if hours.client_id in client_hours:
                    # Update client_hours with formatted time
                    client_hours[hours.client_id]['time'] = formatted_time
                else:
                    # Initialize client_hours with formatted time
                    client_hours[hours.client_id] = {'time': formatted_time}


                #client total time contract
                total_hours1 = float(total_contracted_hours) * weeks

                # Convert total hours to total seconds
                total_seconds1 = int(total_hours1 * 3600)

                # Extracting hours, minutes, and seconds
                hoursss1, remainder1 = divmod(total_seconds1, 3600)
                minutes1, seconds1 = divmod(remainder1, 60)

                # Formatting the time
                formatted_time1 = f"{hoursss1:02d}:{minutes1:02d}:{seconds1:02d}"
                client_total_hours[hours.client_id] = formatted_time1
                ui_employee={}
                ui_employee3={}

                # client revenue
                if total_contracted_hours != 0:
                      client_reven = (float(hours_for_employee)*ui_total_weeks)/(float(total_contracted_hours)*ui_total_weeks)

                else:
                      client_reven=0
                if cost:
                    monthly_hours_ontracted = round(hours_for_employee*weeks,2)

                    Total_weekly_hours_contracted = total_contracted_hours
                    Total_weeks_selected_month = ui_total_weeks
                    Monthly_Working_Contracted = round(Total_weekly_hours_contracted*Total_weeks_selected_month ,2)
                    # Client_Revenue2 = round((cost*monthly_hours_ontracted)/Monthly_Working_Contracted,2)
                    if Monthly_Working_Contracted != 0:
                        Client_Revenue2 = round((cost * monthly_hours_ontracted) / Monthly_Working_Contracted, 2)
                    else:
                        Client_Revenue2 = 0
                    if hours.client_id in client_revenue:
                        client_revenue[hours.client_id] += Client_Revenue2
                    else:
                        client_revenue[hours.client_id] = Client_Revenue2
                    # return HttpResponse(Client_Revenue2)
                else:
                    if hours.client_id in client_revenue:
                        client_revenue[hours.client_id]=client_reven
                    else:
                        client_revenue[hours.client_id] = client_reven


                client1 = client.objects.get(id=hours.client_id)

                new_entry1 = {
                    'ui_employee_name': employee_name,
                    'ui_client_name': client1.toggl_client_name,
                    'ui_total_contracted_hours': total_contracted_hours ,
                    'ui_contracted_hours': hours_for_employee,
                    'ui_cost': cost,
                    'ui_weeks':weeks
                }

                # If the client ID already exists in merged_ui_employee3, append the new entry to a list under that ID
                if str(hours.client_id) in merged_ui_employee:
                    if 'entries' in merged_ui_employee[str(hours.client_id)]:
                        merged_ui_employee[str(hours.client_id)]['entries'].append(new_entry1)
                    else:
                        merged_ui_employee[str(hours.client_id)]['entries'] = [new_entry1]
                # If the client ID doesn't exist, create a new entry with a list containing the new entry
                else:
                    merged_ui_employee[str(hours.client_id)] = {'entries': [new_entry1]}
                #contracted employee cost

                employee_hourly_cost=round(employee_salary /(working_days*8),2)
                if hours.client_id in contracted_employee_rate_per_hour:
                    contracted_employee_rate_per_hour[hours.client_id]+=round(float(employee_hourly_cost)*float(hours_for_employee)*weeks, 2)
                else:
                    contracted_employee_rate_per_hour[hours.client_id]=round(float(employee_hourly_cost)*float(hours_for_employee)*weeks, 2)

                new_entry = {
                    'ui_employee_name': employee_name,
                    'ui_client_name': client1.toggl_client_name,
                    'ui_employee_salary': employee_salary,
                    'ui_contracted_hours': hours_for_employee,
                    'ui_weeks': weeks
                }

                if str(hours.client_id) in merged_ui_employee3:
                    if 'entries' in merged_ui_employee3[str(hours.client_id)]:
                        merged_ui_employee3[str(hours.client_id)]['entries'].append(new_entry)
                    else:
                        merged_ui_employee3[str(hours.client_id)]['entries'] = [new_entry]
                else:
                    merged_ui_employee3[str(hours.client_id)] = {'entries': [new_entry]}

                client1 = client.objects.get(id=hours.client_id)

                client_ids = [client_data['id'] for client_data in client_data_list]
                if client1.id not in client_ids:
                    client_data = {
                        'id': client1.id,
                        'name': client1.toggl_client_name,
                        'img_url': client1.image_url,
                        'toggl_id':client1.toggl_client_id,
                        'company':client1.company_name,
                        'role': role_dict.get(str(employee_id1), "Unknown"),
                    }

                    client_data_list.append(client_data)

                else:
                    for client_data in client_data_list:
                        if client_data['id'] == client1.id:
                            existing_role = client_data['role']
                            new_role = role_dict.get(str(employee_id1), "Unknown")
                            if new_role != existing_role:
                                if existing_role != "Unknown":
                                    if new_role not in existing_role.split(','):
                                        client_data['role'] = existing_role + ',' + new_role
                                else:
                                    client_data['role'] = new_role
                            break



        except (json.JSONDecodeError, ValueError):
            # Handle the case where the JSON parsing fails
            pass

    total_time_spent = {}

    
    timesheets = timeSheet.objects.filter(employee_id=employee_id, time_entries_start_date__range=(start_date, end_date),status=None)

    monthly_time_spent = defaultdict(lambda: defaultdict(int))

    for data in timesheets:
        client_id = data.client_id
        time_spent = data.time_entries_seconds
        entry_date = data.time_entries_start_date
        
        year_month = (entry_date.year, entry_date.month)
        
        monthly_time_spent[year_month][client_id] += time_spent

    # Initialize dictionaries to store formatted time and employee costs
    monthly_client_total_time_spent_formatted = defaultdict(lambda: defaultdict(str))
    monthly_client_tab_employee_cost = defaultdict(lambda: defaultdict(str))

    for year_month, client_times in monthly_time_spent.items():
        year, month = year_month
        # Calculate employee salary for each month
        employee1 = employee.objects.get(id=employee_id)
        employee_salary = get_salary_for_date(employee1, datetime(year, month, 1))
        working_days = count_working_days_in_month(month, year)
        
        for client_id, seconds1 in client_times.items():
            hours, remainder = divmod(seconds1, 3600)
            minutes, seconds2 = divmod(remainder, 60)
            monthly_client_total_time_spent_formatted[year_month][client_id] = f"{hours:02d}:{minutes:02d}:{seconds2:02d}"                
            
            hourly_working = employee_salary / (working_days * 8)
            employee_cost = (seconds1 / 3600) * float(hourly_working)
            monthly_client_tab_employee_cost[year_month][client_id] = "{:.2f}".format(employee_cost)


    # Replace 'employee_id_to_fetch' with the specific employee_id you want to query
    timesheets = timeSheet.objects.filter(employee_id=employee_id,time_entries_start_date__range=(start_date, end_date),status=None)

    for data in timesheets:
        client_id = data.client_id
        time_spent = data.time_entries_seconds
        total_time_spent[client_id] = total_time_spent.get(client_id, 0) + time_spent
    print("weeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee")
    print(total_time_spent)

    employee1 = employee.objects.get(id=employee_id)
    # employee_salary= employee1.salary
    employee_salary = get_salary_for_date(employee1, datetime(current_year, current_month, 1))
    working_days = count_working_days_in_month(current_month, current_year)

    client_total_time_spent_formatted = {}
    client_tab_employee_cost={}
    for key, seconds1 in total_time_spent.items():
        hours, remainder = divmod(seconds1, 3600)
        minutes, seconds2 = divmod(remainder, 60)
        client_total_time_spent_formatted[key] = f"{hours:02d}:{minutes:02d}:{seconds2:02d}"
        hourly_working = employee_salary / (working_days * 8)
        print(seconds1)
        employee_cost = (seconds1 / 3600) * float(hourly_working)
        employee_cost = "{:.2f}".format(employee_cost)
        client_tab_employee_cost[key]=employee_cost
    print(client_tab_employee_cost)
    # Continue with the rest of your existing code, grouping by month and processing accordingly
    result = (
        timeSheet.objects
        .filter(employee_id=employee_id, time_entries_start_date__range=(start_date, end_date),status=None)
        .values('time_entries_start_date', 'client_id', 'category_id', 'description')
        .annotate(total_time=Sum('time_entries_seconds'))
    )

    # Create a dictionary to store the results grouped by client ID and category ID month-wise
    monthly_client_category_info = defaultdict(lambda: defaultdict(lambda: {'client_name': '', 'category_name': '', 'dates': [], 'total_time': 0}))
    variable_counter = 1

    for entry in result:
        entry_date = entry['time_entries_start_date']
        year_month = (entry_date.year, entry_date.month)
        date_str = entry_date.strftime("%A %d %b")
        client_id = entry['client_id']
        category_id = entry['category_id']
        try:
            client_name = client.objects.get(id=client_id).toggl_client_name
        except Exception as e:
            client_name = ''
            
        if category_id == 23:
            category_name = entry['description']  # Using description as category name if available
            key = (client_id, variable_counter)
            variable_counter += 1  # Increment variable counter
        else:
            category_name = Work_Category.objects.get(id=category_id).category
            key = (client_id, category_id)

        monthly_client_category_info[year_month][key]['client_name'] = client_name
        monthly_client_category_info[year_month][key]['category_name'] = category_name
        monthly_client_category_info[year_month][key]['dates'].append(date_str)
        monthly_client_category_info[year_month][key]['total_time'] += entry['total_time']

    # Process dates to be joined as strings
    for month_info in monthly_client_category_info.values():
        for info in month_info.values():
            info['dates'] = ", ".join(info['dates'])

    # Print the results month-wise
    client_category_dict = {}
    ui_employee1 = defaultdict(dict)

    for year_month, client_category_info in monthly_client_category_info.items():
        year, month = year_month
        employee1 = employee.objects.get(id=employee_id)
        employee_salary = get_salary_for_date(employee1, datetime(year, month, 1))
        employee_name = employee1.first_name + " " + employee1.last_name
        working_days = count_working_days_in_month(month, year)
        for key, info in client_category_info.items():
            client_id, category_id = key
            client_name = info['client_name']
            category_name = info['category_name']
            dates = info['dates']
            total_time = info['total_time']
            
            # Convert total_time to hours, minutes, and seconds
            hours, remainder = divmod(total_time, 3600)
            minutes, seconds = divmod(remainder, 60)
            formatted_time = f"{hours:02d}:{minutes:02d}:{seconds:02d}"

            ui_total_time = float(total_time)
            ui_total_time_hours = round(total_time / 3600, 2)
            working_time = round(employee_salary / (working_days * 8), 2)
            working_time = float(working_time)
            employee_cost = round((working_time * ui_total_time_hours), 2)
            
            client_category_dict[(client_id, category_id)] = {
                'client_name': client_name,
                'category_name': category_name,
                'dates': dates,
                'total_time': formatted_time,
                'employee_cost': employee_cost
            }

            ui_employee1[year_month][str(client_id)] = {
                'ui_employee_name': employee_name,
                'ui_client_name': client_name,
                'ui_employee_salary': employee_salary,
                'ui_total_time': total_time,
                'dates': dates
            }

    sum_of_rates_employee = 0

    for year_month, employee_data in ui_employee1.items():
        year, month = year_month
        month_str = datetime(year, month, 1).strftime("%B, %Y")
        
        for entry_id, entry_data in employee_data.items():
            monthly_salary = float(entry_data['ui_employee_salary'])
            ui_total_time = float(entry_data['ui_total_time'])
            ui_total_time_hours = round(ui_total_time / 3600, 2)
            working_time = round(monthly_salary / (working_days * 8), 2)
            total = (working_time * ui_total_time_hours)
            sum_of_rates_employee += total


    # Format the sum
    sum_of_rates_employee = "{:.2f}".format(sum_of_rates_employee)
    sum_of_rates = 0.0
    for client_id, rate in client_revenue.items():
        sum_of_rates += float(rate)

    # Format total_rate to have 2 decimal places
    sum_of_rates = "{:.2f}".format(sum_of_rates)
    contracted_sum_of_rates_employee = 0.0

    # Iterate through the "Project Rate per Hour" dictionary and add up the rates
    for project_id, rate in contracted_employee_rate_per_hour.items():
        contracted_sum_of_rates_employee += float(rate)

    # Format total_rate to have 2 decimal places
    contracted_sum_of_rates_employee = "{:.2f}".format(contracted_sum_of_rates_employee)

    project_details = toggl_user_detail.objects.filter(
        employee_id=employee_id,
        time_entries_start_date__range=(start_date, end_date)
    )

    from django.db import connection
    with connection.cursor() as cursor:
        sql_query = """
            SELECT DISTINCT dec_toggl_user_detail.project_id, dec_client.toggl_client_name, dec_project.toggl_client_id,dec_client.company_name,dec_client.image_url,dec_client.id
            FROM dec_toggl_user_detail
            INNER JOIN dec_project ON dec_toggl_user_detail.project_id = dec_project.toggl_project_id
            INNER JOIN dec_client ON dec_project.toggl_client_id = dec_client.toggl_client_id
            WHERE dec_toggl_user_detail.time_entries_start_date BETWEEN %(start_date)s AND %(end_date)s
            AND dec_toggl_user_detail.employee_id = %(employee_id)s
        """
        params = {'start_date': start_date, 'end_date': end_date,'employee_id':employee_id}

        # Execute the SQL query with parameters
        cursor.execute(sql_query, params)
        project_col = cursor.fetchall()
        unique_clients = set()  # Using a set to store unique client names and IDs
        for row in project_col:
            client_name = row[1]
            client_id = row[2]
            company_name=row[3]
            image_url=row[4]
            id=row[5]


            # Check if the combination of client name and ID is not already in the set
            if (client_name, client_id,company_name,image_url,id) not in unique_clients:
                unique_clients.add((client_name, client_id,company_name,image_url,id))


        # Print the variable containing unique combinations
        for unique_client in unique_clients:

            client_name, client_id,company_name,image_url,id = unique_client

    project_ids = []

    # Iterate through the Toggl user details and collect project IDs
    for detail in project_details:
        project_id = detail.project_id
        if project_id not in project_ids:
            project_ids.append(project_id)

    project_names = []
    client_names = []

    # Fetch project details based on project IDs
    for project_id in project_ids:
        try:
            project_instance = project.objects.get(toggl_project_id=project_id)
            # project_ids.append(project_id)
            project_names.append(project_instance.toggl_project_name)
            project_client_id = project_instance.toggl_client_id
            client_instance = client.objects.get(toggl_client_id=project_client_id)
            client_name = client_instance.toggl_client_name
            client_names.append(client_name)
        except project.DoesNotExist:
            pass

    try:
        employee_country = Country.objects.get(id=employee_info.country_id)
        if employee_country.code == 'US':
            country_city = 'America/New_York'
        elif employee_country.code == 'SA':
            country_city = 'Africa/Johannesburg'
        elif employee_country.code == 'UK':
            country_city = 'Europe/London'
        elif employee_country.code == 'PH':
            country_city = 'Asia/Manila'
        else:
            country_city = 'America/New_York'
    except Exception as e:
        country_city = 'America/New_York'

    files = FileManager.objects.filter(employee_id = employee_id).order_by('-id').all()

    for file in files:
        file.file_name = file.file.name.split('/')[-1]
        if(file.uploaded_by !='' and file.uploaded_by != None):
            file.uploaded_by = employee.objects.filter(user_id=file.uploaded_by).values('id', 'first_name','last_name','image_url').first()
        else:
            file.uploaded_by = ''

    context = {
        'files': files,
        'filtered_records': filtered_records,
        # 'detailed_records': detailed_records,
        'sum_of_rates_employee': sum_of_rates_employee,
        'employee_rate_per_hour': employee_rate_per_hour,
        'sum_of_rates': sum_of_rates,
        # 'project_rate_per_hour': project_rate_per_hour,
        # 'client_rate_per_hour':client_rate_per_hour,
        'total_time_spent_formatted': total_time_spent_formatted,
        'client_total_time_spent_formatted':client_total_time_spent_formatted,
        'employee': employee_info,
        'employee_salary': employee_detail_instance,
        'projects_and_clients': zip(project_ids, project_names, client_names),
        'contracted_sum_of_rates_employee':contracted_sum_of_rates_employee,
        'unique_clients': unique_clients,
        'client_data_list':client_data_list,
        'client_hours':client_hours,
        'current_month': current_month,
        'current_year': current_year,
        'allowed_months': [9, 10, 11, 12],
        # 'entries':entries,
        'client_category_dict': client_category_dict,
        'client_revenue':client_revenue,
        'contracted_employee_rate_per_hour':contracted_employee_rate_per_hour,
        'client_total_hours':client_total_hours,
        'client_tab_employee_cost':client_tab_employee_cost,
        'start_date': start_date_str,
        'end_date': end_date_str,
        'weeks':weeks,
        'ui_employee':merged_ui_employee,
        'ui_employee_time':ui_employee1,
        'ui_employee_time1':merged_ui_employee3,
        'project_data_with_employees':project_data_with_employees,
        'my_profile_tab':my_profile_tab,
        'country_timezone': country_city
    }

    return render(request, 'employees/profile.html', context)


@csrf_exempt
@login_required(login_url='/')
def clients_id(request):
    if request.method == 'GET':

        print("ss")

        import requests
        from base64 import b64encode

        # Replace placeholders with your actual data
        workspace_id = '4007366'
        email = 'jharna.agrawal@brickwin.com'
        password = 'Newsystem@1234'

        # Define the API URL with the workspace_id placeholder replaced
        url = f'https://api.track.toggl.com/api/v9/workspaces/{workspace_id}/clients'

        # Encode the email and password for Basic Authentication
        auth_header = 'Basic ' + b64encode(f"{email}:{password}".encode("ascii")).decode("ascii")

        # Make the POST request with headers and JSON data
        response = requests.get(url, headers={'Content-Type': 'application/json', 'Authorization': auth_header})

        if response.status_code == 200:  # Check if the request was successful (status code 200)
            response_data = response.json()  # Parse the JSON content of the response
            print(response_data)

            for entry in response_data:
                id = entry.get('id')
                name = entry.get('name')

                print(f"client ID: {id}")
                print(f"Client name: {name}")

                # Check if the employee with the same UID exists in the database
                existing_client = client.objects.filter(toggl_client_id=id).first()

                if not existing_client:
                    # If the employee with the same UID doesn't exist, create a new employee in the database
                    new_client = client(toggl_client_id=id,toggl_client_name=name)
                    new_client.save()

        else:
            print(f"Failed to fetch data. Status code: {response.status_code}")

    return render(request,"clients_id.html",{})

@csrf_exempt
@login_required(login_url='/')
def current_clients(request):
    active = [''] * 15
    active[8] = 'active'
    if request.method == 'POST':
        client_name = request.POST.get('client_name')
        email = request.POST.get('email')
        doe = request.POST.get('doe')
        phone = request.POST.get('phone')
        company_name = request.POST.get('company_name')
        designation = request.POST.get('designation')
        address = request.POST.get('address')
        gender = request.POST.get('gender')

        new_client = client(
            client_name=client_name,
            email=email,
            date_of_birth=doe,
            phone=phone,
            company_name=company_name,
            designation=designation,
            address=address,
            gender=gender,

        )
        new_client.save()
        # Redirect to a success page or another appropriate view
        return redirect('admin-dashboard')
    # client_list = client.objects.all()  # Fetch all employees from the database
    selected_month = request.session.get('month')
    import calendar
    from datetime import date

    if selected_month:
        # current_month = datetime.strptime(selected_month, "%B").month
        current_month = int(selected_month)
    else:
        current_month = 2

    if current_month ==1:
        last_month=12
    else:
        last_month=current_month-1
    print("ssssssssssssssssssssssssssssssssssssss")
    print(current_month)
    print(last_month)

    selected_year = request.session.get('year')

    if selected_year:
        # current_month = datetime.strptime(selected_month, "%B").month
        current_year = int(selected_year)
    else:
        current_year = datetime.now().year

    if current_month ==1:
        last_year=current_year-1
    else:
        last_year=current_year

    start_date = date(current_year, current_month, 1)
    end_date = date(current_year, current_month, calendar.monthrange(current_year, current_month)[1])
    if request.user.groups.exists():
        group = request.user.groups.all()
        print("exist group")
        print(group)

        if group[0].name == 'admin' or group[0].name == 'super_admin'or group[0].name == 'super_user':
            print("super admin or admin ")
            if current_year == 2023 and 9 <= current_month <= 12:
                client_contract_work = contracted_hours.objects.filter(month__gte=start_date, month__lte=end_date)

                # Fetch client information for each client contract work
                client_contract_work_with_client_info = []
                for work in client_contract_work:
                    client_info = client.objects.get(toggl_client_id=work.client_id)
                    client_contract_work_with_client_info.append((work, client_info))

                # Extract client objects from the list
                client_list = [client_info for _, client_info in client_contract_work_with_client_info]

                employee_list = employee.objects.filter(status=1).all()
                context = {
                    "client_list": client_list,
                    "active":active,
                    'selected_month':current_month,
                    'current_year':current_year,
                    'employee_list':employee_list,
                }

                return render(request, "current_clients.html", context)
            else:

                client_contract_work = Client_contract_work.objects.filter(date__gte=start_date, date__lte=end_date)

                # Fetch client information for each client contract work
                client_contract_work_with_client_info = []
                for work in client_contract_work:
                    client_info = client.objects.get(id=work.client_id)
                    client_contract_work_with_client_info.append((work, client_info))

                # Extract client objects from the list
                client_list = [client_info for _, client_info in client_contract_work_with_client_info]

                employee_list = employee.objects.filter(status=1).all()
                context = {
                    "client_list": client_list,
                    "active":active,
                    'selected_month':current_month,
                    'current_year':current_year,
                    'employee_list':employee_list,
                }

                return render(request, "current_clients.html", context)
    group = None

    if request.user.groups.exists():
        group = request.user.groups.all()
        print("exist group")
        print(group)

        if group[0].name == 'admin' or group[0].name == 'super_admin' or group[0].name == 'super_user':
            print("admin")
            if current_year == 2023 and 9 <= current_month <= 12:
                client_contract_work = contracted_hours.objects.filter(month__gte=start_date, month__lte=end_date)

                # Fetch client information for each client contract work
                client_contract_work_with_client_info = []
                for work in client_contract_work:
                    client_info = client.objects.get(toggl_client_id=work.client_id)
                    client_contract_work_with_client_info.append((work, client_info))

                # Extract client objects from the list
                client_list = [client_info for _, client_info in client_contract_work_with_client_info]

                employee_list = employee.objects.filter(status=1).all()
                context = {
                    "client_list": client_list,
                    "active":active,
                    'selected_month':current_month,
                    'current_year':current_year,
                    'employee_list':employee_list,
                }

                return render(request, "current_clients.html", context)
            else:

                client_contract_work = Client_contract_work.objects.filter(date__gte=start_date, date__lte=end_date)

                # Fetch client information for each client contract work
                client_contract_work_with_client_info = []
                for work in client_contract_work:
                    client_info = client.objects.get(id=work.client_id)
                    client_contract_work_with_client_info.append((work, client_info))

                # Extract client objects from the list
                client_list = [client_info for _, client_info in client_contract_work_with_client_info]

                employee_list = employee.objects.filter(status=1).all()
                context = {
                    "client_list": client_list,
                    "active":active,
                    'selected_month':current_month,
                    'current_year':current_year,
                    'employee_list':employee_list,
                }

                return render(request, "current_clients.html", context)


    else:
        if current_year == 2023 and 9 <= current_month <= 12:
                client_contract_work = contracted_hours.objects.filter(month__gte=start_date, month__lte=end_date)

                # Fetch client information for each client contract work
                client_contract_work_with_client_info = []
                for work in client_contract_work:
                    client_info = client.objects.get(toggl_client_id=work.client_id)
                    client_contract_work_with_client_info.append((work, client_info))

                # Extract client objects from the list
                client_list = [client_info for _, client_info in client_contract_work_with_client_info]

                employee_list = employee.objects.filter(status=1).all()
                context = {
                    "client_list": client_list,
                    "active":active,
                    'selected_month':current_month,
                    'current_year':current_year,
                    'employee_list':employee_list,
                }

                return render(request, "current_clients.html", context)
        else:

            client_contract_work = Client_contract_work.objects.filter(date__gte=start_date, date__lte=end_date)

            # Fetch client information for each client contract work
            client_contract_work_with_client_info = []
            for work in client_contract_work:
                client_info = client.objects.get(id=work.client_id)
                client_contract_work_with_client_info.append((work, client_info))

            # Extract client objects from the list
            client_list = [client_info for _, client_info in client_contract_work_with_client_info]

            employee_list = employee.objects.filter(status=1).all()
            context = {
                "client_list": client_list,
                "active":active,
                'selected_month':current_month,
                'current_year':current_year,
                'employee_list':employee_list,
            }

            return render(request, "current_clients.html", context)

@csrf_exempt
@login_required(login_url='/')
def all_clients(request):
     active = [''] * 15
     active[13] = 'active'
     client_list = client.objects.filter(status=1).all()
     print(client_list)
     return render(request, "all_client.html", {"client_list": client_list,"active":active})

@csrf_exempt
@login_required(login_url='/')
def archived_clients(request):
    active = [''] * 15
    active[9] = 'active'
    selected_month = request.session.get('month')
    import calendar
    from datetime import date

    if selected_month:
        # current_month = datetime.strptime(selected_month, "%B").month
        current_month = int(selected_month)
    else:
        current_month = 2

    if current_month ==1:
        last_month=12
    else:
        last_month=current_month-1
    print("ssssssssssssssssssssssssssssssssssssss")
    print(current_month)
    print(last_month)

    selected_year = request.session.get('year')

    if selected_year:
        # current_month = datetime.strptime(selected_month, "%B").month
        current_year = int(selected_year)
    else:
        current_year = 2026

    if current_month ==1:
        last_year=current_year-1
    else:
        last_year=current_year


    client_list = client.objects.filter(status=2).all().order_by('image_url')
    print(client_list)
    return render(request, "archived_clients.html", {"client_list": client_list,"active":active})

@csrf_exempt
@login_required(login_url='/')
def update_client_status_2(request):
    if request.method == 'POST':
        print("iffffffffffffffclientstatus2")
        client_id = request.POST.get('id')
        new_status = request.POST.get('status')

        print(client_id)
        print(new_status)

        try:
            client1 = client.objects.get(id=client_id)
            client1.status = new_status
            client1.save()
            return JsonResponse({'message': 'Employee status updated successfully.'})
        except employee.DoesNotExist:
            return JsonResponse({'error': 'Employee not found.'}, status=404)

    return JsonResponse({'error': 'Invalid request.'}, status=400)

@csrf_exempt
@login_required(login_url='/')
def update_client_status_1(request):
    if request.method == 'POST':
        print("iffffffffffffff")
        client_id = request.POST.get('id')
        new_status = request.POST.get('status')

        print(client_id)
        print(new_status)

        try:
            client1 = client.objects.get(id=client_id)
            client1.status = new_status
            client1.save()
            return JsonResponse({'message': 'Employee status updated successfully.'})
        except employee.DoesNotExist:
            return JsonResponse({'error': 'Employee not found.'}, status=404)

    return JsonResponse({'error': 'Invalid request.'}, status=400)









@csrf_exempt
@login_required(login_url='/')
def client_profile(request, client_id):
    import calendar
    from datetime import datetime, timedelta
    from datetime import date
    if request.method == 'POST':

        from datetime import datetime, timedelta
        from_to_date = request.POST.get('from_to_date', None)

        from_date_str, to_date_str = from_to_date.split(" - ")

        from_date = datetime.strptime(from_date_str, "%m/%d/%Y").date()
        to_date = datetime.strptime(to_date_str, "%m/%d/%Y").date()

        from datetime import datetime

        from_date_str = from_date.strftime('%Y-%m-%d')
        to_date_str = to_date.strftime('%Y-%m-%d')

        # Convert start_date_str and end_date_str to datetime objects
        start_date = datetime.strptime(from_date_str, '%Y-%m-%d')
        end_date = datetime.strptime(to_date_str, '%Y-%m-%d')

        start_date_str = start_date.strftime('%Y-%m-%d')
        end_date_str = end_date.strftime('%Y-%m-%d')

        start_date = datetime.strptime(start_date_str, '%Y-%m-%d')
        end_date = datetime.strptime(end_date_str, '%Y-%m-%d')

        print(f"Start date (Monday): {start_date}")
        print(f"End date (Sunday): {end_date}")

        # Extract the year from the datetime objects
        current_month = start_date.month
        current_year = start_date.year

        start_date_str = start_date.strftime('%Y-%m-%d')
        end_date_str = end_date.strftime('%Y-%m-%d')

        start_year, start_month = from_date.year, from_date.month
        end_year, end_month = to_date.year, to_date.month

    else:
        from datetime import datetime, date
        import calendar

        selected_month = request.session.get('month')

        if selected_month:
            current_month = int(selected_month)
        else:
            current_month = 2

        if current_month == 1:
            last_month = 12
        else:
            last_month = current_month - 1

        selected_year = request.session.get('year')

        if selected_year:
            current_year = int(selected_year)
        else:
            current_year = 2026

        if current_month == 1:
            last_year = current_year - 1
        else:
            last_year = current_year

        current_date = datetime.now()

        if current_month == current_date.month:
            start_date = current_date - timedelta(days=current_date.weekday())
            end_date = start_date + timedelta(days=6)
        else:
            start_date = datetime(current_year, current_month, 1, 0, 0, 0)
            end_date = datetime(current_year, current_month, calendar.monthrange(current_year, current_month)[1], 23,
                                59, 59)

        start_date_str = start_date.strftime('%Y-%m-%d %H:%M:%S')
        end_date_str = end_date.strftime('%Y-%m-%d %H:%M:%S')

        start_year, start_month = start_date.year, start_date.month
        end_year, end_month = end_date.year, end_date.month

    if start_date and end_date:
        start_date = start_date.date()
        end_date = end_date.date()

    # Get the start and end months
    start_month = start_date.month
    end_month = end_date.month

    current_date_now = datetime.now().date()
    # show_button = (start_date.year == current_date_now.year and
    #                end_date.year == current_date_now.year and
    #                start_month == current_date_now.month and
    #                end_month == current_date_now.month)

    # show_button = (start_date <= current_date_now <= end_date)

    start_of_week = current_date_now - timedelta(days=current_date_now.weekday())
    end_of_week = start_of_week + timedelta(days=6)
    # show_button = (
    #     start_date <= current_date_now and
    #     (end_date >= start_of_week and end_date <= end_of_week)
    # )
    # show_button = (
    #     start_date <= current_date_now and  # Current date is after or equal to start date
    #     ((end_date >= start_of_week and end_date <= end_of_week) or end_date.month == current_date_now.month)  # End date is within this week or same month
    # )

    start_in_current_month = start_date.year == current_date_now.year and start_date.month == current_date_now.month
    end_in_current_month = end_date.year == current_date_now.year and end_date.month == current_date_now.month

    show_button = (
        (start_in_current_month or end_in_current_month) and
        start_date <= current_date_now
    )
    selected_month = end_date.month

    weeks = 0
    ui_final_cost = {}
    ui_total_hours = {}
    ui_formatted_time2 = {}
    ui_data = {}
    ui = {}
    working_days = count_working_days_in_month(current_month, current_year)

    client_detail = client.objects.get(pk=client_id)
    toggl_client = client_detail.toggl_client_id

    employee_details = {}
    employee_details2 = {}
    client_details = {}
    ui_client_data = []
    buddy_ids = []
    advisor_ids = []
    consultant_ids = []
    consultant_details = {}

    if start_year == end_year:
        query = Q(date__year=start_year, date__month__range=[start_month, end_month])
    else:
        query = (
                Q(date__year=start_year, date__month__gte=start_month) |
                Q(date__year=end_year, date__month__lte=end_month)
        )


    print('YEAR AND MONTH', start_year, end_year, start_month, end_month, query)
    if Client_contract_work.objects.filter(client_id=client_id).filter(query).exists():
        contracts = Client_contract_work.objects.filter(client_id=client_id).filter(query)
        print(contracts, 'TEST Contract')
        for contract in contracts:
            ui_final_cost = contract.cost
            date = contract.date
            target_month = date.month

            work_json_str = contract.working_input
            work_dict = json.loads(work_json_str)
            role_json_str = contract.working_role
            role_dict = json.loads(role_json_str)
            working_week = calculate_month_weeks(start_date, end_date)
            print("Vinod start_date :", start_date)
            print("end_date :", end_date)
            print("working_week :", working_week)
            try:
                working_week_count = working_week[target_month]
            except KeyError:
                working_week_count = 0

            # if start_date.month == 12 and start_date.day in[29,30,31] and end_date.month != 12 and end_date.day not in[29,30,31]:
            #     if target_month ==12:
            #         working_week_count = 0
            if start_date.month == 12 and end_date.day in [1, 2, 3, 4, 5] and end_date.year == 2026:
                if target_month == 12:
                    working_week_count = working_week[target_month]
                    working_week_count = working_week_count - 1
            print(work_dict, 'work dict')
            for employee_id, hours in work_dict.items():
                print(hours, working_week_count, 'HOURS WORK WEEK')
                try:
                    hours = float(hours)
                    employee1 = employee.objects.get(id=int(employee_id))
                    if employee1.first_name and employee1.last_name:
                        employee_name = f"{employee1.first_name} {employee1.last_name}"
                    else:
                        employee_name = employee1.user_name

                    image_url = employee1.image_url if hasattr(employee1,
                                                               'image_url') else "/static/assets/img/client/default-profile-pic.jpg"
                    salary = get_salary_for_date(employee1, date)
                    role = role_dict.get(employee_id, "")
                    if 'B' in role:
                        buddy_ids.append(int(employee_id))

                    if 'A' in role:
                        advisor_ids.append(int(employee_id))

                    if 'C' in role:
                        consultant_ids.append(int(employee_id))

                    if 'C' in role:
                        consultant_details[int(employee_id)] = hours

                    if int(employee_id) in employee_details2:
                        employee_details2[int(employee_id)]['total_hours'] += hours * working_week_count
                        current_roles = set(employee_details2[int(employee_id)]['role'])
                        new_role = role_dict.get(employee_id)
                        if new_role not in current_roles:
                            employee_details2[int(employee_id)]['role'] = list(current_roles | {new_role})

                    else:
                        employee_details2[int(employee_id)] = {
                            'name': employee_name,
                            'image_url': image_url,
                            'id': employee1.id,
                            'salary': salary,
                            'role': role,
                            'total_hours': hours * working_week_count
                        }

                except ValueError:
                    print(f"Invalid hours value for employee_id {employee_id}: {hours} in contract {contract.id}")
                except employee.DoesNotExist:
                    employee_details2[int(employee_id)] = {
                        'name': f"Employee {employee_id} not found",
                        'image_url': "/static/assets/img/client/default-profile-pic.jpg"
                    }

        for employee_id, details in employee_details2.items():
            total_seconds = int(details['total_hours'] * 3600)
            hoursss, remainder = divmod(total_seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            formatted_time = f"{hoursss:02d}:{minutes:02d}:{seconds:02d}"
            details['hours_worked'] = formatted_time
            if details['total_hours'] > 0:
                details[
                    'formula'] = "To convert decimal hours to hours and minutes, separate the whole number for hours, then multiply the decimal part by 60 to get minutes."
            else:
                details['formula'] = ""

        print(f"employee_details2 {employee_details2} ")

    from datetime import date
    project_start_date = date(2025, 1, 1)
    project_list2 = project.objects.filter(client_id=client_id, created_at__gte=project_start_date).order_by('-id')[:5]
    print("Vinod project_list2")
    print(project_list2)

    project_data_with_employees = []
    import ast
    for project_data in project_list2:
        employee_details_by_role = {
            'L': [],
            'S': [],
            'A': []
        }

        working_roles = ast.literal_eval(project_data.working_role)

        for employee_id, role in working_roles.items():
            if role not in employee_details_by_role:
                continue

            if employee_id not in [emp['id'] for emp in employee_details_by_role[role]]:
                try:
                    employee_data = employee.objects.get(id=employee_id)
                    employee_details_by_role[role].append({
                        'name': f"{employee_data.first_name} {employee_data.last_name}",
                        'id': employee_data.id,
                        'image_url': employee_data.image_url,
                        'role': role
                    })
                except employee.DoesNotExist:
                    continue

        project_data_with_employees.append({
            'project': project_data,
            'employee_details_by_role': employee_details_by_role
        })

    if Client_contract_work.objects.filter(client_id=client_id).filter(query).exists():
        all = Client_contract_work.objects.filter(client_id=client_id).filter(query)

        # Iterate over each record in the queryset
        for record in all:
            first_record = record
            ui_final_cost = first_record.cost
            date1 = first_record
            date = date1.date
            target_month = date.month

            work_json_str = first_record.working_input

            work_dict = json.loads(work_json_str)
            role_json_str = first_record.working_role
            role_dict = json.loads(role_json_str)
            print('SUPER ADMIN', work_dict)
            for employee_id, hours in work_dict.items():
                try:
                    employee1 = employee.objects.get(id=int(employee_id))

                    if employee1.first_name and employee1.last_name:
                        employee_name = f"{employee1.first_name} {employee1.last_name}"
                    else:
                        employee_name = employee1.user_name

                    image_url = employee1.image_url if hasattr(employee1,
                                                               'image_url') else "/static/assets/img/client/default-profile-pic.jpg"

                    id = employee1.id
                    # salary=employee1.salary
                    salary = get_salary_for_date(employee1, date)
                    # Store employee details
                    # Get the role
                    role = role_dict.get(employee_id, "")

                    import calendar
                    from datetime import datetime

                    if target_month < start_date.month:  # If target_month is earlier in the year
                        target_year = start_date.year + 1  # Next year
                    else:
                        target_year = start_date.year  # Same year

                    # Calculate target_month_start
                    target_month_start = start_date.replace(year=target_year, month=target_month, day=1)
                    start_date_in_target_month = max(start_date, target_month_start)

                    if start_date_in_target_month.month == target_month:
                        if target_month == 12:
                            next_month_date = start_date_in_target_month.replace(
                                year=start_date_in_target_month.year + 1, month=1, day=1)
                        else:
                            next_month_date = start_date_in_target_month.replace(month=target_month + 1, day=1)
                        target_month_end = min(next_month_date - timedelta(days=1), end_date)
                    else:
                        if target_month < start_date_in_target_month.month:
                            target_year = start_date_in_target_month.year + 1
                        else:
                            target_year = start_date_in_target_month.year

                        target_month_start = datetime(target_year, target_month, 1)
                        target_month_end = min(target_month_start - datetime.resolution, end_date)

                    # Calculate the total days in the target month between the start and end dates
                    if target_month_end.month == start_date_in_target_month.month:
                        total_days_between = (target_month_end - start_date_in_target_month).days + 1
                    else:
                        total_days_between = (target_month_end - start_date_in_target_month).days

                    date_difference = total_days_between
                    # Get the number of days in that month
                    days_in_month = calendar.monthrange(date.year, date.month)[1]
                    ui_total_weeks = round(days_in_month / 7, 2)
                    # print(days_in_month)

                    if date_difference == days_in_month:
                        # weeks=4.3
                        weeks = round(days_in_month / 7, 2)
                        weeks = round(weeks, 2)
                    else:
                        weeks = date_difference / 7
                        weeks = round(weeks, 2)

                    # Convert hours to an integer
                    hours = float(hours)

                    if int(employee_id) in employee_details:
                        employee_details[int(employee_id)]['total_hours'] += hours
                        total_hours = float(employee_details[int(employee_id)]['total_hours']) * weeks
                    else:
                        total_hours = float(hours) * weeks

                    # Convert total hours to total seconds
                    total_seconds = int(total_hours * 3600)

                    # Extracting hours, minutes, and seconds
                    hoursss, remainder = divmod(total_seconds, 3600)
                    minutes, seconds = divmod(remainder, 60)

                    # Formatting the time
                    formatted_time = f"{hoursss:02d}:{minutes:02d}:{seconds:02d}"

                    if int(employee_id) in employee_details:
                        new_role = role_dict.get(employee_id)
                        # Use set to avoid duplicates
                        current_roles = set(employee_details[int(employee_id)]['role'])
                        if new_role not in current_roles:
                            # Convert back to list after ensuring it's not already a list
                            employee_details[int(employee_id)]['role'] = list(current_roles | {new_role})

                        # Add hours worked to existing hours
                        employee_details[int(employee_id)]['hours_worked'] = formatted_time
                    else:
                        employee_details[int(employee_id)] = {'name': employee_name, 'image_url': image_url, 'id': id,
                                                              'salary': salary, 'role': role,
                                                              'hours_worked': formatted_time, 'total_hours': hours}
                except employee.DoesNotExist:
                    employee_details[int(employee_id)] = {'name': f"Employee {employee_id} not found",
                                                          'image_url': "/static/assets/img/client/default-profile-pic.jpg"}

            # client total time contract
            if first_record.total_working_hours:

                import calendar
                from datetime import datetime

                if target_month < start_date.month:  # If target_month is earlier in the year
                    target_year = start_date.year + 1  # Next year
                else:
                    target_year = start_date.year  # Same year

                # Calculate target_month_start
                target_month_start = start_date.replace(year=target_year, month=target_month, day=1)
                start_date_in_target_month = max(start_date, target_month_start)

                if start_date_in_target_month.month == target_month:
                    if target_month == 12:
                        next_month_date = start_date_in_target_month.replace(year=start_date_in_target_month.year + 1,
                                                                             month=1, day=1)
                    else:
                        next_month_date = start_date_in_target_month.replace(month=target_month + 1, day=1)
                    target_month_end = min(next_month_date - timedelta(days=1), end_date)
                else:
                    if target_month < start_date_in_target_month.month:
                        target_year = start_date_in_target_month.year + 1
                    else:
                        target_year = start_date_in_target_month.year

                    target_month_start = datetime(target_year, target_month, 1)
                    target_month_end = min(target_month_start - datetime.resolution, end_date)
                # print(target_month_end)
                # Calculate the total days in the target month between the start and end dates
                if target_month_end.month == start_date_in_target_month.month:
                    total_days_between = (target_month_end - start_date_in_target_month).days + 1
                else:
                    total_days_between = (target_month_end - start_date_in_target_month).days

                date_difference = total_days_between

                days_in_month = calendar.monthrange(date.year, date.month)[1]

                if date_difference == days_in_month:
                    # weeks=4.3
                    weeks = round(days_in_month / 7, 2)
                    weeks = round(weeks, 2)
                else:
                    weeks = date_difference / 7
                total_hours1 = float(first_record.total_working_hours) * weeks
                ui_total_hours = first_record.total_working_hours
            else:
                total_hours1 = 0
                ui_total_hours = 0

            if 'total_time_hours' in client_details:
                client_details['total_time_hours'] += total_hours1
            else:
                client_details['total_time_hours'] = total_hours1

            # Convert total hours to total seconds
            total_seconds1 = int(client_details['total_time_hours'] * 3600)

            # Extracting hours, minutes, and seconds
            hoursss1, remainder1 = divmod(total_seconds1, 3600)
            minutes1, seconds1 = divmod(remainder1, 60)

            import calendar
            from datetime import datetime
            # Calculate the difference between end_date and start_date

            if target_month < start_date.month:  # If target_month is earlier in the year
                target_year = start_date.year + 1  # Next year
            else:
                target_year = start_date.year  # Same year

            # Calculate target_month_start
            target_month_start = start_date.replace(year=target_year, month=target_month, day=1)
            start_date_in_target_month = max(start_date, target_month_start)

            if start_date_in_target_month.month == target_month:
                if target_month == 12:
                    next_month_date = start_date_in_target_month.replace(year=start_date_in_target_month.year + 1,
                                                                         month=1, day=1)
                else:
                    next_month_date = start_date_in_target_month.replace(month=target_month + 1, day=1)
                target_month_end = min(next_month_date - timedelta(days=1), end_date)
            else:
                if target_month < start_date_in_target_month.month:
                    target_year = start_date_in_target_month.year + 1
                else:
                    target_year = start_date_in_target_month.year

                target_month_start = datetime(target_year, target_month, 1)
                target_month_end = min(target_month_start - datetime.resolution, end_date)

            if target_month_end.month == start_date_in_target_month.month:
                total_days_between = (target_month_end - start_date_in_target_month).days + 1
            else:
                total_days_between = (target_month_end - start_date_in_target_month).days

            date_difference = total_days_between

            days_in_month = calendar.monthrange(date.year, date.month)[1]
            ui_total_weeks = round(days_in_month / 7, 2)

            if date_difference == days_in_month:
                # weeks=4.3
                weeks = round(days_in_month / 7, 2)
                weeks = round(weeks, 2)
                cost_new = first_record.cost
            else:
                weeks = date_difference / 7
                weeks = round(weeks, 2)
                c = round((first_record.cost * weeks), 2)
                cost_new = round((c) / ui_total_weeks, 2)

            # Formatting the time
            formatted_time2 = f"{hoursss1:02d}:{minutes1:02d}:{seconds1:02d}"
            ui_formatted_time2 = formatted_time2

            if 'cost' in client_details:
                client_details['cost'] += cost_new
                client_details['total_working_hours'] = formatted_time2
            else:
                client_details['cost'] = cost_new
                client_details['total_working_hours'] = formatted_time2
                client_details['total_time_hours'] = total_hours1

            client_details['cost'] = round(client_details['cost'], 2)
            # return HttpResponse(cost_new)
            ui_client_data1 = {

                'ui_cost': first_record.cost,
                'ui_weeks': weeks,
                'ui_date_difference': date_difference
            }

            # Append this dictionary to the list
            ui_client_data.append(ui_client_data1)
            # Print the employee details
            for employee_id, details in employee_details.items():
                print(
                    f"Employee ID: {employee_id}, Employee Name: {details['name']}, Image URL: {details['image_url']}")
    else:
        print("No contracted hours found for the specified client.")

    unique_category_ids = timeSheet.objects.filter(client_id=client_id,
                                                   time_entries_start_date__range=(start_date, end_date),
                                                   status=None).values('category_id').distinct()

    # Prepare a list to store client and category information
    client_category_list = []

    # Iterate over unique category IDs and fetch corresponding category names
    for unique_category_id in unique_category_ids:

        category_id = unique_category_id['category_id']

        try:
            category_1 = Work_Category.objects.get(id=category_id)
            category_name = category_1.category

            # Append client and category information to the list
            client_category_list.append({'id': category_id, 'category_name': category_name})

        except Work_Category.DoesNotExist:
            print(f"Category with ID {category_id} does not exist in the WorkCategory table.")

    # Get unique timeSheet entries for a specific client
    unique_timesheet_entries = timeSheet.objects.filter(client_id=client_id,
                                                        time_entries_start_date__range=(start_date, end_date),
                                                        status=None).values('category_id', 'employee_id').distinct()

    # Prepare a dictionary to store employee information
    employee_info_dict = {}

    # Iterate over unique timeSheet entries
    for timesheet_entry in unique_timesheet_entries:
        category_id = timesheet_entry['category_id']
        employee_id = timesheet_entry['employee_id']

        # Fetch the employee from the Employee table
        try:
            employee1 = employee.objects.get(id=employee_id)
            employee_name = f"{employee1.first_name} {employee1.last_name}"
            employee_image_url = employee1.image_url
            # employee_salary = employee1.salary
            employee_salary = get_salary_for_date(employee1, start_date)

            # Check if the category exists in the dictionary, if not, create an entry
            if category_id not in employee_info_dict:
                employee_info_dict[category_id] = []

            # Append employee information to the dictionary
            employee_info_dict[category_id].append({
                'id': employee_id,
                'name': employee_name,
                'image_url': employee_image_url,
                'salary': employee_salary
            })

        except employee.DoesNotExist:
            print(f"Employee with ID {employee_id} does not exist in the Employee table.")

    total_time_spent_by_category = timeSheet.objects.filter(client_id=client_id,
                                                            time_entries_start_date__gte=start_date,
                                                            time_entries_stop_date__lte=end_date,
                                                            status=None) \
        .values('category_id') \
        .annotate(total_time=Sum('time_entries_seconds'))

    # Create a dictionary to store category_id and total time spent
    category_time_dict = {}

    # Loop through the results to populate the dictionary
    for entry in total_time_spent_by_category:
        category_id = entry['category_id']
        total_time_spent_seconds = entry['total_time']

        # Convert total_time_spent_seconds to a more readable format
        total_time_spent_hours, remainder = divmod(total_time_spent_seconds, 3600)
        total_time_spent_minutes, total_time_spent_seconds = divmod(remainder, 60)

        # Store the values in the dictionary
        category_time_dict[category_id] = {
            'formatted_time': f"{total_time_spent_hours:02d}:{total_time_spent_minutes:02d}:{total_time_spent_seconds:02d}",
            'total_time_seconds': entry['total_time'],
            'hours': total_time_spent_hours,
            'minutes': total_time_spent_minutes,
            'seconds': total_time_spent_seconds
        }

    # Print or use the category_time_dict as needed
    print(category_time_dict)

    print("kiki")
    total_time_spent_by_client = timeSheet.objects.filter(
        client_id=client_id,
        time_entries_start_date__gte=start_date,  # Filter based on start date
        time_entries_stop_date__lte=end_date,  # Filter based on end date
        status=None
    ).values('client_id', 'employee_id').annotate(total_time=Sum('time_entries_seconds'))
    print(total_time_spent_by_client)
    # Create a dictionary to store category_id and total time spent
    category_time_dict_client = {}

    # Loop through the results to populate the dictionary
    for entry in total_time_spent_by_client:
        employee_id = entry['employee_id']
        client_id = entry['client_id']
        total_time_spent_seconds = entry['total_time']

        # Convert total_time_spent_seconds to a more readable format
        total_time_spent_hours, remainder = divmod(total_time_spent_seconds, 3600)
        total_time_spent_minutes, total_time_spent_seconds = divmod(remainder, 60)

        # Store the values in the dictionary
        category_time_dict_client[employee_id] = {
            'formatted_time': f"{total_time_spent_hours:02d}:{total_time_spent_minutes:02d}:{total_time_spent_seconds:02d}",
            'total_time_seconds': entry['total_time'],
            'client_id': entry['client_id'],
            'hours': total_time_spent_hours,
            'minutes': total_time_spent_minutes,
            'seconds': total_time_spent_seconds
        }
    print(category_time_dict_client)

    # if Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month]).exists():
    #     all = Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month])

    if Client_contract_work.objects.filter(client_id=client_id).filter(query).exists():
        all = Client_contract_work.objects.filter(client_id=client_id).filter(query)
        for record in all:
            # Access the current record in the queryset
            first_record = record

            # Access the 'working_input' attribute
            work_json_str = first_record.working_input

            # Parse the JSON string
            work_dict = json.loads(work_json_str)
            for employee_id in work_dict.keys():
                if int(employee_id) not in category_time_dict_client:
                    category_time_dict_client[int(employee_id)] = {
                        'formatted_time': '00:00:00',
                        'total_time_seconds': 0,
                        'client_id': '',  # You may set this to appropriate default value
                        'hours': 0,
                        'minutes': 0,
                        'seconds': 0
                    }

    category_cost_dict = {}

    # Iterate over the categories in employee_info_dict
    for category_id, employees in employee_info_dict.items():
        total_salary = 0

        # Calculate total salary for employees in the category
        for employee_info in employees:
            if employee_info['salary']:
                total_salary += float(employee_info['salary'])  # Convert Decimal to float

        # Calculate cost per hour
        cost_per_hour = total_salary / (working_days * 8)

        # Fetch total time spent for the category from category_time_dict
        total_time_seconds = category_time_dict.get(category_id, {}).get('total_time_seconds', 0)

        # Convert Decimal to float for total_cost calculation and round to 2 decimal places
        # total_cost = round(float((total_time_seconds / 3600) * cost_per_hour), 2)
        yoo = float(total_time_seconds / 3600)

        total_cost = round(cost_per_hour * yoo, 2)

        # Store the values in the category_cost_dict
        category_cost_dict[category_id] = {
            'total_cost': total_cost,
            # 'cost_per_hour': cost_per_hour,
            # 'total_time_seconds': total_time_seconds
        }

    timesheets = timeSheet.objects.filter(client_id=client_id, time_entries_start_date__range=(start_date, end_date),
                                          status=None)

    # Dictionary to store employee IDs and their total time worked
    employee_data = {}
    ui = {}
    from decimal import Decimal
    # Calculate total time worked by each employee for the client
    for timesheet1 in timesheets:
        employee_id = timesheet1.employee_id
        time_worked_seconds = timesheet1.time_entries_seconds

        # Update total time worked for the employee
        if employee_id in employee_data:
            employee_data[employee_id]['time_worked'] += time_worked_seconds
        else:
            employee_data[employee_id] = {'time_worked': time_worked_seconds, 'salary': 0}

    # if Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month]).exists():
    #     all = Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month])
    if Client_contract_work.objects.filter(client_id=client_id).filter(query).exists():
        all = Client_contract_work.objects.filter(client_id=client_id).filter(query)
        for record in all:
            first_record = record
            work_json_str = first_record.working_input

            # Parse the JSON string
            work_dict = json.loads(work_json_str)
            for employee_id in work_dict.keys():
                if int(employee_id) not in employee_data:
                    employee_data[int(employee_id)] = {'time_worked': 0, 'salary': 0}

    for employee_id in employee_data.keys():
        employee1 = employee.objects.get(id=employee_id)

        if employee1.salary:
            emp_salary = get_salary_for_date(employee1, start_date)
            employee_data[employee_id]['salary'] = emp_salary
            adjusted_salary = float(emp_salary) / (working_days * 8)
            salary = emp_salary
        else:
            employee_data[employee_id]['salary'] = 0
            adjusted_salary = 0
            salary = 0

        time_worked_hours = employee_data[employee_id]['time_worked'] / 3600

        if employee1.first_name and employee1.last_name:
            name = employee1.first_name + ' ' + employee1.last_name
        else:
            name = employee1.user_name

        ui[str(employee_id)] = {
            'ui_employee_name': name,
            'ui_employee_salary': salary,
            'ui_working_hours': time_worked_hours
        }
        # Multiply adjusted salary and time worked
        total_payment = adjusted_salary * time_worked_hours
        total_payment = round(total_payment, 2)
        # Update employee_data with total_payment
        employee_data[employee_id]['total_payment'] = total_payment

    sum_of_rates_employee = 0.0  # Initialize the variable to store the sum of all costs

    sum_of_rates_employee = sum(employee['total_payment'] for employee in employee_data.values())

    # Format the sum_of_rates_employee as a string with two decimal places when printing
    sum_of_rates_employee = "{:.2f}".format(sum_of_rates_employee)

    # client revenue
    client_detail = client.objects.get(pk=client_id)
    client_id = client_detail.id

    one_project_rate = 0

    employee_salary_dict = {}
    ui_data = []

    if Client_contract_work.objects.filter(client_id=client_id).filter(query).exists():
        contracted_client1 = Client_contract_work.objects.filter(client_id=client_id).filter(query)
        # if Client_contract_work.objects.filter(client_id=client_id,date__month__range=[start_month, end_month],date__year=current_year).exists():
        #     contracted_client1 = Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month])

        for contracted_client in contracted_client1:

            date1 = contracted_client
            # print(date)

            date = date1.date

            target_month = date.month
            import ast
            from decimal import Decimal
            import calendar
            from datetime import datetime

            if target_month < start_date.month:  # If target_month is earlier in the year
                target_year = start_date.year + 1  # Next year
            else:
                target_year = start_date.year  # Same year

            # Calculate target_month_start
            target_month_start = start_date.replace(year=target_year, month=target_month, day=1)

            # Determine the start_date_in_target_month
            start_date_in_target_month = max(start_date, target_month_start)

            # Ensure target_month is in the correct year
            if start_date_in_target_month.month == target_month:
                if target_month == 12:
                    next_month_date = start_date_in_target_month.replace(year=start_date_in_target_month.year + 1,
                                                                         month=1, day=1)
                else:
                    next_month_date = start_date_in_target_month.replace(month=target_month + 1, day=1)

                target_month_end = min(next_month_date - timedelta(days=1), end_date)
            else:
                if target_month < start_date_in_target_month.month:
                    target_year = start_date_in_target_month.year + 1
                else:
                    target_year = start_date_in_target_month.year

                target_month_start = datetime(target_year, target_month, 1)
                target_month_end = min(target_month_start - datetime.resolution, end_date)

            if target_month_end.month == start_date_in_target_month.month:
                total_days_between = (target_month_end - start_date_in_target_month).days + 1
            else:
                total_days_between = (target_month_end - start_date_in_target_month).days

            date_difference = total_days_between

            # Get the number of days in that month
            days_in_month = calendar.monthrange(date.year, date.month)[1]

            if date_difference == days_in_month:
                # weeks=4.3
                weeks = round(days_in_month / 7, 2)
                weeks = round(weeks, 2)
            else:
                weeks = date_difference / 7

            contracted_working_hours_1_str = contracted_client.working_input
            contracted_working_hours_1 = ast.literal_eval(contracted_working_hours_1_str)

            for employee_id, working_hours in contracted_working_hours_1.items():
                # Fetch the employee from the Employee table
                employee3 = employee.objects.get(id=employee_id)
                # Calculate salary per hour
                emp3_salary = get_salary_for_date(employee3, start_date)
                ui_employee_salary = float(emp3_salary)
                salary_per_hour = float(emp3_salary) / (working_days * 8)
                salary_per_hour = round(salary_per_hour, 2)
                # Convert working hours to float
                working_hours = float(working_hours)
                ui_working_hours = working_hours
                # Calculate total salary for the given working hours

                if employee3.first_name and employee3.last_name:
                    name = employee3.first_name + ' ' + employee3.last_name
                else:
                    name = employee3.user_name

                weeks = round(weeks, 2)
                ui_employee_data = {
                    'ui_employee_name': name,
                    'ui_employee_salary': emp3_salary,
                    'ui_working_hours': working_hours,
                    'ui_weeks': weeks
                }

                # Append this dictionary to the list
                ui_data.append(ui_employee_data)

                mul = round(working_hours * weeks, 2)

                total_salary = round(salary_per_hour * mul, 2)

                total_salary = round(total_salary, 2)
                # Store the total salary in the dictionary
                employee_id = int(employee_id)
                if int(employee_id) in employee_salary_dict:
                    # If it exists, add the new salary to the existing one
                    employee_salary_dict[int(employee_id)] += total_salary
                    employee_salary_dict[int(employee_id)] = round(employee_salary_dict[int(employee_id)], 2)

                else:
                    print("else")
                    # If it doesn't exist, create a new entry
                    employee_salary_dict[int(employee_id)] = total_salary
                    employee_salary_dict[int(employee_id)] = round(employee_salary_dict[int(employee_id)], 2)

    contracted_sum_of_rates_employee = 0.0
    # Convert all values in employee_salary_dict to float
    employee_salary_dict = {k: float(v) for k, v in employee_salary_dict.items()}

    # Sum the values in employee_salary_dict
    contracted_sum_of_rates_employee = sum(employee_salary_dict.values())
    contracted_sum_of_rates_employee = "{:.2f}".format(contracted_sum_of_rates_employee)

    total_time_spent_formatted = {}
    project_names = {}
    project_user_dict = {}
    employee_rate_per_hour = {}

    employee_list = employee.objects.filter(status=1)
    employee_id_list = list(employee_details2.keys())
    monthly_amount = Client_contract_work.objects.filter(client_id=client_id).values('cost').order_by('-id').first()
    print('buddy_ids ', buddy_ids)
    print('advisor_ids ', advisor_ids)
    print('monthly_amount ', monthly_amount)

    files = FileManager.objects.filter(client_id=client_id).order_by('-id').all()

    try:
        for file in files:
            file.file_name = file.file.name.split('/')[-1]
            if (file.uploaded_by != '' and file.uploaded_by != None):
                file.uploaded_by = employee.objects.filter(user_id=file.uploaded_by).values('id', 'first_name',
                                                                                            'last_name',
                                                                                            'image_url').first()
            else:
                file.uploaded_by = ''
    except Exception as e:
        files = []

    file_category_all = File_Category.objects.distinct('name')
    file_category = File_Category.objects.filter(client_id=client_id)
    # client_file_category = File_Category.objects.filter(client_id=client_id).all()
    client_file_category = File_Category.objects.filter(client_id=client_id)

    file_counts = FileManager.objects.filter(client_id=client_id).values('category_id').annotate(count=Count('id'))

    # Create a lookup dictionary: {category_id: count}
    file_count_dict = {item['category_id']: item['count'] for item in file_counts}
    for category in client_file_category:
        category.file_count = file_count_dict.get(category.id, 0)

    # Get all files for "All Files" tab
    all_files = FileManager.objects.filter(client_id=client_id).order_by('-created_at')

    files_by_category = {}

    for category in client_file_category:
        category_files = FileManager.objects.filter(client_id=client_id, category_id=category.id).order_by(
            '-created_at')
        category_key = category.name.replace(' ', '_').lower()
        files_by_category[category_key] = category_files
    print(files_by_category, 'files_by_category')
    # END DYNAMIC FILE SHOW
    # all_employee = employee.objects.filter(status = 1)
    auth_user_employee = User.objects.all()
    employee_dict = {}
    for emp in auth_user_employee:
        try:
            emp_ob = employee.objects.get(user_id=emp.id)
            employee_dict[emp_ob.user_id] = emp_ob.first_name + ' ' + emp_ob.last_name
        except Exception as e:
            pass
    
    employee_id = request.session.get('user_id')
    login_emp_ob = employee.objects.get(id=employee_id)

    airtable_details = Airtable.objects.filter(client_id=client_id).first()
    from urllib.parse import urlparse
    linkedin_user_url =''
    if airtable_details and airtable_details.linkedin_url:
        linkedin_url = airtable_details.linkedin_url
        path = urlparse(linkedin_url).path
        linkedin_user_url = path.strip('/').split('/')[-1]

    context = {
        'files': files,
        'employee_list': employee_list,
        'show_button': show_button,
        'linkedin_user_url': linkedin_user_url,
        'file_category': file_category,
        'client_file_category': client_file_category,
        'employee_id_list': employee_id_list,
        'monthly_amount': monthly_amount,
        'buddy_ids': buddy_ids,
        'advisor_ids': advisor_ids,
        'consultant_ids': consultant_ids,
        'consultant_details': consultant_details,
        'client': client_detail,
        'projects': project_names,
        'team_member_images': project_user_dict,
        # 'project_rate':project_rate,
        'sum_of_rates': one_project_rate,
        'employee_rate_per_hour': employee_rate_per_hour,
        'sum_of_rates_employee': sum_of_rates_employee,
        'contracted_sum_of_rates_employee': contracted_sum_of_rates_employee,
        'employee_details': employee_details,
        'employee_details2': employee_details2,
        'selected_month': selected_month,
        'current_year': current_year,
        # 'allowed_months': [9, 10, 11, 12],
        'client_category_list': client_category_list,
        'employee_info_dict': employee_info_dict,
        'category_time_dict': category_time_dict,
        'total_time_spent_formatted': total_time_spent_formatted,
        'category_cost_dict': category_cost_dict,
        "client_details": client_details,
        "category_time_dict_client": category_time_dict_client,
        "employee_data": employee_data,
        "employee_salary_dict": employee_salary_dict,
        'start_date': start_date_str,
        'end_date': end_date_str,
        'weeks': weeks,
        'total_cost_client': ui_final_cost,
        'ui_total_hours': ui_total_hours,
        'ui_formatted_time2': ui_formatted_time2,
        'ui_data': ui_data,
        'ui': ui,
        'ui_client_data': ui_client_data,
        'project_data_with_employees': project_data_with_employees,
        'all_files': all_files,
        'files_by_category': files_by_category,
        'employee_dict': employee_dict,
        'login_emp_ob': login_emp_ob,
        'file_category_all': file_category_all,
    }
    return render(request, 'client_profile.html', context)




@csrf_exempt
@login_required(login_url='/')
def projects_id(request):
    if request.method == 'GET':

        print("ss")

        import requests
        from base64 import b64encode

        # Replace placeholders with your actual data
        workspace_id = 4007366  # Replace with your workspace ID
        email = 'jharna.agrawal@brickwin.com'
        password = 'Newsystem@1234'

        # Define the API URL with the workspace_id placeholder replaced
        url = f'https://api.track.toggl.com/api/v9/workspaces/{workspace_id}/projects'

        # Encode the email and password for Basic Authentication
        auth_header = 'Basic ' + b64encode(f"{email}:{password}".encode("ascii")).decode("ascii")

        # Define query parameters, if needed
        params = {
            'active': True,  # Set to True to retrieve active projects
            'per_page': 2000,  # Adjust the number of items per page as needed
            # Add more query parameters as required
        }

        # Make the GET request with headers and query parameters
        response = requests.get(url, headers={'Content-Type': 'application/json', 'Authorization': auth_header},
                                params=params)

        if response.status_code == 200:
            # If the request was successful, print the JSON response
            print("hbjnjnm,")
            response_data=response.json()
            print(response.json())

            for entry in response_data:
                id = entry.get('id')
                client_id = entry.get('client_id')
                name = entry.get('name')

                print(f"project ID: {id}")
                print(f"client id: {client_id}")
                print(f"Projectname: {name}")

                # Check if the employee with the same UID exists in the database
                existing_project = project.objects.filter(toggl_project_id=id).first()

                if not existing_project:
                        # If the employee with the same UID doesn't exist, create a new employee in the database
                        new_project = project(toggl_project_id=id, toggl_client_id=client_id, toggl_project_name=name)
                        new_project.save()
        else:
            # If there was an error, print the status code and response content
            print(f"Error: {response.status_code}")
            print(response.content)

    return render(request,"projects_id.html",{})

@csrf_exempt
@login_required(login_url='/')
def projects(request):
    active = [''] * 15
    active[6] = 'active'
    if request.method == 'POST':
        request_for = request.POST.get('request_for')
        if request_for == 'add_project':
            project_name = request.POST.get('project_name')
            company = request.POST.get('company')
            client_id = request.POST.get('client_id')
            start_date = request.POST.get('start_date')
            end_date = request.POST.get('end_date')
            rate = request.POST.get('rate')
            working_hours = request.POST.get('working_hours')
            working_hours_type = request.POST.get('working_hours_type')
            duration = request.POST.get('duration')
            duration_type = request.POST.get('duration_type')
            rate_type = request.POST.get('rate_type')
            status = request.POST.get('status')
            description = request.POST.get('description')
            uploaded_file = request.FILES.get('uploaded_file')

            print("Vinod Jan20")
            print(request.POST.getlist('leader'))

            if not project_name:
                return JsonResponse({"error": "Project name cannot be blank."}, status=400)
            
            if project.objects.filter(project_name=project_name).exists():
                return JsonResponse({"error": "This project name already exists."}, status=400)
            
            # try:
            #     rate = float(rate)
            #     if rate <= 0:
            #         return JsonResponse({"error": "Project value must be a positive value."}, status=400)
            # except ValueError:
            #     return JsonResponse({"error": "Invalid project value."}, status=400)
            
            if start_date and end_date:
                try:
                    start_date_obj = datetime.strptime(start_date, '%Y-%m-%d')
                    end_date_obj = datetime.strptime(end_date, '%Y-%m-%d')
                    if end_date_obj < start_date_obj:
                        return JsonResponse({"error": "End Date must be greater than Start Date."}, status=400)
                except ValueError:
                    return JsonResponse({"error": "Invalid date format."}, status=400)

            leader_ids = request.POST.getlist('leader')
            support_ids = request.POST.getlist('support')
            advisor_ids = request.POST.getlist('advisor')
            
            if not leader_ids or len(leader_ids) == 0:
                return JsonResponse({"error": "Please select at least one leader."}, status=400)
            
            working_role = {}
            
            for id in support_ids:
                working_role[int(id)] = "S"
            for id in advisor_ids:
                working_role[int(id)] = "A"
            for id in leader_ids:
                working_role[int(id)] = "L"
            
            filename = ""
            destination_path = None

            if start_date and end_date:
                start_date = start_date
                end_date = end_date
            else:
                start_date = None
                end_date = None

            if uploaded_file:
                base_filename = os.path.basename(uploaded_file.name)

                base_filename = base_filename.replace('/', '_')

                filename = f'{project_name}_{base_filename}'
                filename = filename.replace('/', '_')

                destination_path = os.path.join(settings.STATICFILES_DIRS[0], 'img', 'user', filename)

                try:
                    with open(destination_path, 'wb+') as destination:
                        for chunk in uploaded_file.chunks():
                            destination.write(chunk)
                except Exception as e:
                    print(e)

            if uploaded_file:
                uploaded_file = os.path.join(settings.STATIC_URL, 'assets', 'img', 'user', filename)
            else:
                uploaded_file =''

            if request.POST.get('add_new_client') == 'true':  # Check if user selected to add new client
                client_name = request.POST.get('client_name')
                client_company = request.POST.get('client_company')

                if not client_name or not client_company:
                    return JsonResponse({"error": "Client name and Company are required when adding a new client."}, status=400)
                
                toggl_client_name = f"{client_company}, {client_name}"
                clientData, created = client.objects.get_or_create(client_name=client_name, company_name=client_company, toggl_client_name=toggl_client_name, status=1)
                client_id = clientData.id
                if created:
                    clientData.toggl_client_id = client_id
                    clientData.save()

            elif not client_id:
                return JsonResponse({"error": "Client must be selected."}, status=400)
            else:
                if not client.objects.filter(id=client_id).exists():
                    return JsonResponse({"error": "Selected client does not exist."}, status=400)

            project1 = project(
                project_name=project_name,
                working_hours = working_hours,
                working_hours_type = working_hours_type,
                duration = duration,
                duration_type = duration_type,
                company=company,
                client_id=client_id,
                working_role=working_role,
                start_date=start_date,
                end_date=end_date,
                rate=rate,
                rate_type=rate_type,
                status=status,
                description=description,
                uploaded_file=uploaded_file
            )
            project1.save()
        elif request_for == 'filter_project':
            project_name = request.POST.get('search_project')
            employee_id = request.POST.getlist('employee_id')
            status = request.POST.get('status')

    employee_list = employee.objects.filter(status=1).all()
    client_list = client.objects.all()
    import ast
    if request.method == 'POST' :
        request_for = request.POST.get('request_for')
        project_name = request.POST.get('search_project')
        employee_ids = request.POST.getlist('employee_id')
        status = request.POST.get('search_status')

    else:
        request_for = ''
    
    if request_for != 'filter_project' :
        project_name = ''
        employee_ids = []
        status = ''
    

    print("Vinod project_name")
    print(project_name)
    print('employee_ids')
    print(employee_ids)
    print('status')
    print(status)
    project_start_date = date(2025, 1, 1)
    # project_queryset = project.objects.filter(created_at__gte=project_start_date).order_by('id')



    project_queryset = project.objects.filter(created_at__gte=project_start_date).order_by('id')

    if project_name:
        project_queryset = project_queryset.filter(project_name__icontains=project_name)

    if employee_ids:
        matching_projects = []
        for project_data in project_queryset:
            try:
                working_roles = ast.literal_eval(project_data.working_role)
                if any(int(emp_id) in working_roles for emp_id in employee_ids):
                    matching_projects.append(project_data)
            except (ValueError, SyntaxError):
                continue
        project_queryset = matching_projects

    if status:
        if isinstance(project_queryset, list):
            project_queryset = [
                project for project in project_queryset 
                if project.status and project.status.lower() == status.lower()
            ]
        else:
            project_queryset = project_queryset.filter(status__iexact=status)

    project_list = project_queryset[:100] if isinstance(project_queryset, list) else project_queryset.order_by('id')[:100]

    print("Vinod project_list")
    print(project_list)

    project_data_with_employees = []
    for project_data in project_list:
        employee_details_by_role = {
            'L': [],
            'S': [],
            'A': []
        }

        working_roles = ast.literal_eval(project_data.working_role)

        for employee_id, role in working_roles.items():
            if role not in employee_details_by_role:
                continue

            if employee_id not in [emp['id'] for emp in employee_details_by_role[role]]:
                try:
                    employee_data = employee.objects.get(id=employee_id)
                    employee_details_by_role[role].append({
                        'name': f"{employee_data.first_name} {employee_data.last_name}",
                        'id': employee_data.id,
                        'image_url': employee_data.image_url,
                        'role': role
                    })
                except employee.DoesNotExist:
                    continue

        project_data_with_employees.append({
            'project': project_data,
            'employee_details_by_role': employee_details_by_role
        })

    context = {
        "active": active,
        "employee_list": employee_list,
        "client_list": client_list,
        "project_data_with_employees": project_data_with_employees,
        "project_name":project_name,
        "employee_ids":employee_ids,
        "status":status
    }

    return render(request, 'projects.html', context)

@csrf_exempt
@login_required(login_url='/')
def edit_project(request, project_id):
    
    project1 = get_object_or_404(project, id=project_id)

    if request.method == 'POST':
        project_name = request.POST.get('project_name')
        company = request.POST.get('company')
        client_id = request.POST.get('client_id')
        start_date = request.POST.get('start_date')
        end_date = request.POST.get('end_date')
        rate = request.POST.get('rate')
        rate_type = request.POST.get('rate_type')
        working_hours = request.POST.get('working_hours')
        working_hours_type = request.POST.get('working_hours_type')
        duration = request.POST.get('duration')
        duration_type = request.POST.get('duration_type')
        status = request.POST.get('status')
        description = request.POST.get('description')
        uploaded_file = request.FILES.get('uploaded_file')

        if not project_name:
            return JsonResponse({"error": "Project name cannot be blank."}, status=400)

        try:
            rate = float(rate)
            if rate <= 0:
                return JsonResponse({"error": "Project value must be a positive value."}, status=400)
        except ValueError:
            return JsonResponse({"error": "Invalid project value."}, status=400)
        
        if start_date:
            start_date_obj = datetime.strptime(start_date, '%Y-%m-%d')
        if end_date:
            end_date_obj = datetime.strptime(end_date, '%Y-%m-%d')
        if start_date and end_date:
            try:
                if end_date_obj < start_date_obj:
                    return JsonResponse({"error": "End Date must be greater than Start Date."}, status=400)
            except ValueError:
                return JsonResponse({"error": "Invalid date format."}, status=400)

        leader_ids = request.POST.getlist('leader')
        if not leader_ids:
            return JsonResponse({"error": "Please select at least one leader."}, status=400)

        # Collect working roles
        working_role = {
            **{int(id): "S" for id in request.POST.getlist('support')},
            **{int(id): "A" for id in request.POST.getlist('advisor')},
            **{int(id): "L" for id in leader_ids}
        }

        if uploaded_file:
            base_filename = os.path.basename(uploaded_file.name).replace('/', '_')
            filename = f'{project_name}_{base_filename}'
            destination_path = os.path.join(settings.STATICFILES_DIRS[0], 'img', 'profiles', filename)

            try:
                with open(destination_path, 'wb+') as destination:
                    for chunk in uploaded_file.chunks():
                        destination.write(chunk)
            except Exception as e:
                return JsonResponse({"error": f"Error saving file: {str(e)}"}, status=500)

            uploaded_file_url = os.path.join(settings.STATIC_URL, 'assets', 'img', 'profiles', filename)
        else:
            uploaded_file_url = project1.uploaded_file  # Keep existing file if no new upload

        project1.project_name = project_name
        project1.company = company
        project1.client_id = client_id
        project1.start_date = start_date_obj if start_date else project1.start_date
        project1.end_date = end_date_obj if end_date else project1.end_date
        project1.rate = rate
        project1.rate_type = rate_type
        project1.working_hours = working_hours
        project1.working_hours_type = working_hours_type
        project1.duration = duration
        project1.duration_type = duration_type
        project1.status = status
        project1.description = description
        project1.uploaded_file = uploaded_file_url
        project1.working_role = working_role

        project1.save()

        return redirect('projects')

@csrf_exempt
@login_required(login_url='/')
def view_project(request, project_id):
    if request.method == 'POST':
        form_type = request.POST.get('form_type')
        action = request.POST.get('action')
        print(form_type)
        print(action)
        # Handle image upload
        if form_type == 'form3':
            start_date = request.POST.get('start_date')
            end_date = request.POST.get('end_date')
            print(start_date)
            print(end_date)
            if action == 'Call API':

                try:

                    toggl_project_record = toggl_project.objects.get(project_id=project_id)
                    toggl_project_id = toggl_project_record.toggl_project_id
                    print(toggl_project_id)

                    workspace_id = '4007366'
                    email = 'jharna.agrawal@brickwin.com'
                    password = 'Newsystem@1234'
                    page_size = 600
                    toggl_project_id = [toggl_project_id]

                    # Define the request JSON data with your specific parameters
                    request_data = {
                        "start_date": start_date,
                        "end_date": end_date,
                        "page_size": page_size,
                        "project_ids": toggl_project_id
                    }

                    # Define the API URL with the workspace_id placeholder replaced
                    url = f'https://api.track.toggl.com/reports/api/v3/workspace/{workspace_id}/search/time_entries'

                    # Encode the email and password for Basic Authentication
                    auth_header = 'Basic ' + b64encode(f"{email}:{password}".encode("ascii")).decode("ascii")

                    # Make the POST request with headers and JSON data
                    response = requests.post(url, json=request_data,
                                             headers={'Content-Type': 'application/json', 'Authorization': auth_header})

                    # Parse the JSON response and store it in response_data
                    response_data = response.json()
                    # Loop through each entry in the response_data
                    for entry in response_data:
                        user_id = entry['user_id']
                        username = entry['username']
                        project_id = entry['project_id']
                        task_id = entry['task_id']
                        billable = entry['billable']
                        description = entry['description']
                        tag_ids = entry['tag_ids']
                        billable_amount_in_cents = entry['billable_amount_in_cents']
                        hourly_rate_in_cents = entry['hourly_rate_in_cents']
                        currency = entry['currency']
                        time_entries = entry['time_entries']  # This is a list of time entries

                        print(f"User ID: {user_id}")
                        print(f"Username: {username}")
                        print(f"Project ID: {project_id}")
                        print(f"Task ID: {task_id}")
                        print(f"Billable: {billable}")
                        print(f"Description: {description}")
                        print(f"Tag IDs: {tag_ids}")
                        print(f"Billable Amount (in cents): {billable_amount_in_cents}")
                        print(f"Hourly Rate (in cents): {hourly_rate_in_cents}")
                        print(f"Currency: {currency}")
                        toggl_user1 = toggl_user.objects.get(toggl_user_id=user_id)
                        employee_id = toggl_user1.employee_id
                        print(f"employee_id: {employee_id}")

                        project_data = None  # Initialize project data variable
                        try:
                            # Construct the URL for project data
                            project_url = f'https://api.track.toggl.com/api/v9/workspaces/{workspace_id}/projects/{project_id}'

                            # Create the basic authentication string
                            project_auth_string = f"{email}:{password}"
                            encoded_project_auth_string = b64encode(project_auth_string.encode()).decode("ascii")

                            # Set the headers including the basic authentication
                            project_headers = {
                                'Content-Type': 'application/json',
                                'Authorization': f'Basic {encoded_project_auth_string}'
                            }

                            # Make the GET request to fetch project data
                            project_response = requests.get(project_url, headers=project_headers)

                            if project_response.status_code == 200:
                                project_data = project_response.json()
                                print(f"Project Data: {project_data}")
                                # Assuming you have already fetched and stored project_data as a dictionary
                                toggl_project_id = project_data['id']
                                workspace_id = project_data['workspace_id']
                                client_id = project_data['client_id']
                                name = project_data['name']
                                is_private = project_data['is_private']
                                active = project_data['active']

                                print(f"Project ID: {toggl_project_id}")
                                print(f"Workspace ID: {workspace_id}")
                                print(f"Client ID: {client_id}")
                                print(f"Project Name: {name}")
                                print(f"Is Private: {is_private}")
                                print(f"Active: {active}")
                                #
                                at = project_data['at']
                                created_at = project_data['created_at']
                                # Parse the start time and stop time into datetime objects
                                at_time = datetime.fromisoformat(at)
                                created_at_time = datetime.fromisoformat(created_at)
                                at_date = at_time.strftime('%Y-%m-%d')
                                at_time_of_day = at_time.strftime('%H:%M:%S')
                                created_at_date = created_at_time.strftime('%Y-%m-%d')
                                created_at_time_of_day = created_at_time.strftime('%H:%M:%S')
                                # Get the time zone offset as a string (e.g., '-04:00')
                                at_time_zone_offset = at_time.strftime('%z')
                                at_time_zone_offset = f"{at_time_zone_offset[:-2]}:{at_time_zone_offset[-2:]}"
                                created_at_time_zone_offset = created_at_time.strftime('%z')
                                created_at_time_zone_offset = f"{created_at_time_zone_offset[:-2]}:{created_at_time_zone_offset[-2:]}"
                                print(f"Startat Date: {at_date}")
                                print(f"Startat Time: {at_time_of_day}")
                                print(f"Startat Time Zone Offset: {at_time_zone_offset}")
                                print(f"Stopcreated at Date: {created_at_date}")
                                print(f"Stopcreated at Time: {created_at_time_of_day}")
                                print(f"Stopcreated at Time Zone Offset: {created_at_time_zone_offset}")
                                #
                                server_deleted_at = project_data['server_deleted_at']
                                color = project_data['color']
                                billable = project_data['billable']
                                template = project_data['template']
                                auto_estimates = project_data['auto_estimates']
                                estimated_hours = project_data['estimated_hours']
                                rate = project_data['rate']
                                rate_last_updated = project_data['rate_last_updated']
                                currency_1 = project_data['currency']
                                recurring = project_data['recurring']
                                recurring_parameters = project_data['recurring_parameters']
                                current_period = project_data['current_period']
                                fixed_fee = project_data['fixed_fee']
                                actual_hours = project_data['actual_hours']
                                wid = project_data['wid']
                                cid = project_data['cid']
                                #
                                print(f"Server Deleted At: {server_deleted_at}")
                                print(f"Color: {color}")
                                print(f"Billable: {billable}")
                                print(f"Template: {template}")
                                print(f"Auto Estimates: {auto_estimates}")
                                print(f"Estimated Hours: {estimated_hours}")
                                print(f"Rate: {rate}")
                                print(f"Rate Last Updated: {rate_last_updated}")
                                print(f"Currency: {currency_1}")
                                print(f"Recurring: {recurring}")
                                print(f"Recurring Parameters: {recurring_parameters}")
                                print(f"Current Period: {current_period}")
                                print(f"Fixed Fee: {fixed_fee}")
                                print(f"Actual Hours: {actual_hours}")
                                print(f"WID: {wid}")
                                print(f"CID: {cid}")

                                # Try to fetch the corresponding project_id from the toggl_project table
                                toggl_project_record = toggl_project.objects.filter(
                                    toggl_project_id=toggl_project_id).first()

                                if toggl_project_record:
                                    project_id_1 = toggl_project_record.project_id
                                    # Now you have the project_id associated with the toggl_project_id
                                else:
                                    # Handle the case where the toggl_project_id is not found
                                    project_id = None  # or raise an exception, return a default value, etc.

                                existing_project = toggl_project_detail.objects.filter(project_id=project_id_1).first()
                                if not existing_project:
                                    # If the project doesn't exist, create a new Project instance
                                    new_project = toggl_project_detail(
                                        project_id=project_id_1,
                                        toggl_project_id=toggl_project_id,
                                        workspace_id=workspace_id,
                                        client_id=client_id,
                                        name=name,
                                        is_private=is_private,
                                        active=active,
                                        at_date=at_date,
                                        at_time_of_day=at_time_of_day,
                                        at_time_zone_offset=at_time_zone_offset,
                                        created_at_date=created_at_date,
                                        created_at_time_of_day=created_at_time_of_day,
                                        created_at_time_zone_offset=created_at_time_zone_offset,
                                        server_deleted_at=server_deleted_at,
                                        color=color,
                                        billable=billable,
                                        template=template,
                                        auto_estimates=auto_estimates,
                                        estimated_hours=estimated_hours,
                                        rate=rate,
                                        rate_last_updated=rate_last_updated,
                                        currency=currency_1,
                                        recurring=recurring,
                                        recurring_parameters=recurring_parameters,
                                        current_period=current_period,
                                        fixed_fee=fixed_fee,
                                        actual_hours=actual_hours,
                                        wid=wid,
                                        cid=cid
                                    )
                                    new_project.save()
                            else:
                                print(f"Failed to retrieve project data. Status code: {project_response.status_code}")

                        except Exception as e:
                            print(f"An error occurred while fetching project data: {str(e)}")

                        # Loop through time entries for this entry

                        for time_entry in time_entries:
                            entry_id = time_entry['id']
                            seconds = time_entry['seconds']
                            start = time_entry['start']
                            stop = time_entry['stop']
                            at = time_entry['at']
                            # Parse the start time and stop time into datetime objects
                            start_time = datetime.fromisoformat(start)
                            stop_time = datetime.fromisoformat(stop)
                            at_time = datetime.fromisoformat(at)

                            # Extract the date and time components
                            start_date = start_time.strftime('%Y-%m-%d')
                            start_time_of_day = start_time.strftime('%H:%M:%S')
                            stop_date = stop_time.strftime('%Y-%m-%d')
                            stop_time_of_day = stop_time.strftime('%H:%M:%S')
                            at_date = at_time.strftime('%Y-%m-%d')
                            at_time_of_day = at_time.strftime('%H:%M:%S')
                            # Get the time zone offset as a string (e.g., '-04:00')
                            start_time_zone_offset = start_time.strftime('%z')
                            start_time_zone_offset = f"{start_time_zone_offset[:-2]}:{start_time_zone_offset[-2:]}"
                            stop_time_zone_offset = stop_time.strftime('%z')
                            stop_time_zone_offset = f"{stop_time_zone_offset[:-2]}:{stop_time_zone_offset[-2:]}"
                            at_time_zone_offset = at_time.strftime('%z')
                            at_time_zone_offset = f"{at_time_zone_offset[:-2]}:{at_time_zone_offset[-2:]}"

                            print(f"Time Entry ID: {entry_id}")
                            print(f"Seconds: {seconds}")
                            print(f"Start Date: {start_date}")
                            print(f"Start Time: {start_time_of_day}")
                            print(f"Start Time Zone Offset: {start_time_zone_offset}")
                            print(f"Stop Date: {stop_date}")
                            print(f"Stop Time: {stop_time_of_day}")
                            print(f"Stop Time Zone Offset: {stop_time_zone_offset}")
                            print(f"Stop Date: {at_date}")
                            print(f"Stop Time: {at_time_of_day}")
                            print(f"Stop Time Zone Offset: {at_time_zone_offset}")

                            existing_record = toggl_user_detail.objects.filter(
                                employee_id=employee_id,
                                user_id=user_id,
                                username=username,
                                project_id=project_id,
                                task_id=task_id,
                                billable=billable,
                                description=description,
                                tag_ids=tag_ids,
                                billable_amount_in_cents=billable_amount_in_cents,
                                hourly_rate_in_cents=hourly_rate_in_cents,
                                currency=currency,
                                time_entries_id=entry_id,
                                time_entries_seconds=seconds,
                                time_entries_start_date=start_date,
                                time_entries_start_time=start_time_of_day,
                                time_entries_start_time_utc=start_time_zone_offset,
                                time_entries_stop_date=stop_date,
                                time_entries_stop_time=stop_time_of_day,
                                time_entries_stop_time_utc=stop_time_zone_offset,
                                time_entries_at_date=at_date,
                                time_entries_at_time=at_time_of_day,
                                time_entries_at_time_utc=at_time_zone_offset,
                            ).first()
                            if not existing_record:
                                toggl_user1 = toggl_user_detail.objects.create(
                                    employee_id=employee_id,
                                    user_id=user_id,
                                    username=username,
                                    project_id=project_id,
                                    task_id=task_id,
                                    billable=billable,
                                    description=description,
                                    tag_ids=tag_ids,
                                    billable_amount_in_cents=billable_amount_in_cents,
                                    hourly_rate_in_cents=hourly_rate_in_cents,
                                    currency=currency,
                                    time_entries_id=entry_id,
                                    time_entries_seconds=seconds,
                                    time_entries_start_date=start_date,
                                    time_entries_start_time=start_time_of_day,
                                    time_entries_start_time_utc=start_time_zone_offset,
                                    time_entries_stop_date=stop_date,
                                    time_entries_stop_time=stop_time_of_day,
                                    time_entries_stop_time_utc=stop_time_zone_offset,
                                    time_entries_at_date=at_date,
                                    time_entries_at_time=at_time_of_day,
                                    time_entries_at_time_utc=at_time_zone_offset,
                                )
                                toggl_user1.save()
                except toggl_user.DoesNotExist:
                    # Handle the case where the toggl_user does not exist
                    return HttpResponse("Toggl user not found")

                except Exception as e:
                    # Handle other exceptions, you may want to log the error for debugging
                    print(f"An error occurred: {str(e)}")
                    return HttpResponse("An error occurred")
                    # Parse the start and end dates into datetime objects

            elif action == 'Fetch from Database':
                start_date = datetime.strptime(start_date, '%Y-%m-%d')
                end_date = datetime.strptime(end_date, '%Y-%m-%d')
                print(start_date)
                print(end_date)
                toggl_project_record = project.objects.get(id=project_id)
                toggl_project_id = toggl_project_record.toggl_project_id
                print("musan")
                print(toggl_project_id)
                # Filter records based on the selected date range
                filtered_records = toggl_user_detail.objects.filter(
                    project_id=toggl_project_id,
                    time_entries_start_date__range=(start_date, end_date)

                )
                # print("filete")
                # print(filtered_records)
                # Initialize total_work_hours to 0
                total_work_hours = 0
                results = []

                user_duration_data = filtered_records.values('employee_id').annotate(
                    total_duration=Sum('time_entries_seconds'))

                # Iterate over the grouped data, fetch the first and last name, and convert the total duration to hours, minutes, and seconds
                for entry in user_duration_data:
                    employee_id = entry['employee_id']
                    total_seconds = entry['total_duration']

                    # Fetch the first and last name based on the employee ID
                    try:
                        user_info = employee.objects.get(id=employee_id)
                        first_name = user_info.first_name
                        last_name = user_info.last_name
                        employee_salary = user_info.salary
                        # employee_salary = 6049.61
                    except employee.DoesNotExist:
                        first_name = "Unknown"
                        last_name = "Unknown"

                    # Calculate hours, minutes, and seconds
                    hours, remainder = divmod(total_seconds, 3600)
                    minutes, seconds = divmod(remainder, 60)
                    # Calculate total hours worked
                    total_hours_worked = hours + (minutes / 60) + (seconds / 3600)
                    # Calculate hourly rate based on monthly salary
                    monthly_salary = employee_salary
                    working_days_per_month = 22
                    hours_per_day = 8
                    hourly_rate = float(monthly_salary) / (
                            working_days_per_month * hours_per_day)  # Convert to float here

                    # Calculate earned salary
                    earned_salary = total_hours_worked * hourly_rate

                    # Print the results
                    name = f"{first_name} {last_name}"
                    # Format hours, minutes, and seconds with leading zeros
                    formatted_hours = f"{hours:02}"
                    formatted_minutes = f"{minutes:02}"
                    formatted_seconds = f"{seconds:02}"

                    results.append({
                        'name': name,
                        'hours_worked': formatted_hours,
                        'minutes_worked': formatted_minutes,
                        'seconds_worked': formatted_seconds,
                        'total_hours_worked': total_hours_worked,
                        'employee_salary': employee_salary,
                        'earned_salary': "{:.2f}".format(earned_salary)
                    })
                print("lkjhb")
                print(results)
                # # Calculate the total earned salary for all employees
                # total_earned_salary1 = sum(entry['earned_salary'] for entry in results)
                # total_earned_salary = "{:.2f}".format(total_earned_salary1)
                # Calculate the total earned salary for all employees
                total_earned_salary1 = sum(float(entry['earned_salary']) for entry in results)
                total_earned_salary = "{:.2f}".format(total_earned_salary1)



                # Calculate the total hours worked for all employees
                total_hours_worked_seconds = sum(entry['total_hours_worked'] * 3600 for entry in results)

                # Calculate hours, minutes, and seconds
                total_hours, remainder = divmod(total_hours_worked_seconds, 3600)
                total_minutes, total_seconds = divmod(remainder, 60)

                # Format the result as "hours:minutes:seconds"
                formatted_total_hours_worked = "{:02}:{:02}:{:02}".format(int(total_hours), int(total_minutes),
                                                                          int(total_seconds))
                print("sahil")
                print(formatted_total_hours_worked)


                for entry in results:
                    print("Name:", entry['name'])
                    print("Hours Worked:", entry['hours_worked'])
                    print("Minutes Worked:", entry['minutes_worked'])
                    print("Seconds Worked:", entry['seconds_worked'])
                    print("Total hour Worked:", entry['total_hours_worked'])
                    print("Employee Salary:", entry['employee_salary'])
                    print()

                print("Total Earned Salary for All Employees:", total_earned_salary)
                project_detail = project.objects.get(pk=project_id)
                # Extract project_ids from the queryset
                project_ids = [project_detail.toggl_project_id]

                # Now project_ids contains the project IDs of the first 200 projects
                print(project_ids)
                # Initialize an empty dictionary to store project_id and corresponding user_ids
                project_user_dict = {}

                # Iterate through each project_id
                for project_id in project_ids:
                    # Get unique user_id values for the specified project_id
                    user_ids = toggl_user_detail.objects.filter(project_id=project_id).values_list('user_id',
                                                                                                   flat=True).distinct()

                    # Assign the user_ids to the dictionary with project_id as the key
                    project_user_dict[project_id] = list(user_ids)

                print(project_user_dict)

                for project_id, user_ids in project_user_dict.items():
                    # Fetch image URLs and full names for each user_id from the Employee model
                    employees_data = employee.objects.filter(toggl_user_id__in=user_ids).values('id', 'first_name',
                                                                                                'last_name',
                                                                                                'image_url').distinct()

                    # Update the project_user_dict with image_urls and full names for each project_id
                    project_user_dict[project_id] = [

                        {'id': data['id'], 'image_url': data['image_url'],
                         'full_name': f"{data['first_name']} {data['last_name']}"}
                        for data in employees_data]

                print(project_user_dict)

                context = {
                    'project': project_detail,
                    'total_earned_salary': total_earned_salary,
                    'total_hours_worked':formatted_total_hours_worked,
                    'results': results,
                    'team_member_images': project_user_dict

                }
                return render(request, 'view_project.html', context)
            # # Assuming you want to fetch data for October of the current year
    current_year = 2023
    start_date = date(current_year, 9, 1)  # October 1st of the current year
    end_date = date(current_year, 9, 30)  # October 31st of the current year
    toggl_project_record = project.objects.get(id=project_id)
    toggl_project_id = toggl_project_record.toggl_project_id
    print("musan")
    print(toggl_project_id)
    # Filter records based on the selected date range
    filtered_records = toggl_user_detail.objects.filter(
        project_id=toggl_project_id,
        time_entries_start_date__range=(start_date, end_date)
    )
    # print("filete")
    # print(filtered_records)
    # Initialize total_work_hours to 0
    total_work_hours = 0
    results = []

    user_duration_data = filtered_records.values('employee_id').annotate(
        total_duration=Sum('time_entries_seconds'))

    # Iterate over the grouped data, fetch the first and last name, and convert the total duration to hours, minutes, and seconds
    for entry in user_duration_data:
        employee_id = entry['employee_id']
        total_seconds = entry['total_duration']

        # Fetch the first and last name based on the employee ID
        try:
            user_info = employee.objects.get(id=employee_id)
            first_name = user_info.first_name
            last_name = user_info.last_name
            employee_salary = user_info.salary
            # employee_salary = 6049.61
        except employee.DoesNotExist:
            first_name = "Unknown"
            last_name = "Unknown"

        # Calculate hours, minutes, and seconds
        hours, remainder = divmod(total_seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        # Calculate total hours worked
        total_hours_worked = hours + (minutes / 60) + (seconds / 3600)
        # Calculate hourly rate based on monthly salary
        monthly_salary = employee_salary
        working_days_per_month = 22
        hours_per_day = 8
        hourly_rate = float(monthly_salary) / (
                working_days_per_month * hours_per_day)  # Convert to float here

        # Calculate earned salary
        earned_salary = total_hours_worked * hourly_rate

        # Print the results
        name = f"{first_name} {last_name}"
        # Format hours, minutes, and seconds with leading zeros
        formatted_hours = f"{hours:02}"
        formatted_minutes = f"{minutes:02}"
        formatted_seconds = f"{seconds:02}"

        results.append({
            'name': name,
            'hours_worked': formatted_hours,
            'minutes_worked': formatted_minutes,
            'seconds_worked': formatted_seconds,
            'total_hours_worked': total_hours_worked,
            'employee_salary': employee_salary,
            'earned_salary': "{:.2f}".format(earned_salary)
        })
    print("lkjhb")
    print(results)
    # # Calculate the total earned salary for all employees
    # total_earned_salary1 = sum(entry['earned_salary'] for entry in results)
    # total_earned_salary = "{:.2f}".format(total_earned_salary1)
    # Calculate the total earned salary for all employees
    total_earned_salary1 = sum(float(entry['earned_salary']) for entry in results)
    total_earned_salary = "{:.2f}".format(total_earned_salary1)

    # Calculate the total hours worked for all employees
    total_hours_worked_seconds = sum(entry['total_hours_worked'] * 3600 for entry in results)

    # Calculate hours, minutes, and seconds
    total_hours, remainder = divmod(total_hours_worked_seconds, 3600)
    total_minutes, total_seconds = divmod(remainder, 60)

    # Format the result as "hours:minutes:seconds"
    formatted_total_hours_worked = "{:02}:{:02}:{:02}".format(int(total_hours), int(total_minutes),
                                                              int(total_seconds))
    print("sahil")
    print(formatted_total_hours_worked)

    for entry in results:
        print("Name:", entry['name'])
        print("Hours Worked:", entry['hours_worked'])
        print("Minutes Worked:", entry['minutes_worked'])
        print("Seconds Worked:", entry['seconds_worked'])
        print("Total hour Worked:", entry['total_hours_worked'])
        print("Employee Salary:", entry['employee_salary'])
        print()

    print("Total Earned Salary for All Employees:", total_earned_salary)

    print("l")
    print(project_id)
    project_detail = project.objects.get(pk=project_id)
    # Extract project_ids from the queryset
    project_ids = [project_detail.toggl_project_id]

    # Now project_ids contains the project IDs of the first 200 projects
    print(project_ids)
    # Initialize an empty dictionary to store project_id and corresponding user_ids
    project_user_dict = {}

    # Iterate through each project_id
    for project_id in project_ids:
        # Get unique user_id values for the specified project_id
        user_ids = toggl_user_detail.objects.filter(project_id=project_id).values_list('user_id', flat=True).distinct()

        # Assign the user_ids to the dictionary with project_id as the key
        project_user_dict[project_id] = list(user_ids)

    print(project_user_dict)

    for project_id, user_ids in project_user_dict.items():
        # Fetch image URLs and full names for each user_id from the Employee model
        employees_data = employee.objects.filter(toggl_user_id__in=user_ids).values('id', 'first_name',
                                                                                    'last_name', 'image_url').distinct()

        # Update the project_user_dict with image_urls and full names for each project_id
        project_user_dict[project_id] = [

            {'id': data['id'],'image_url': data['image_url'], 'full_name': f"{data['first_name']} {data['last_name']}"}
            for data in employees_data]

    print(project_user_dict)
    context = {
        'project': project_detail,
        'total_earned_salary': total_earned_salary,
        'total_hours_worked': formatted_total_hours_worked,
        'results': results,
        'team_member_images': project_user_dict
    }
    return render(request, 'view_project.html', context)


@csrf_exempt
@login_required(login_url='/')
def holidays(request):
    active = [''] * 15
    active[3] = 'active'
    country_name = Country.objects.values_list('name', flat=True).distinct()
    south_africa_holidays = Holiday.objects.filter(country_id=4)
    philippine_holidays = Holiday.objects.filter(country_id=2)

    us_id = Country.objects.filter(code='US').first()
    uk_id = Country.objects.filter(code='UK').first()   
    in_id = Country.objects.filter(code='IN').first()   

    if us_id:
        us_id = us_id.id
    if uk_id:
        uk_id = uk_id.id
    if in_id:
        in_id = in_id.id
    from django.db.models import F, Value
    from django.db.models.functions import Concat

    from django.db.models.functions import ExtractYear

    ind_holidays = Holiday.objects.filter(
        country_id=in_id
    ).annotate(
        year=ExtractYear('date')
    ).filter(
        year=2026
    ).annotate(
        country_code=Value('IN')
    ).values('id', 'name', 'date', 'country_code')
    print(ind_holidays)
    # US Holidays for 2026
    us_holidays = Holiday.objects.filter(
        country_id=us_id
    ).annotate(
        year=ExtractYear('date')
    ).filter(
        year=2026
    ).annotate(
        country_code=Value('US')
    ).values('id', 'name', 'date', 'country_code')

    # UK Holidays for 2026
    uk_holidays = Holiday.objects.filter(
        country_id=uk_id
    ).annotate(
        year=ExtractYear('date')
    ).filter(
        year=2026
    ).annotate(
        country_code=Value('UK')
    ).values('id', 'name', 'date', 'country_code')


    combined_holidays = us_holidays.union(uk_holidays)

    # Process combined holidays to adjust country names
    seen_holidays = {}
    for holiday in combined_holidays:
        key = (holiday['name'], holiday['date'])
        if key in seen_holidays:
            seen_holidays[key]['country_code'] = 'All'
        else:
            seen_holidays[key] = holiday

    # Convert the processed holidays back to a list of dictionaries
    uk_us_holidays = list(seen_holidays.values())
    uk_us_holidays = sorted(uk_us_holidays, key=lambda x: x['date'])
    us_holidays = sorted(us_holidays, key=lambda x: x['date'])
    uk_holidays = sorted(uk_holidays, key=lambda x: x['date'])
    ind_holidays = sorted(ind_holidays, key=lambda x: x['date'])
    country_list = Country.objects.all()
    # print(country_list)
    # return HttpResponse(country_list)

    return render(request, "employees/holidays.html",
                  {'country_names': country_name, 'us_holidays': us_holidays,'ind_holidays': ind_holidays, 'uk_holidays': uk_holidays,
                   'south_africa_holidays': south_africa_holidays, 'philippine_holidays': philippine_holidays,'uk_us_holidays':uk_us_holidays,'active':active,'country_list':country_list})

@csrf_exempt
@login_required(login_url='/')
def update_employee(request):
    if request.method == 'POST':
        import csv
        import io
        # csv_file = request.FILES['emp_file']
        csv_file = request.FILES.get('emp_file')
        decoded_file = csv_file.read().decode('utf-8')
        io_string = io.StringIO(decoded_file)
        reader = csv.DictReader(io_string)
        # from django.http import HttpResponse
        # return HttpResponse(reader)
        for row in reader:
            print(row)
            # user_email = "sbhutra@educatedc.com"
            user_email = row['EC Email'].strip()
            first_name = row['First Name'].strip()
            last_name = row['Last Name'].strip()
            department = row['Department'].strip()
            designation = row['Designation'].strip()
            date_of_birth = row['Birthday'].strip()
            phone = row['Phone'].strip()
            gender = row['Gender'].strip()
            personal_email = row['Personal Email'].strip()
            image_url = row['Image URL'].strip()

            original_date = row['Birthday'].strip()
            if original_date:
                date_object = datetime.strptime(original_date, '%B %d %Y')
                formatted_date = date_object.strftime('%Y-%m-%d')
            else:
                formatted_date=''
            if image_url:
                image_url = os.path.join(settings.STATIC_URL, 'assets','img', 'user', image_url+".jpeg")

            # from django.http import HttpResponse
            # return HttpResponse(formatted_date)
            if user_email:
                try:
                    existing_employee = employee.objects.get(email=user_email)
                    # from django.http import HttpResponse
                    # return HttpResponse(existing_employee)
                    if existing_employee:
                        existing_employee = employee.objects.get(email=user_email)
                        existing_employee.first_name = first_name
                        existing_employee.last_name = last_name
                        existing_employee.department = department
                        existing_employee.designation = designation
                        existing_employee.date_of_birth = formatted_date
                        existing_employee.phone = phone
                        existing_employee.gender = gender
                        existing_employee.personal_email = personal_email
                        existing_employee.image_url = image_url
                        existing_employee.save()
                    # from django.http import HttpResponse
                    # return HttpResponse(existing_employee.id)
                    emergency_details = row['Emergency Contact'].strip()
                    emergency_list = emergency_details.split('(',1)
                    emergency_name = emergency_list[0]
                    emergency_relation_list = emergency_list[1].split(')',1)
                    emergency_relation = emergency_relation_list[0]
                    emergency_phone = emergency_relation_list[1]
                    try:
                        employee_details = employee_detail.objects.filter(employee_id=existing_employee.id).first()
                    except Exception as e:
                        employee_details = ''
                    if employee_details:
                        # from django.http import HttpResponse
                        # var = "Test"
                        # return HttpResponse(str(var))
                        employee_details.emergency_contact = emergency_phone
                        employee_details.name = emergency_name
                        employee_details.relationship = emergency_relation
                        employee_details.save()
                    else:
                        new_employee_details = employee_detail(employee_id=existing_employee.id,emergency_contact=emergency_phone, name=emergency_name, relationship=emergency_relation)
                        # from django.http import HttpResponse
                        # var = "Test2"
                        # return HttpResponse(new_employee_details)
                        new_employee_details.save()
                except Exception as e:
                    print(e)
        return redirect("employees")

    return render(request, "excel/update_employee.html", {})


@csrf_exempt
@login_required(login_url='/')
def employee_sheet(request):
    if request.method == 'POST':
        import csv
        import io
        # Fetch only the 'toggl_client_id' and 'toggl_client_name' fields
        clients = employee.objects.values('user_name', 'email')
        # from django.http import HttpResponse
        # return HttpResponse(clients)
        # Create a response object with CSV content type
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = 'attachment; filename="employee_data.csv"'

        # Create a CSV writer
        csv_writer = csv.writer(response)

        # Write headers to the CSV file
        csv_writer.writerow(['User Name', 'Email'])

        # Write data to the CSV file
        for client_data in clients:
            csv_writer.writerow([client_data['user_name'], client_data['email']])

        return response
    return render(request, "employee_sheet.html", {})

@csrf_exempt
@login_required(login_url='/')
def update_client(request):
    if request.method == 'POST':
        import csv
        import io
        csv_file = request.FILES.get('emp_file')
        decoded_file = csv_file.read().decode('utf-8')
        io_string = io.StringIO(decoded_file)
        reader = csv.DictReader(io_string)
        for row in reader:
            # return HttpResponse(row['Toggl Client ID'])
            print('Client Id')
            print(row['Toggl Client ID'])
            try:
                existing_elient = client.objects.get(toggl_client_id=row['Toggl Client ID'])
                if existing_elient:
                    name = row['Name'].strip()
                    if not name:
                        name_list = row['Toggl Client Name'].split(',')
                        if(len(name_list) > 1):
                            name = name_list[1]
                            name = name.strip()
                    existing_elient.client_name = name

                    company_name = row['Company Name'].strip()
                    if not company_name:
                        company_list = row['Toggl Client Name'].split(',')
                        if(len(company_list) > 1):
                            company_name = company_list[0]
                            company_name = company_name.strip()
                    # from django.http import HttpResponse
                    existing_elient.company_name = company_name
                    # designation = row['Cost'],
                    existing_elient.gender = row['Gender'].strip()
                    image_name = row['Image URL'].strip()
                    if image_name:
                        image_name = os.path.join(settings.STATIC_URL, 'assets','img', 'client', image_name+".jpeg")
                        existing_elient.image_url = image_name
                    
                    # return HttpResponse(image_name)
                    existing_elient.company_size = row['Company Size']
                    existing_elient.country = row['Country'].strip()
                    existing_elient.industry = row['Industry'].strip()
                    existing_elient.level = row['Level'].strip()
                    existing_elient.location = row['Location'].strip()
                    existing_elient.region = row['Region'].strip()
                    existing_elient.save()

            except client.DoesNotExist:
                # Handle the case where the client does not exist
                # You can return an error or take other appropriate actions here
                pass

            # existing_project = project.objects.filter(toggl_client_id=row['Toggl Client ID'].strip()).all()
            # if existing_project:
            #     project.objects.filter(toggl_client_id=row['Toggl Client ID'].strip()).update(rate=row['Cost'].strip())

        return redirect("current_clients")
    return render(request, "excel/update_client.html", {})

@login_required(login_url='/')
def ajax_get_items(request):
    category_name = request.GET.get('category_id')

    if category_name =='company':
        items = client.objects.order_by('company_name').distinct('company_name').values('id').annotate(name=F('company_name'))
    elif category_name =='industry':
        items = client.objects.order_by('industry').distinct('industry').values('id').annotate(name=F('industry'))
    elif category_name =='level':
        items = client.objects.order_by('level').distinct('level').values('id').annotate(name=F('level'))
    elif category_name =='country':
        items = client.objects.order_by('country').distinct('country').values('id').annotate(name=F('country'))
    elif category_name =='region':
        items = client.objects.order_by('region').distinct('region').values('id').annotate(name=F('region'))
    else:
        items = client.objects.order_by('company_name').distinct('company_name').values('id').annotate(name=F('company_name'))

    # from django.http import HttpResponse
    # return HttpResponse(items)
    return JsonResponse({"items": list(items)})

@login_required(login_url='/')
def search_client(request):
    category_name = request.GET.get('category')
    selected_category = request.GET.getlist('selected_category')
    client_id = request.GET.getlist('client_id')
    search_from = request.GET.get('search_from', '')

    if search_from == 'current_clients':
        selected_month = request.session.get('month')
        import calendar
        from datetime import date

        if selected_month:
            current_month = int(selected_month)
        else:
            current_month = 2

        selected_year = request.session.get('year')

        if selected_year:
            current_year = int(selected_year)
        else:
            current_year = 2026

        start_date = date(current_year, current_month, 1)
        end_date = date(current_year, current_month, calendar.monthrange(current_year, current_month)[1])
        client_contract_work = Client_contract_work.objects.filter(date__gte=start_date, date__lte=end_date)
        client_contract_work = Client_contract_work.objects.filter(date__gte=start_date, date__lte=end_date)

        client_contract_work_with_client_info = []
        for work in client_contract_work:
            client_info = client.objects.get(id=work.client_id)
            client_contract_work_with_client_info.append((work, client_info))

        client_list = [client_info for _, client_info in client_contract_work_with_client_info]
        client_ids = [client_info.id for client_info in client_list]
    else:
        client_ids = []
    print("Vinod client_ids",selected_category)
    
    if client_id:
        client_list = client.objects.filter(id__in=client_id)
    else:
        if category_name =='company':
            client_list = client.objects.filter(company_name__in=selected_category)
        elif category_name =='industry':
            client_list = client.objects.filter(industry__in=selected_category)
        elif category_name =='level':
            client_list = client.objects.filter(level__in=selected_category)
        elif category_name =='country':
            client_list = client.objects.filter(country__in=selected_category)
        elif category_name =='region':
            client_list = client.objects.filter(region__in=selected_category)
        else:
            client_list = client.objects.filter(company_name__in=selected_category)

    if client_ids:
        client_list = client_list.filter(id__in=client_ids)
    if search_from == 'archived_clients':
        client_list = client_list.filter(status=2)

    data = {"client_list": client_list}
    return render(request, 'search_client.html', data)

@login_required(login_url='/')
def get_employee(request):
    employee_id = request.GET.get('employee_id')
    employee_detail = employee.objects.filter(id=employee_id).first()
    data = {
        'id': employee_detail.id,
        'first_name': employee_detail.first_name,
        'last_name': employee_detail.last_name,
        'designation': employee_detail.designation,
        'phone': employee_detail.phone,
        'gender': employee_detail.gender,
        'salary': employee_detail.salary,
        'personal_email': employee_detail.personal_email,
        'date_of_birth': employee_detail.date_of_birth,
    }
    return JsonResponse(data)

@login_required(login_url='/')
def edit_employee(request):
    first_name = request.POST.get('first_name')
    last_name = request.POST.get('last_name')
    personal_email = request.POST.get('personal_email')
    phone = request.POST.get('phone')
    designation = request.POST.get('designation')
    employee_id = request.POST.get('employee_id')
    try:
        existing_employee = employee.objects.get(id=employee_id)
        if existing_employee:
            existing_employee.first_name = first_name
            existing_employee.last_name = last_name
            existing_employee.personal_email = personal_email
            existing_employee.designation = designation
            existing_employee.phone = phone
            existing_employee.save()
    except Exception as e:
        print(e)

    return redirect('employees')

@login_required(login_url='/')
def update_month(request):
    month = request.GET.get('month')
    year = request.GET.get('year')

    request.session['month'] = month
    request.session['year'] = year
    request.session.save()

    return JsonResponse({"month": month, "year": year})

@login_required(login_url='/')
def get_projects(request, employee_id):
    if request.method == 'GET':
        start_date = request.GET.get('start_date')
        end_date = request.GET.get('end_date')

        start_date = datetime.strptime(start_date, '%Y-%m-%d')
        end_date = datetime.strptime(end_date, '%Y-%m-%d')

        # Filter records based on the selected date range
        filtered_records = toggl_user_detail.objects.filter(
            employee_id=employee_id,
            time_entries_start_date__range=(start_date, end_date)
        )
        print("filete")
        print(filtered_records)
        # for printing toggl rows
        # Create a list to store the detailed records
        detailed_records = []

        # Iterate through filtered records
        for record in filtered_records:
            project_id = record.project_id
            print(project_id)
            # project_detail = toggl_project_detail.objects.filter(toggl_project_id=project_id).first()
            # print(project_detail)
            toggl_project = project.objects.get(toggl_project_id=project_id)
            toggl_projectid = toggl_project.toggl_project_id
            toggl_client = toggl_project.toggl_client_id
            toggl_projectname = toggl_project.toggl_project_name
            # print(toggl_projectid)
            # print(toggl_client)
            print(toggl_projectname)
            toggl_client = client.objects.get(toggl_client_id=toggl_client)
            toggl_clientname = toggl_client.toggl_client_name
            print(toggl_clientname)

            # Create a dictionary to store the detailed record
            detailed_record = {
                'record': record,
                'toggl_projectname': toggl_projectname,
                'toggl_clientname': toggl_clientname
            }

            # Append the detailed record to the list
            detailed_records.append(detailed_record)

        print(detailed_records)

        context = {
            'detailed_records': detailed_records,
        }
        return render(request, 'get_projects.html', context)

@csrf_exempt
@login_required(login_url='/')
def leave_admin(request):
    active = [''] * 15
    active[4] = 'active'
    leave_year = datetime.now().year
    result_list =[]
    if request.method == 'POST':
        request_for = request.POST.get('request_for')
        # return HttpResponse(request_for)
        if request_for == 'add_leave':
            leave_type = request.POST.get('leave_type')
            from_date = request.POST.get('from_date')
            to_date = request.POST.get('to_date')
            reason = request.POST.get('reason')
            employee_id = request.POST.get('employee_id')

            parsed_date = datetime.strptime(from_date, "%Y-%m-%d")
            from_date = parsed_date.strftime("%Y-%m-%d")

            parsed_date2 = datetime.strptime(to_date, "%Y-%m-%d")
            to_date = parsed_date2.strftime("%Y-%m-%d")
            new_leave = leave(
                employee_id=employee_id,
                leave_type_id=leave_type,
                start_date=from_date,
                end_date=to_date,
                status='pending',
                reason=reason
            )
            new_leave.save()
        elif request_for == 'edit_leave':
            leave_type = request.POST.get('leave_type')
            from_date = request.POST.get('edit_from_date')
            to_date = request.POST.get('edit_to_date')
            reason = request.POST.get('reason')
            leave_id = request.POST.get('leave_id')
            try:
                existing_leave = leave.objects.get(id=leave_id)
                # from django.http import HttpResponse
                # return HttpResponse(existing_leave)
                if existing_leave:
                    existing_leave.leave_type_id = leave_type
                    existing_leave.reason = reason
                    existing_leave.start_date = from_date
                    existing_leave.end_date = to_date
                    existing_leave.save()
                # from django.http import HttpResponse
                # return HttpResponse(existing_employee.id)
            except Exception as e:
                print(e)    
        elif request_for == 'search_leave':
            employee_name = request.POST.get('employee_name')
            leave_type = request.POST.get('leave_type')
            status = request.POST.get('status')
            leave_year = request.POST.get('leave_year',None)
            search_from_date = request.POST.get('search_from_date')
            search_to_date = request.POST.get('search_to_date')
            if search_from_date:
                parsed_date = datetime.strptime(search_from_date, "%Y-%m-%d")
                start_date = parsed_date.strftime("%Y-%m-%d")
            else:
                start_date =None
            if search_to_date:
                parsed_date = datetime.strptime(search_to_date, "%Y-%m-%d")
                end_date = parsed_date.strftime("%Y-%m-%d")
            else:
                end_date = None

            leave_status = status if status else None
            leave_type = leave_type if leave_type else None

            first_name = last_name = employee_name if employee_name else None
            search_term = f"%{employee_name}%" if employee_name else None
            query = """
            SELECT e.id as emp_id,e.first_name,e.last_name,e.image_url,e.user_name,e.country_id,lt.name,l.* FROM dec_leave l
            JOIN dec_employee e ON CAST(l.employee_id AS bigint) = e.id
            JOIN dec_leavetype lt ON CAST(l.leave_type_id AS bigint) = lt.id
            WHERE 
            (
                (%s IS NULL OR e.first_name ILIKE %s)
                OR (%s IS NULL OR e.last_name ILIKE %s)
            )
            AND (%s IS NULL OR LOWER(l.status) = LOWER(%s))
            AND (%s IS NULL OR l.leave_type_id = %s)
            AND (%s IS NULL OR l.start_date >= %s)
            AND (%s IS NULL OR l.end_date <= %s)
            """
            params = [search_term, search_term, search_term, search_term,leave_status, leave_status,leave_type,leave_type, start_date, start_date, end_date, end_date]

            with connection.cursor() as cursor:
                cursor.execute(query, params)
                result_list = cursor.fetchall()
                column_names = [col[0] for col in cursor.description]

            # Convert tuples to dictionaries
            dict_results = [dict(zip(column_names, row)) for row in result_list]
            dict_results = sorted(dict_results, key=lambda x: x['start_date'], reverse=True)
            if leave_year:
                dict_results = [
                entry for entry in dict_results
                if entry['start_date'].year == int(leave_year) or entry['end_date'].year == int(leave_year)
                ]
            else:           #27_1_25 ASHOK ADDED THIS
                current_year = datetime.now().year
                dict_results = [
                    entry for entry in dict_results
                    if entry['start_date'].year == int(current_year) or entry['end_date'].year == int(current_year)
                ]
            if not result_list:
                result_list =[]
    if request.method == 'POST' :
        request_for = request.POST.get('request_for')
    else:
        request_for = ''
    if request_for != 'search_leave' :
        start_date =None
        end_date = None
        leave_status = None
        leave_type = None
        search_term = None
        employee_name = None
        result_list =[]
        query = """
        SELECT e.id as emp_id,e.first_name,e.last_name,e.image_url,e.user_name,e.country_id,lt.name,l.* FROM dec_leave l
        JOIN dec_employee e ON CAST(l.employee_id AS bigint) = e.id
        JOIN dec_leavetype lt ON CAST(l.leave_type_id AS bigint) = lt.id
        WHERE 
        (
            (%s IS NULL OR e.first_name ILIKE %s)
            OR (%s IS NULL OR e.last_name ILIKE %s)
        )
        AND (%s IS NULL OR l.status = %s)
        AND (%s IS NULL OR l.leave_type_id = %s)
        AND (%s IS NULL OR l.start_date >= %s)
        AND (%s IS NULL OR l.end_date <= %s)
        """
        params = [search_term, search_term, search_term, search_term,leave_status, leave_status,leave_type,leave_type, start_date, start_date, end_date, end_date]

        # return HttpResponse(leave_type)
        with connection.cursor() as cursor:
            cursor.execute(query, params)
            result_list = cursor.fetchall()
            column_names = [col[0] for col in cursor.description]

        # Convert tuples to dictionaries
        dict_results = [dict(zip(column_names, row)) for row in result_list]
        dict_results = sorted(dict_results, key=lambda x: x['start_date'], reverse=True)
        current_year = datetime.now().year
        print(current_year)
        dict_results = [
            entry for entry in dict_results
            if entry['start_date'].year == int(current_year) or entry['end_date'].year == int(current_year)
        ]

        # return HttpResponse(dict_results)
    # Query all leaves from the 'Leave' model
    all_leaves = leave.objects.all().order_by('id')  # Use 'Leave' instead of 'leave'
    employees = employee.objects.filter(status=1).order_by('image_url')  # Use 'Leave' instead of 'leave'

    leave_details = []
    pending_leave_count = 0
    planned_leave_count = 0
    approved_leave_count = 0
    employee_count = employees.count()
    current_year = datetime.now().year
    pending_leave_count = leave.objects.filter(status__iexact='pending',start_date__year=current_year).count()
    approved_leave_count = leave.objects.filter(status__iexact='approved', start_date__year=current_year).count()

    today_date = datetime.now().date()

    try:
        if today_date.weekday() not in [4, 5, 6]:
            planned_leave_ids = leave.objects.filter(
                start_date__lte=today_date,
                end_date__gte=today_date
            ).values_list('employee_id', flat=True)
        else:
            planned_leave_ids = []

        # Get country IDs for holidays today
        holiday_country_ids = Holiday.objects.filter(date=today_date).values_list('country_id', flat=True)

        # Get employee IDs for employees in countries with holidays today
        holiday_employee_ids = employee.objects.filter(
            country_id__in=holiday_country_ids,
            status=1
        ).values_list('id', flat=True)

        # Find overlap: Employees on both holiday and planned leave
        overlap_ids = set(planned_leave_ids).intersection(holiday_employee_ids)

        # Calculate the total counts
        planned_leave_count = len(planned_leave_ids)
        holiday_employees_count = len(holiday_employee_ids)
        overlap_count = len(overlap_ids)

        presents_count = employee_count - planned_leave_count - holiday_employees_count + overlap_count

        print(f"Presents Count: {presents_count}",holiday_employee_ids)
    except Exception as e:
        presents_count = employee_count-planned_leave_count


    print('dict_results')
    
    for dict_result in dict_results:
        all_leaves = leave.objects.filter(
            employee_id=dict_result['emp_id'],
            start_date__year=current_year
        ).exclude(
            status='declined'
        )
        total_taken_days = 0
        for leave_detail in all_leaves:
            leave_start_date = leave_detail.start_date
            leave_end_date = leave_detail.end_date
            current_date = leave_start_date
            if leave_end_date is None:
                continue  # Skip this leave detail if end_date is None
            # Check each day between start and end date
            if leave_detail.day_type == 1:
                while current_date <= leave_end_date:
                    if current_date.weekday() < 4:  # Monday to Friday are represented by 0 to 4
                        total_taken_days += 1
                    current_date += timedelta(days=1)  # Move to the next day
            else:
                if leave_start_date.weekday() < 4:
                    total_taken_days += 0.5
        country_detail = Country.objects.get(id=dict_result['country_id'])
        # remaining_leave = country_detail.paid_leave - total_taken_days
        remaining_leave = country_detail.paid_leave - total_taken_days

        dict_result['remaining_leave'] = remaining_leave
        print(all_leaves)
        print(dict_result)

    # Pass the leave details to the template
    leaveTypes = LeaveType.objects.all()
    # presents_count = employee_count-planned_leave_count
    context = {
        # 'leave_details': leave_details,
        'leave_type':leaveTypes,
        'employees':employees,
        'pending_leave_count':pending_leave_count,
        'planned_leave_count':planned_leave_count,
        'approved_leave_count': approved_leave_count,
        'employee_count':employee_count,
        'presents_count':presents_count,
        'result_list':result_list,
        'dict_results':dict_results,
        'employee_name':employee_name,
        'leave_status':leave_status,
        'leave_type_id':leave_type,
        'start_date':start_date,
        'end_date':end_date,
        'active':active,
        'leave_year':int(leave_year),
    }
    return render(request, 'employees/leaves.html', context)

@csrf_exempt
@login_required(login_url='/')
def leave_employee(request):
    active = [''] * 15
    active[5] = 'active'

    start_date = None
    end_date = None
    leave_status = None
    leave_type = None
    search_term = None
    employee_name = None
    user_id = request.user.id
    employee_detail = employee.objects.get(user_id=user_id)
    print(employee_detail )
    employee_id = employee_detail.id

    if employee_detail.country_id:
        country_id = employee_detail.country_id
    else:
        country_id = 1
    country_detail = Country.objects.get(id=country_id)

    query = """
            SELECT e.id as emp_id,e.first_name, e.last_name, e.image_url, e.user_name, lt.name, l.*
            FROM dec_leave l
            LEFT JOIN dec_employee e ON l.approved_by = e.id
            JOIN dec_leavetype lt ON CAST(l.leave_type_id AS bigint) = lt.id
            WHERE
            (%s IS NULL OR l.employee_id = %s)
        """

    params = [employee_id, employee_id]

    # Using 'DictCursor'
    with connection.cursor() as cursor:
        cursor.execute(query, params)
        # Fetching results as dictionaries
        result_list = cursor.fetchall()
        column_names = [col[0] for col in cursor.description]

    # Convert tuples to dictionaries
    dict_results = [dict(zip(column_names, row)) for row in result_list]
    dict_results = sorted(dict_results, key=lambda x: x['start_date'], reverse=True)

    # ASHOK ADDED THIS FILTER FOR FILTER CURRENT YEAR LEAVE
    current_year = datetime.now().year
    print(current_year)
    dict_results = [
        entry for entry in dict_results
        if entry['start_date'].year == int(current_year) or entry['end_date'].year == int(current_year)
    ]
    employees = employee.objects.filter(status=1).order_by('image_url')  # Use 'Leave' instead of 'leave'

    leave_details = []
    pending_leave_count = 0
    planned_leave_count = 0
    employee_count = employees.count()
    pending_leave_count = leave.objects.filter(status__iexact='pending').count()

    today_date = datetime.now().date()
    planned_leave_count = leave.objects.filter(
        start_date__lte=today_date,
        end_date__gte=today_date
    ).count()


    # Pass the leave details to the template
    leaveTypes = LeaveType.objects.all()
    presents_count = employee_count - planned_leave_count

    current_year = datetime.now().year

    # Filter leaves for the current year only
    all_leaves = leave.objects.filter(
        employee_id=employee_id,
        start_date__year=current_year  # Ensure start_date falls in the current year
    ).exclude(
        status='declined'
    )
    
    # print("muskan")
    # print(all_leaves)
    total_taken = 0
    total_count = all_leaves.count()

    # Initialize variables to store counts for different leave types
    medical_leave = 0
    other_leave_count = 0

    for lea in all_leaves:
        total_taken += lea.leave_type_id  # This seems incorrect as it's adding up leave_type_ids, which doesn't make sense for a total. You might want to revise this logic.

        # Function to count days excluding weekends
        def count_days_excluding_weekends(start_date, end_date):
            day_count = 0
            current_date = start_date
            while current_date <= end_date:
                if current_date.weekday() < 4:  # Weekdays are 0-4 (Mon-Fri)
                    day_count += 1
                current_date += timedelta(days=1)
            return day_count

        if lea.leave_type_id == 2:  # Medical leave
            if lea.end_date == lea.start_date and lea.day_type == 1:
                if lea.start_date.weekday() < 4:
                    medical_leave += 1
            else:
                if lea.end_date and lea.day_type == 1:
                    duration = count_days_excluding_weekends(lea.start_date, lea.end_date)
                    medical_leave += duration  # Already an integer, no need to add 1 since we're counting all days excluding weekends
                else:
                    medical_leave += 0.5  # Assuming this is a half-day leave that doesn't need weekend exclusion
        else:  # Other leave
            if lea.end_date == lea.start_date and lea.day_type == 1:
                if lea.start_date.weekday() < 4:
                    other_leave_count += 1
            else:
                if lea.end_date and lea.day_type == 1:
                    duration = count_days_excluding_weekends(lea.start_date, lea.end_date)
                    other_leave_count += duration  # Excluding weekends
                else:
                    if lea.start_date.weekday() < 4:
                        other_leave_count += 0.5  # Assuming a half-day leave

    # Print or use the counts as needed
    print(f"Total Leaves: {total_count}")
    print(f"Total Taken Days: {total_taken}")
    print(f"Medical Leave: {medical_leave}")
    print(f"Other Leave Count: {other_leave_count}")
    if country_detail.paid_leave:
        remaining=country_detail.paid_leave-medical_leave-other_leave_count
        annual_leaves=country_detail.paid_leave
    else:
        remaining=12-medical_leave-other_leave_count
        annual_leaves=12

    print(remaining)

    total_taken_days = 0
    # return HttpResponse(all_leaves)
    for leave_detail in all_leaves:
        start_date = leave_detail.start_date  # Adjust indices based on your actual data structure
        end_date = leave_detail.end_date
        duration = (end_date - start_date).days + 1 if end_date and start_date else 0
        total_taken_days += duration
    remaining_leave = country_detail.paid_leave - total_taken_days
    # print(duration)
    # return HttpResponse(total_taken_days)
    current_date = date.today()
    context = {
        # 'leave_details': leave_details,
        'leave_type': leaveTypes,
        'employee_detail': employee_detail,
        'country_detail': country_detail,
        'pending_leave_count': pending_leave_count,
        'planned_leave_count': planned_leave_count,
        'employee_count': employee_count,
        'presents_count': presents_count,
        'result_list': result_list,
        'dict_results': dict_results,
        'employee_name': employee_name,
        'leave_status': leave_status,
        'leave_type_id': leave_type,
        'start_date': start_date,
        'end_date': end_date,
        'remaining_leave': remaining,
        'total_taken_days': total_taken_days,
        'annual_leaves':annual_leaves,
        'medical_leave': medical_leave,
        'remaining': remaining,
        'other_leave_count':other_leave_count,
        'active':active,
        'current_date':current_date
    }
    return render(request, 'employees/leaves-employee.html', context)
@csrf_exempt  # Use this decorator to temporarily disable CSRF protection for testing purposes
def search(request):
    if request.method == 'GET':
        print("search")
        # Retrieve the leave_type from the query parameters
        leave_type = request.GET.get('leave_type', None)
        print(leave_type)

        if leave_type:
            # Perform your search logic here using leave_type
            # Replace the following line with your actual search logic
            all_leaves = leave.objects.filter(leave_type_id=leave_type)

            # Initialize the list to store search results
            search_result = []

            for leave_instance in all_leaves:
                employee_id = leave_instance.employee_id

                # Query the 'Employee' model to get employee details
                try:
                    employee1 = employee.objects.get(toggl_user_id=employee_id)

                    # Calculate the number of days between start_date and end_date
                    start_date = leave_instance.start_date
                    end_date = leave_instance.end_date

                    # Handle the case where start_date and end_date are the same
                    duration = 1 if start_date == end_date else (end_date - start_date).days + 1

                    employee_details = {
                        'employee_id': employee1.id,
                        'first_name': employee1.first_name,
                        'last_name': employee1.last_name,
                        'image_url': employee1.image_url,
                        'user_name': employee1.user_name,
                        'leave_instance': {
                            'start_date': leave_instance.start_date,
                            'end_date': leave_instance.end_date,
                            'leave_type': leave_instance.leave_type_id,
                            'reason': leave_instance.reason,
                            'status': leave_instance.status,
                            # Add other leave instance details as needed
                        },
                        'duration': duration,
                    }

                    search_result.append(employee_details)

                except employee.DoesNotExist:
                    # Handle the case where the employee is not found
                    pass
            print(search_result)
            # Return the result as JSON
            return JsonResponse({'result': search_result})
        else:
            return JsonResponse({'error': 'No leave type specified'})
    else:
        # Handle other HTTP methods if needed
        return JsonResponse({'error': 'Invalid request method'})

@csrf_exempt
@login_required(login_url='/')
def upload_contracted_hours(request):
    import csv
    from django.shortcuts import render
    if request.method == 'POST':
        file = request.FILES.get('emp_file')
        if file:
            reader = csv.reader(file.read().decode('utf-8').splitlines())
            first_row = next(reader, None)  # Returns None if the file is empty
            index = 6
            employee_list = first_row [index:]
            employee_list = [item.split('(')[0] for item in employee_list]

            for row in reader:
                client_id = row[0].strip()
                client_name = row[1].strip()+','+row[2].strip()
                total_working_hours = row[4].strip()
                no_of_people_on_account = row[3].strip()
                current_month = int(row[5].strip())
                current_year = 2023
                import calendar
                input_dt = datetime(current_year, current_month, 13)
                res = calendar.monthrange(input_dt.year, input_dt.month)
                last_day = res[1]
                current_date = date(current_year, current_month, last_day)

                if not total_working_hours:
                    total_working_hours = 0
                if not no_of_people_on_account:
                    no_of_people_on_account = 0

                employee_working = row [index:]
                working_dict = {key: value for key, value in zip(employee_list, employee_working) if value != ''}

                json_data = json.dumps(working_dict)
                if client_id:
                    try:
                        try:
                            start_date = date(current_year, current_month, 1)  # October 1st of the current year
                            end_date = date(current_year, current_month, 31)
                            print(current_month)
                            # start_date = date(current_year, 9, 1)  # October 1st of the current year
                            # end_date = date(current_year, 9, 30)  # October 31st of the current year

                            client_details = contracted_hours.objects.filter(
                                client_id=client_id,
                                month__range=(start_date, end_date)
                            ).first()
                        except Exception as e:
                            client_details = ''
                        # from django.http import HttpResponse
                        # return HttpResponse(client_details)
                        if client_details:
                            client_details.client_name = client_name
                            client_details.total_working_hours = total_working_hours
                            client_details.working_input = json_data
                            client_details.no_of_people_on_account = no_of_people_on_account
                            client_details.month = current_date
                            client_details.save()
                        else:
                            new_client_details = contracted_hours(client_id=client_id,client_name=client_name,total_working_hours=total_working_hours,no_of_people_on_account=no_of_people_on_account, working_input=json_data,month=current_date)
                            new_client_details.save()
                    except Exception as e:
                        print(e)
        return redirect("employees")

    return render(request, "excel/upload_contracted_hours.html", {})

@csrf_exempt
@login_required(login_url='/')
def upload_client_contract_work(request):
    if request.method == 'POST':
        file = request.FILES.get('emp_file2')
        if file:
            reader = csv.reader(file.read().decode('utf-8').splitlines())
            first_row = next(reader, None)  # Returns None if the file is empty
            index = 7
            employee_list = first_row [index:]
            employee_list1 = [item.split('(')[0] for item in employee_list]
            employee_list = []

            for employee_id in employee_list1:
                try:
                    # Assuming 'toggl_client_id' is the field in the Client model corresponding to the employee ID
                    emp_obj = employee.objects.get(toggl_user_id=employee_id)
                    employee_list.append(emp_obj.id)
                except employee.DoesNotExist:
                    # Handle the case where the client with the specified toggl_client_id does not exist
                    print(f"Client with toggl_client_id {employee_id} does not exist.")

            # Now 'client_ids' contains the corresponding client IDs for the employee IDs in 'employee_list'
            # print(employee_list)
            for row in reader:
                client_id = row[0].strip()
                client_name = row[1].strip()+','+row[2].strip()
                total_working_hours = row[4].strip()
                no_of_people_on_account = row[3].strip()
                current_month = int(row[5].strip())
                cost = int(row[6].strip())
                current_year = 2026
                import calendar
                input_dt = datetime(current_year, current_month, 13)
                res = calendar.monthrange(input_dt.year, input_dt.month)
                last_day = res[1]
                current_date = date(current_year, current_month, last_day)

                if not total_working_hours:
                    total_working_hours = 0
                if not no_of_people_on_account:
                    no_of_people_on_account = 0

                employee_working = row [index:]
                working_dict = {key: value for key, value in zip(employee_list, employee_working) if value != ''}
                print(working_dict)

                json_data = json.dumps(working_dict)

                client2 = client.objects.get(toggl_client_id=client_id)
                # project_salary = project_id_3.rate
                client_id =client2.id

                if client_id:
                    try:
                        try:
                            start_date = date(current_year, current_month, 1)  # October 1st of the current year
                            end_date = date(current_year, current_month, 28)

                            client_details = Client_contract_work.objects.filter(
                                client_id=client_id,
                                date__range=(start_date, end_date)
                            ).first()
                        except Exception as e:
                            client_details = ''

                        print(current_date)

                        if client_details:
                            # client_details.total_working_hours = total_working_hours
                            client_details.working_input = json_data
                            # client_details.no_of_people_on_account = no_of_people_on_account
                            # client_details.month = current_date
                            client_details.save()
                        else:
                            new_client_details = Client_contract_work(client_id=client_id,total_working_hours=total_working_hours,no_of_people_on_account=no_of_people_on_account, working_role=json_data,cost=cost,date=current_date,status=1)
                            new_client_details.save()
                    except Exception as e:
                        print(e)
        return redirect("employees")

    return render(request, "excel/upload_client_contract_work.html", {})

@csrf_exempt
@login_required(login_url='/')
def upload_attendance(request):

    if request.method == 'POST':
        file = request.FILES.get('emp_file')
        if file:
            reader = csv.reader(file.read().decode('utf-8').splitlines())
            next(reader)
            for row in reader:
               
                employee_id = row[0].strip()
                day = int(row[1].strip())
                in_time = row[2].strip()
                out_time = row[3].strip()
                status = row[4].strip()
                current_month = int(row[5].strip())
                current_year = 2023
                input_dt = datetime(current_year, current_month, 13)
                current_date = date(current_year, current_month, day)
                try:
                    # Condition 1: If ':' in in_time, parse it as a time
                    if ':' in in_time:
                        in_time = datetime.strptime(in_time, '%H:%M:%S').time()
                        # Condition 2: If in_time is a digit, assume it's the hour and format it as a time
                    elif in_time.isdigit():
                        time_object = time(hour=int(in_time))
                        in_time = time_object.strftime("%H:%M:%S")
                        # Condition 3: If none of the above conditions are met, set in_time to None
                    else:
                        in_time = None
                except ValueError as e:
                    print(f"Error parsing in_time: {e}")

                if out_time:
                    try:
                        # Condition 1: If ':' in out_time, parse it as a time
                        if ':' in out_time:
                            out_time = datetime.strptime(out_time, '%H:%M:%S').time()
                            # Condition 2: If out_time is a digit, assume it's the hour and format it as a time
                        elif out_time.isdigit():
                            time_object = time(hour=int(out_time))
                            out_time = time_object.strftime("%H:%M:%S")
                            # Condition 3: If none of the above conditions are met, set out_time to None
                        else:
                            out_time = None
                    except ValueError as e:
                        print(f"Error parsing out_time: {e}")
                else:
                    out_time = None # Set out_time to None if it's not provided

                # from django.http import HttpResponse
                # return HttpResponse(out_time)
                if employee_id:
                    try:
                        try:
                            attendance_details = Attendance.objects.filter(
                                employee_id=employee_id,
                                date=current_date
                            ).first()
                        except Exception as e:
                            attendance_details = ''
                        if attendance_details:
                            attendance_details.date = current_date
                            attendance_details.in_time = in_time
                            attendance_details.out_time = out_time
                            attendance_details.status = status
                            attendance_details.save()
                        else:
                            print(employee_id)
                            print(current_date)
                            print(status)
                            new_attendance_details = Attendance(employee_id=employee_id,date=current_date,in_time=in_time,status=status, out_time=out_time)
                            new_attendance_details.save()
                    except Exception as e:
                        print(e)
        # return redirect("employees")

    return render(request, "excel/upload_attendance.html", {})

@csrf_exempt
@login_required(login_url='/')
def monthly_overview(request):
    active = [''] * 15
    active[7] = 'active'
    

    employees_with_attendance = employee.objects.filter(status=1).order_by('image_url')

    employee_data_list = []

    month = date.today().month
    year = date.today().year
    
    for employee1 in employees_with_attendance:
        employee_data = {
            'id': employee1.id,
            'user_name': employee1.user_name,
            'first_name': employee1.first_name,
            'last_name': employee1.last_name,
            'image_url': employee1.image_url,
            'country_id': employee1.country_id,
            'attendance': [
                {'id': attendance1.id, 'date': attendance1.date, 'status': attendance1.status,
                    'in_time': attendance1.in_time, 'out_time': attendance1.out_time,
                    'notes': attendance1.notes, 'employee_id': attendance1.employee_id
                } for attendance1 in Attendance.objects.annotate(
                   year=ExtractYear('date'),
                   month=ExtractMonth('date')
               ).filter(year=year, month=month, employee_id=employee1.id).all()
            ]
        }
        employee_data_list.append(employee_data)
    
    input_dt = datetime(int(year), int(month), 13)
    res = calendar.monthrange(input_dt.year, input_dt.month)
    last_day = res[1] + 1

    num_days = calendar.monthrange(year, month)[1]
    dates = [datetime(year, month, day) for day in range(1, num_days + 1)]

    # Mark weekends
    employee_holiday = {}
    for emp in employee_data_list:
        dates_with_weekends = [
            {
                'date': date, 
                'is_weekend': date.weekday() in [4,5, 6],
                'is_holiday': Holiday.objects.filter(country_id=emp['country_id'], date=date).exists(),
                'is_leave': leave.objects.filter(employee_id=emp['id'], start_date__lte=date, end_date__gte=date).exists(),
                'is_half_day_leave': leave.objects.filter(employee_id=emp['id'], start_date=date,day_type__gt=1).exists(),
                'half_day_type': leave.objects.filter(employee_id=emp['id'], start_date=date).first().day_type if leave.objects.filter(employee_id=emp['id'], start_date=date,day_type__gt=1).exists() else None
            } for date in dates
        ]

        
        employee_holiday[emp['id']] = dates_with_weekends

    # print(str(year), str(month), '########', dates_with_weekends)
    print(str(year), str(month), '########', employee_holiday)
    context = {'employee_data_list': employee_data_list, 'last_day': last_day, 'numbers': range(1, last_day),
               'dates_with_weekends': dates_with_weekends, 'year': year, 'month': month,
               'employee_holiday': employee_holiday,'active':active}
    return render(request, "employees/admin-attendance.html", context)

@csrf_exempt
@login_required(login_url='/')
def search_attendance(request):
    employee_name = request.GET.get('employee_name')
    month = request.GET.getlist('month')
    year = request.GET.getlist('year')
    print(employee_name)

    import calendar
    from django.db.models import Q
    query = Q()
    if employee_name:
        query = Q(first_name__icontains=employee_name) | Q(last_name__icontains=employee_name)

    employees_with_attendance = employee.objects.filter(query,status=1).order_by('image_url')

    employee_data_list = []

    # month = int(month[0])
    if month[0]:
        month = int(month[0])
    else:
        month = date.today().month
    if year[0]:
        year = int(year[0])
    else:
        year = date.today().year
    from django.db.models.functions import ExtractMonth, ExtractYear
    for employee1 in employees_with_attendance:
        employee_data = {
            'id': employee1.id,
            'user_name': employee1.user_name,
            'first_name': employee1.first_name,
            'last_name': employee1.last_name,
            'image_url': employee1.image_url,
            'country_id': employee1.country_id,
            'attendance': [
                {'id': attendance1.id, 'date': attendance1.date, 'status': attendance1.status,
                    'in_time': attendance1.in_time, 'out_time': attendance1.out_time,
                    'notes': attendance1.notes, 'employee_id': attendance1.employee_id
                } for attendance1 in Attendance.objects.annotate(
                   year=ExtractYear('date'),
                   month=ExtractMonth('date')
               ).filter(year=year, month=month, employee_id=employee1.id).all()
            ]
        }
        employee_data_list.append(employee_data)
    
    input_dt = datetime(int(year), int(month), 13)
    res = calendar.monthrange(input_dt.year, input_dt.month)
    last_day = res[1] + 1

    num_days = calendar.monthrange(year, month)[1]
    dates = [datetime(year, month, day) for day in range(1, num_days + 1)]

    # Mark weekends
    employee_holiday = {}
    for emp in employee_data_list:
        dates_with_weekends = [
            {
                'date': date, 
                'is_weekend': date.weekday() in [4,5, 6],
                'is_holiday': Holiday.objects.filter(country_id=emp['country_id'], date=date).exists(),
                'is_leave': leave.objects.filter(employee_id=emp['id'], start_date__lte=date, end_date__gte=date).exists(),
                'is_half_day_leave': leave.objects.filter(employee_id=emp['id'], start_date=date,day_type__gt=1).exists(),
                'half_day_type': leave.objects.filter(employee_id=emp['id'], start_date=date).first().day_type if leave.objects.filter(employee_id=emp['id'], start_date=date,day_type__gt=1).exists() else None
            } for date in dates
        ]

        
        employee_holiday[emp['id']] = dates_with_weekends
    print(str(year), str(month), '########', employee_holiday)
    context = {'employee_data_list': employee_data_list, 'last_day': last_day, 'numbers': range(1, last_day),
               'dates_with_weekends': dates_with_weekends, 'year': str(year), 'month': str(month),
               'employee_holiday': employee_holiday}
    return render(request, "employees/search_attendance.html", context)

@csrf_exempt
@login_required(login_url='/')
def search_leave(request):
    if request.method == 'GET':
        employee_name = request.GET.get('employee_name')
        leave_type = request.GET.get('leave_type')
        status = request.GET.get('status')
        search_from_date = request.GET.get('search_from_date')
        search_to_date = request.GET.get('search_to_date')
        if search_from_date:
            parsed_date = datetime.strptime(search_from_date, "%Y-%m-%d")
            start_date = parsed_date.strftime("%Y-%m-%d")
        else:
            start_date =None
        if search_to_date:
            parsed_date = datetime.strptime(search_to_date, "%Y-%m-%d")
            end_date = parsed_date.strftime("%Y-%m-%d")
        else:
            end_date = None

        leave_status = status if status else None
        leave_type = leave_type if leave_type else None

        first_name = last_name = employee_name if employee_name else None
        search_term = f"%{employee_name}%" if employee_name else None
        query = """
        SELECT e.id,e.toggl_user_id,e.first_name,e.last_name,e.image_url,e.user_name,lt.name,l.* FROM dec_leave l
        JOIN dec_employee e ON CAST(l.employee_id AS bigint) = e.id
        JOIN dec_leavetype lt ON CAST(l.leave_type_id AS bigint) = lt.id
        WHERE 
        (
            (%s IS NULL OR e.first_name ILIKE %s)
            OR (%s IS NULL OR e.last_name ILIKE %s)
        )
        AND (%s IS NULL OR l.status = %s)
        AND (%s IS NULL OR l.leave_type_id = %s)
        AND (%s IS NULL OR l.start_date >= %s)
        AND (%s IS NULL OR l.end_date <= %s)
        """
        params = [search_term, search_term, search_term, search_term,leave_status, leave_status,leave_type,leave_type, start_date, start_date, end_date, end_date]

        with connection.cursor() as cursor:
            cursor.execute(query, params)
            result_list = cursor.fetchall()

        context = {'result_list': result_list}
        return render(request, "employees/search_leave.html", context)
    else:
        return redirect("leaves")

@csrf_exempt
@login_required(login_url='/')
def add_leave(request):
    if request.method == 'POST':        
        leave_id = request.POST.get('leave_id')
        leave_type = request.POST.get('leave_type')
        reason = request.POST.get('reason')
        day_type = int(request.POST.get('day_type'))
        try:
            if leave_id:
                from_date = request.POST.get('edit_from_date')
                to_date = request.POST.get('edit_to_date')
                existing_leave = leave.objects.get(id=leave_id)

                if day_type != 1:
                    to_date = from_date

                if existing_leave:
                    existing_leave.leave_type_id = leave_type
                    existing_leave.day_type = day_type
                    existing_leave.reason = reason
                    existing_leave.start_date = from_date
                    existing_leave.end_date = to_date
                    existing_leave.status = 'pending'
                    existing_leave.save()
            else:
                from_date = request.POST.get('from_date')
                to_date = request.POST.get('to_date')
                employee_id = request.POST.get('employee_id')

                parsed_date = datetime.strptime(from_date, "%Y-%m-%d")
                from_date = parsed_date.strftime("%Y-%m-%d")
                if to_date:
                    parsed_date2 = datetime.strptime(to_date, "%Y-%m-%d")
                    to_date = parsed_date2.strftime("%Y-%m-%d")
                else:
                    to_date = None
                # print(to_date)
                # from django.http import HttpResponse
                if day_type ==1:
                    difference = parsed_date2 - parsed_date
                    leave_days = difference.days+1
                else:
                    leave_days = .5
                    to_date = from_date
                # return HttpResponse(to_date)

                existing_entry = leave.objects.filter(
                    employee_id=employee_id,
                    start_date=from_date,
                    end_date=to_date
                ).exists()

                if not existing_entry:
                    new_leave = leave.objects.create(
                        employee_id=employee_id,
                        leave_type_id=leave_type,
                        start_date=from_date,
                        end_date=to_date,
                        day_type=day_type,
                        leave_days=leave_days,
                        status='pending',
                        reason=reason
                    )
                    send_leave_approval_email(new_leave)
            # from django.http import HttpResponse
            # return HttpResponse(existing_employee.id)
        except Exception as e:
            print(e)

        # Get the 'next' parameter from the form data
        next_url = request.POST.get('next', 'leaves')  # Default to 'leaves' if 'next' is not present

        if request.user.groups.exists():
            return redirect(next_url)
        else:
            return redirect(next_url)










def update_response(request, buddy_email_id, buddy_id, client_id, response):
    # Get the Buddy_Email record
    print(response, 'RESPONSE')
    buddy_email = get_object_or_404(Buddy_Email, id=buddy_email_id)
    client_ob = client.objects.get(id=client_id)
    emp_ob = employee.objects.get(id=buddy_id)

    # Convert JSONField data into a dictionary
    try:
        client_buddy_record = json.loads(buddy_email.client_buddy_record)  # Ensure it's a dictionary
    except json.JSONDecodeError:
        return HttpResponse("Error: Invalid JSON format in database.", status=400)

    # Check if client_id exists in the dictionary
    if str(client_id) in client_buddy_record:
        if str(buddy_id) in client_buddy_record[str(client_id)]:
            # Get the current response_status
            current_status = client_buddy_record[str(client_id)][str(buddy_id)].get("response_status", "")

            # Check conditions before updating and sending email
            if current_status == "" or (current_status == "yes" and response == "no") or (current_status == "no" and response == "yes"):
                # Update the response_status and response_date
                client_buddy_record[str(client_id)][str(buddy_id)]["response_status"] = response
                client_buddy_record[str(client_id)][str(buddy_id)]["response_date"] = now().strftime(
                    "%Y-%m-%d %H:%M:%S")

                # Save the updated JSON back to the model
                buddy_email.client_buddy_record = json.dumps(client_buddy_record)  # Convert back to JSON string
                buddy_email.save()

                # Get leave user's employee object
                leave_user_emp_ob = employee.objects.get(id=buddy_email.employee_id)

                # Define email content based on response
                consultant_email = "jagrawal@educatedc.com"
                if response == "yes":
                    email_html_body = render_to_string("buddy_response_yes.html", {
                        "buddy_name": emp_ob.first_name,
                        "client_name": client_ob.client_name,
                        "leave_user_name": leave_user_emp_ob.first_name,
                    })
                    email_subject = f"Buddy {emp_ob.first_name} Responded (Accepted)"
                else:
                    email_html_body = render_to_string("buddy_response_no.html", {
                        "buddy_name": emp_ob.first_name,
                        "client_name": client_ob.client_name,
                        "leave_user_name": leave_user_emp_ob.first_name,
                    })
                    email_subject = f"Buddy {emp_ob.first_name} Responded (Not Accepted)"

                # Strip HTML tags for plain text version
                email_plain_body = strip_tags(email_html_body)

                # Send email
                send_mail(
                    email_subject,
                    email_plain_body,
                    "developers@brickwin.com",
                    [consultant_email],
                    fail_silently=False,
                    html_message=email_html_body
                )

                # HTML response
            html_content = """
                    <html>
                    <head>
                        <title>Response Recorded</title>
                        <style>
                            body {
                                background-color: #f6f6f6;
                                font-family: Arial, sans-serif;
                                text-align: center;
                                padding: 50px;
                            }
                            .container {
                                background: #ffffff;
                                padding: 30px;
                                border-radius: 10px;
                                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
                                display: inline-block;
                            }
                            h1 {
                                color: #0061bf;
                                margin-bottom: 15px;
                            }
                            p {
                                color: #333;
                                font-size: 16px;
                                margin-bottom: 20px;
                            }
                            .btn {
                                display: inline-block;
                                padding: 10px 20px;
                                color: #ffffff;
                                background-color: #0061bf;
                                text-decoration: none;
                                border-radius: 5px;
                                font-size: 16px;
                                transition: 0.3s;
                            }
                            .btn:hover {
                                background-color: #004c99;
                            }
                        </style>
                    </head>
                    <body>
                        <div class="container">
                            <h1>Response Recorded</h1>
                            <p>Your response has been successfully recorded, and a confirmation has been sent.</p>
                        </div>
                    </body>
                    </html>
                """
            return HttpResponse(html_content)
        else:
            return HttpResponse("Error: Buddy ID not found under the given Client ID.", status=400)
    else:
        return HttpResponse("Error: Client ID not found.", status=400)





def update_leave_status(request):
    if request.method == 'GET':
        print("search")
        # Retrieve the leave_type from the query parameters
        leave_id = request.GET.get('leave_id', None)
        leave_status = request.GET.get('leave_status', None)
        approved_by_email = request.GET.get('user_email', None)
        s_ajax = request.headers.get('x-requested-with') == 'XMLHttpRequest'
        message = ''
        if leave_id:
            try:
                check_leave = leave.objects.get(id=leave_id)
                # employee_detail = employee.objects.get(user_id=request.user.id)
                try:
                    employee_detail = employee.objects.get(email=approved_by_email)
                    employee_detail_id = employee_detail.id
                except Exception as e:
                    employee_detail_id = 46
                # from django.http import HttpResponse
                # return HttpResponse(check_leave)
                if check_leave:
                    check_leave.status = leave_status
                    check_leave.approved_by = employee_detail_id
                    check_leave.save()
                    status = 1
                    message = "Leave status updated successfully."
            except Exception as e:
                status = 0
                message = "Failed to update leave status."
            # Return the result as JSON
            if s_ajax:
                print('YES AJAX')
                return JsonResponse({'status': status})
            else:
                print('NO AJAX')
                context = {
                    'status': status,
                    'message': message,
                }
                return render(request, 'leave_status_response.html', context)
        else:
            return JsonResponse({'status': 'No leave specified'})
    else:
        # Handle other HTTP methods if needed
        return JsonResponse({'error': 'Invalid request method'})

@login_required(login_url='/')
def get_leave_by_id(request):
    if request.method == 'GET':
        try:
            leave_id = request.GET.get('leave_id')
            leave_detail = leave.objects.get(id=leave_id)


            # START CODE FOR REMAINING LEAVE 20_1_25

            current_year = datetime.now().year
            # Filter leaves for the current year only
            leave_details = leave.objects.filter(
                employee_id=int(leave_detail.employee_id),
                start_date__year=current_year  # Ensure start_date falls in the current year
            ).exclude(
                status='declined'
            )
            total_taken_days = 0
            for leave_detail1 in leave_details:
                start_date = leave_detail1.start_date
                end_date = leave_detail1.end_date
                current_date = start_date
                # Check each day between start and end date
                if leave_detail1.day_type == 1:  # 13_1_25 ASHOK TODAY
                    while current_date <= end_date:
                        if current_date.weekday() < 4:  # Monday to Friday are represented by 0 to 4
                            total_taken_days += 1
                        current_date += timedelta(days=1)  # Move to the next day
                else:
                    total_taken_days += 0.5
            employee_details = employee.objects.get(id=leave_detail.employee_id)
            country_detail = Country.objects.get(id=employee_details.country_id)
            remaining_leave = country_detail.paid_leave - total_taken_days
            print(remaining_leave)
            # END CODE FOR REMAINING LEAVE 20_1_25


            print(leave_id)
            print(leave_detail)
            status = 1
            leave_detail_data = {
                "id": leave_detail.id,
                "employee_id": leave_detail.employee_id,
                "start_date": leave_detail.start_date,
                "end_date": leave_detail.end_date,
                "leave_type_id": leave_detail.leave_type_id,  # replace with actual field names
                "reason": leave_detail.reason,
                "status": leave_detail.status,
                "remaining_leave": remaining_leave,
                # Add other fields as needed
            }
        except Exception as e:
            status = 0

        return JsonResponse({'status': status,"leave_detail": leave_detail_data})

@login_required(login_url='/')
def delete_leave(request):
    if request.method == 'GET':
        leave_id = request.GET.get('leave_id')
        try:
            leave_to_delete = leave.objects.get(id=leave_id)
            leave_to_delete.delete()
            status = 1
            print("Leave deleted successfully.")
        except leave.DoesNotExist:
            status = 0
            print("Leave with the given ID does not exist.")

        return JsonResponse({'status': status})


@login_required(login_url='/')
@csrf_exempt
def calender(request):
    active = [''] * 15
    active[10] = 'active'
    if request.method == 'POST':
        start_date_str = request.POST.get('calender_date')
        print(start_date_str)
        print("muskan")
        dt = datetime.strptime(start_date_str, "%B %d, %Y")
        start_date = dt.strftime("%Y-%m-%d")
        end_date = start_date

        start_time_str = request.POST.get('start_time')
        end_time_str = request.POST.get('end_time')
        client_id = request.POST.get('client_id')

        category_id = request.POST.get('category_id')
        project_id = request.POST.get('project_id')
        description = request.POST.get('description')

        description = description.strip()

        # Convert the string representations to datetime objects
        # start_time_str = datetime.strptime(start_time, "%H:%M")
        start_time_obj = datetime.strptime(start_time_str, "%I:%M %p")
        start_time = start_time_obj.time()
        end_time_obj = datetime.strptime(end_time_str, "%I:%M %p")
        end_time = end_time_obj.time()


        # Ensure end_time is after start_time
        if end_time_obj < start_time_obj:
            end_time_obj += timedelta(days=1)
            end_date = datetime.strptime(end_date, "%Y-%m-%d") #ADDED 20TH FEB 2026
            end_date += timedelta(days=1)
            end_date = end_date.strftime("%Y-%m-%d")

        # Calculate the time difference in seconds
        time_difference_seconds = (end_time_obj - start_time_obj).seconds

        if category_id == 'other':
            other_category = request.POST.get('other_category')
            print(other_category)

            # Check if other_category already exists
            existing_category = Work_Category.objects.filter(category__iexact=other_category).first()

            if existing_category:
                # Use the existing category
                category_id = existing_category.id
                print("Existing Category ID:", category_id)
            else:
                # Create a new Work_Category instance
                if len(other_category) > 0:
                    new_category_instance = Work_Category(category=other_category)
                    new_category_instance.save()

                    # Get the ID of the newly created instance
                    category_id = new_category_instance.id
                    print("New Category ID:", category_id)
                else:
                    return JsonResponse({"error": "Please Fill Work Category"}, status=400,safe=False)



       
        group = None

        if request.user.groups.exists():
            group = request.user.groups.all()
            print("exist group")
            print(group)

            if group[0].name == 'admin' or group[0].name == 'super_admin' or group[0].name == 'super_user':
                print("admin")
                employee_id = request.session.get('user_id')


        else:
            employee_id= request.session.get('user_id')



        print("Employee id:",employee_id)
        print("Client ID:", client_id)
        print("Category ID:", category_id)
        print("Project ID:", project_id)
        print("Description:", description)
        print("Time Seconds:", time_difference_seconds)
        print("Start Date:", start_date)
        print("End Date:", end_date)
        print("Start Time:", start_time)
        print("End Time:", end_time)
        # return HttpResponse(end_time)
        # Create a new timeSheet entry
        employee_ob = employee.objects.get(id=employee_id)
        try:
            # country_city = request.session['employee_timezone']
            # country_city = employee_ob.timezone
            country_city = employee_ob.manual_timezone
            if len(country_city) == 0:
                employee_country = Country.objects.get(id=employee_ob.country_id)
                if employee_country.code == 'US':
                    country_city = 'America/New_York'
                elif employee_country.code == 'SA':
                    country_city = 'Africa/Johannesburg'
                elif employee_country.code == 'UK':
                    country_city = 'Europe/London'
                elif employee_country.code == 'PH':
                    country_city = 'Asia/Manila'
                else:
                    country_city = 'America/New_York'
        except Exception as e:
            employee_country = Country.objects.get(id=employee_ob.country_id)
            if employee_country.code == 'US':
                country_city = 'America/New_York'
            elif employee_country.code == 'SA':
                country_city = 'Africa/Johannesburg'
            elif employee_country.code == 'UK':
                country_city = 'Europe/London'
            elif employee_country.code == 'PH':
                country_city = 'Asia/Manila'
            else:
                country_city = 'America/New_York'


    
        print(country_city)
        local_tz = pytz.timezone(country_city)  # Replace with your local timezone
        start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date, '%Y-%m-%d').date()

        # Combine date and time
        local_start_dt = datetime.combine(start_date, start_time)
        local_start_dt = local_tz.localize(local_start_dt)  # Make it timezone-aware
        # Convert to UTC
        start_date = local_start_dt.astimezone(pytz.utc)
        # Combine date and time
        local_end_dt = datetime.combine(end_date, end_time)
        local_end_dt = local_tz.localize(local_end_dt)  # Make it timezone-aware
        # Convert to UTC
        end_date = local_end_dt.astimezone(pytz.utc)
        print(start_date, '###########################', end_date)
        start_time = start_date.time()
        end_time = end_date.time()

        client_id = int(client_id)
        category_id = category_id

        # Create a new timeSheet entry
        if len(project_id) > 0:
            new_entry = timeSheet(
                employee_id=employee_id,
                client_id=client_id,
                category_id=category_id,
                project_id=int(project_id),
                description=description,
                time_entries_seconds=time_difference_seconds,  # assuming 1 hour in seconds
                time_entries_start_date=start_date,
                time_entries_stop_date=end_date,
                time_entries_start_time=start_time,
                time_entries_stop_time=end_time,
            )

            # Save the entry to the database
            new_entry.save()
        else:
            new_entry = timeSheet(
                employee_id=employee_id,
                client_id=client_id,
                category_id=category_id,
                description=description,
                time_entries_seconds=time_difference_seconds,  # assuming 1 hour in seconds
                time_entries_start_date=start_date,
                time_entries_stop_date=end_date,
                time_entries_start_time=start_time,
                time_entries_stop_time=end_time,
            )
            # Save the entry to the database
            new_entry.save()

        employee_ob = employee.objects.get(id=employee_id)

   
        print(country_city)


        start_datetime = datetime.combine(new_entry.time_entries_start_date, new_entry.time_entries_start_time)
        end_datetime = datetime.combine(new_entry.time_entries_stop_date, new_entry.time_entries_stop_time)

        start_datetime_utc = start_datetime.replace(tzinfo=pytz.utc)
        end_datetime_utc = end_datetime.replace(tzinfo=pytz.utc)
        # Create a timezone object for US Eastern Time (ET)
        local_tz = pytz.timezone(country_city)
        # Convert the datetime to US Eastern Time
        start_datetime = start_datetime_utc.astimezone(local_tz)
        end_datetime = end_datetime_utc.astimezone(local_tz)

        # Format start_datetime in ISO 8601 format with 'Z'
        start_formatted = start_datetime.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
        end_formatted = end_datetime.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'

        print("muskan ")
        print(new_entry.client_id)
        print(start_formatted)
        print(new_entry.description)
        print(end_formatted)
        try:
            client_name = client.objects.get(id=new_entry.client_id)
            client_name = client_name.company_name + ', ' + client_name.client_name  #client_name.toggl_client_name
            print(client_name)
        except Exception as e:
            client_name = ''

        category_name = Work_Category.objects.get(id=new_entry.category_id)
        category_name = category_name.category
        print(client_name, '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$', category_name,project_id,type(project_id))
        events = {
            'title': client_name,
            'start': start_formatted,
            'end': end_formatted,
            'className': 'border-0 bg-primary text-white ff-heading fs-18 fw-semibold',
            'categoryName': category_name,
            'clientId': new_entry.client_id,
            'categoryId': new_entry.category_id,
            'description': new_entry.description,
            'eventId': new_entry.id,
            'color':'#303030',
            'projectId': new_entry.project_id,
        }
        print(events, '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')
        return JsonResponse(events, safe=False)


    # projects = project.objects.all()
    clients = client.objects.exclude(id=227)
    # category = Work_Category.objects.exclude(id=23)
    category = Work_Category.objects.exclude(id=23).order_by('category')
    employee_id = request.session.get('user_id')
    print(clients, '##############################################################')
    print(category)

    # START CODE FOR FREQUENTLY USED EVENTS
    # Get the date 5 months ago

    from django.db.models import Count
    # Get the date 5 months ago
    five_months_ago = now().date() - timedelta(days=3 * 30)

    # Filter timesheets from the last 5 months
    timesheets = timeSheet.objects.filter(time_entries_start_date__gte=five_months_ago,employee_id = int(employee_id))

    # Get the top 3 most frequently used client_id
    top_clients = (
        timesheets.values("client_id").exclude(client_id = 227)
        .annotate(client_count=Count("id"))
        .order_by("-client_count")[:5]
    )

    # Extract client IDs
    top_client_ids = [client1["client_id"] for client1 in top_clients]

    # START FREQUENT USED WHERE EMP ID IS C on CLIENT
    # employee_id = 46
    try:
        emp_client_with_c = get_clients_with_role_c(employee_id)
        emp_client_with_a = get_clients_with_role_a(employee_id)
        emp_client_with_b = get_clients_with_role_b(employee_id)
        if emp_client_with_c:
    
    
            # Extract client_id list
            top_clients_first = list(clients.filter(id__in=emp_client_with_c))  # Top 5 first
            top_clients_second = list(clients.filter(id__in=emp_client_with_a))  # Top 5 first
            top_clients_third = list(clients.filter(id__in=emp_client_with_b))  # Top 5 first
            top_clients_all = emp_client_with_c + emp_client_with_a + emp_client_with_b
            remaining_clients = list(clients.exclude(id__in=top_clients_all))  # Others after
            print(top_clients_first, top_clients_second, top_clients_third, top_clients_all, "TOP ALL C")
            # Step 4: Combine the two lists without duplicates
            clients = top_clients_first + top_clients_second + top_clients_third + remaining_clients
    except Exception as e:
        print(e)
    # End code FREQUENT USED WHERE EMP ID IS C on CLIENT


    # Get the most used category_id for each of the top clients
    client_category_map = {}

    for client_id in top_client_ids:
        # Find the most used category for this client
        if client_id == 227:
            continue
        top_category = (
            timesheets.filter(client_id=client_id)
            .values("category_id")
            .annotate(category_count=Count("id"))
            .order_by("-category_count")
            .first()
        )
        if top_category:
            # client_category_map[client_id] = top_category["category_id"]

            client_name_ob = client.objects.get(id=client_id)
            category_name_ob = Work_Category.objects.get(id=top_category["category_id"])

            if client_name_ob and category_name_ob:
                client_category_map[client_id] = {
                    "client_name": client_name_ob.client_name,
                    "category_id": top_category["category_id"],
                    "category_name": category_name_ob.category,
                }
    print("DEBUG: Client-Category Map ->", client_category_map)  # Debugging


    context = {
        'clients': clients,
        'categorys': category,
        'active': active,
        'employee_id': employee_id,
        'client_category_map':client_category_map
    }
    return render(request, "calender2.html", context)



@login_required(login_url='/')
def calendar(request):
    if request.method == 'POST':
        # Get the values submitted in the form
        start_date_str = request.POST.get('start_date')
        end_date_str = request.POST.get('end_date')

        # Process the values (convert to datetime or perform any other necessary actions)
        # Process the values (convert to datetime or perform any other necessary actions)
        start_date = datetime.strptime(start_date_str, '%d-%b-%Y').strftime('%Y-%m-%d')
        end_date = datetime.strptime(end_date_str, '%d-%b-%Y').strftime('%Y-%m-%d')

        start_time = request.POST.get('start_time')
        end_time = request.POST.get('end_time')
        project_id = request.POST.get('project_id')
        description = request.POST.get('description')

        description = description.strip()

        # Convert the string representations to datetime objects
        start_time_str = datetime.strptime(start_time, "%H:%M")
        end_time_str = datetime.strptime(end_time, "%H:%M")

        # Calculate the time difference in seconds
        time_difference_seconds = (end_time_str - start_time_str).seconds

        # print(f"The user worked for {time_difference_seconds} seconds.")

        print("Start Date:", start_date)
        print("End Date:", end_date)
        print("Start Time:", start_time)
        print("End Time:", end_time)
        print("Project ID:", project_id)
        print("Description:", description)
        print("Time Seconds:", time_difference_seconds)

        group = None

        if request.user.groups.exists():
            group = request.user.groups.all()
            print("exist group")
            print(group)

            if group[0].name == 'admin' or group[0].name == 'super_admin'  or group[0].name == 'super_user':
                print("admin")
                user_name = request.session.get('admin')
        else:
            user_name = request.session.get('user_name')

        employee1 = employee.objects.get(user_name=user_name)
        user_id = employee1.toggl_user_id
        if user_id is None:
            # Insert NULL into the database
            user_id = None
        employee_id = employee1.id
        print(user_id)

        print("Employee id:",employee_id)
        print("User Id:",user_id)
        print("User name:", user_name)
        print("Project ID:", project_id)
        print("Description:", description)
        print("Time Seconds:", time_difference_seconds)
        print("Start Date:", start_date)
        print("End Date:", end_date)
        print("Start Time:", start_time)
        print("End Time:", end_time)

        # Create a new timeSheet entry
        new_entry = timeSheet(
            employee_id=employee_id,
            user_id=user_id,
            user_name=user_name,
            project_id=project_id,
            description=description,
            time_entries_seconds=time_difference_seconds,  # assuming 1 hour in seconds
            time_entries_start_date=start_date,
            time_entries_stop_date=end_date,
            time_entries_start_time=start_time,
            time_entries_stop_time=end_time,
        )

        # Save the entry to the database
        new_entry.save()


    projects = project.objects.all()
    clients = client.objects.all()

    return render(request, "calender.html",{'projects': projects,'clients':clients})





@csrf_exempt  # Disable CSRF for testing in Postman
def get_client_id_api(request):
    if request.method == "POST":
        try:
            # Load request body
            data = json.loads(request.body.decode("utf-8"))
            ev_summary = data.get("ev_summary", "")
            employee_id = data.get("employee_id", None)

            if not ev_summary or not employee_id:
                return JsonResponse({"error": "ev_summary and employee_id are required"}, status=400)

            # Normalize input summary
            print(ev_summary)
            ev_summary = re.sub(r"'s\b", "", ev_summary)  # Remove "'s" at word boundaries
            ev_summary = re.sub(r'[^a-zA-Z\s]', '', ev_summary)
            ev_summary = ev_summary.lower().strip()
            ev_words = set(ev_summary.split())

            # Retrieve all clients
            clients = client.objects.all()

            # Find matching client names
            matched_clients = {}
            clients_dict = set()
            for c in clients:
                client_words = set(c.client_name.lower().split())
                clients_dict.update(client_words)
                if ev_words & client_words:  # Check if there's a word match
                    matched_clients[c.client_name] = c.id

            client_name_set = ev_words & clients_dict
            print(client_name_set, 'ONLY NAMES')

            if not matched_clients:
                return JsonResponse({"client_id": None}, status=200)

            # Get timesheets from the last 5 months
            five_months_ago = now().date() - timedelta(days=3 * 30)
            timesheets = timeSheet.objects.filter(
                time_entries_start_date__gte=five_months_ago,
                employee_id=employee_id
            )

            # Get most frequently used client_id
            top_clients = (
                timesheets.values("client_id").exclude(client_id=227)
                    .annotate(client_count=Count("id"))
                    .order_by("-client_count")
            )
            top_client_ids = [client1["client_id"] for client1 in top_clients]
            print(matched_clients, top_clients)

            matched_client_ids = []
            for name in client_name_set:
                for c in clients:
                    if name.lower() in c.client_name.lower().split():
                        matched_client_ids.append(c.id)

            print("Matched Client IDs:", matched_client_ids)

            if matched_client_ids:
                most_common_id = Counter(matched_client_ids).most_common(1)[0][0]
                return JsonResponse({"client_id": most_common_id}, status=200)

            for client_name, client_id in matched_clients.items():
                if client_id in top_client_ids:
                    return JsonResponse({"client_id": client_id}, status=200)

            return JsonResponse({"client_id": list(matched_clients.values())[0]}, status=200)

        except Exception as e:
            return JsonResponse({"error": str(e)}, status=500)

    return JsonResponse({"error": "Invalid request method"}, status=405)


def get_client_id(ev_summary, employee_id):
    # Normalize input summary and split into words
    print(ev_summary)
    ev_summary = re.sub(r"'s\b", "", ev_summary)  # Remove "'s" at word boundaries
    ev_summary = re.sub(r'[^a-zA-Z\s]', '', ev_summary)
    ev_summary = ev_summary.lower().strip()
    ev_words = set(ev_summary.lower().split())

    # Retrieve all clients
    clients = client.objects.all()

    # Find matching client names
    matched_clients = {}
    clients_dict = set()
    for c in clients:
        client_words = set(c.client_name.lower().split())
        # print('CLIENT ERROR')
        clients_dict.update(c.client_name.lower().split())
        # print(ev_words, client_words, 'EV CLIENT')
        if ev_words & client_words:  # Check if there's a word match
            matched_clients[c.client_name] = c.id
    # clients_dict = {c.client_name.lower() for c in client.objects.all()}
    # Print the complete dictionary once (for debugging)
    # print(clients_dict, "ALL CLIENTS")
    client_name_set = ev_words & clients_dict
    print(client_name_set, 'ONLY NAMES')
    if not matched_clients:
        return 227  # No matching client found

    # Get timesheets from the last 5 months
    five_months_ago = now().date() - timedelta(days=3 * 30)
    timesheets = timeSheet.objects.filter(
        time_entries_start_date__gte=five_months_ago,
        employee_id=employee_id
    )

    # Get most frequently used client_id
    top_clients = (
        timesheets.values("client_id").exclude(client_id=227)
            .annotate(client_count=Count("id"))
            .order_by("-client_count")
    )

    top_client_ids = [client1["client_id"] for client1 in top_clients]
    print(matched_clients, top_clients)

    matched_client_ids = []
    # Step 3: Iterate over each name in client_name_set
    for name in client_name_set:
        for c in clients:
            # Check if the current client_name contains the matching word
            if name.lower() in c.client_name.lower().split():
                matched_client_ids.append(c.id)  # Store client_id

    print("Matched Client IDs:", matched_client_ids)

    # Step 4: Find the most frequently occurring client_id
    if matched_client_ids:
        print(Counter(matched_client_ids), 'MOST COMMON')
        most_common_id = Counter(matched_client_ids).most_common(1)[0][0]
        return most_common_id

    # Return the most frequently used client_id from matched clients
    for client_name, client_id in matched_clients.items():
        if client_id in top_client_ids:
            return client_id

    # If no top client is found, return the first match
    return list(matched_clients.values())[0]



@login_required(login_url='/')
def calender_events(request):
    group = None
    if request.user.groups.exists():
        group = request.user.groups.all()
        print("exist group")
        print(group)

        if group[0].name == 'super_admin' or group[0].name == 'super_user':
            print("super admin")
            employee_id = request.session.get('user_id')
        else:
            employee_id = request.session.get('user_id')
    else:
        employee_id = request.session.get('user_id')
    # print(employee_id, '%%%%%%%%%%%%%%%%55')
    # Fetch timeSheet data

    emp_ob = employee.objects.get(id=int(employee_id))

    try:
        # country_city = request.session['employee_timezone']
        # country_city = emp_ob.timezone
        country_city = emp_ob.manual_timezone
        if len(country_city) == 0:
            employee_country = Country.objects.get(id=emp_ob.country_id)
            if employee_country.code == 'US':
                country_city = 'America/New_York'
            elif employee_country.code == 'SA':
                country_city = 'Africa/Johannesburg'
            elif employee_country.code == 'UK':
                country_city = 'Europe/London'
            elif employee_country.code == 'PH':
                country_city = 'Asia/Manila'
            else:
                country_city = 'America/New_York'
    except Exception as e:
        employee_country = Country.objects.get(id=emp_ob.country_id)
        if employee_country.code == 'US':
            country_city = 'America/New_York'
        elif employee_country.code == 'SA':
            country_city = 'Africa/Johannesburg'
        elif employee_country.code == 'UK':
            country_city = 'Europe/London'
        elif employee_country.code == 'PH':
            country_city = 'Asia/Manila'
        else:
            country_city = 'America/New_York'



    print(emp_ob.calender_status, 'KKK1111122222222')
    if emp_ob.calender_status == 0:
        time_entries = timeSheet.objects.filter(employee_id=employee_id).exclude(is_google=1)
        print(time_entries, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa', len(time_entries))
    else:
        # time_entries = timeSheet.objects.filter(employee_id=employee_id)
        # print(time_entries, 'AAAAAAA', len(time_entries))
        global CLIENT_SECRETS_FILE
        # Check if there are already stored credentials in the session
        employee_ob = employee.objects.get(id=int(employee_id))
        print(employee_ob.token, 'ASHOK')

        if employee_ob.token:
            google_credentials = json.loads(employee_ob.token)
            creds = Credentials.from_authorized_user_info(google_credentials, SCOPES)
            # if creds.expired and creds.refresh_token:
            # return JsonResponse({'status':False}, safe=False)

            # else:
            #     return get_authenticated_service(request)
            service = build('calendar', 'v3', credentials=creds)
            current_time = datetime.utcnow().isoformat() + 'Z'

            # start_date_time = datetime.utcnow() - timedelta(days=36)
            start_date_time = datetime(2024, 12, 31)

            try:
                has_google_entries = timeSheet.objects.filter(
                employee_id=employee_id,
                is_google=1,
                ).exists()

                if has_google_entries:
                    start_date_time = datetime.utcnow() - timedelta(days=30)
                else:
                    start_date_time = datetime(2024, 12, 31)
            except Exception as e:
                print(e,'HAS GOOGLE ENTRY ERROR')
                start_date_time = datetime(2024, 12, 31)


            end_date_time = datetime.utcnow() + timedelta(days=30)
            # Convert start_date to RFC3339 format (required by Google Calendar API)
            start_date_time = start_date_time.isoformat() + 'Z'
            end_date_time = end_date_time.isoformat() + 'Z'

            # START CALENDAR DATA SAVED 20_1_25
            try:
                events_result = service.events().list(calendarId='primary', timeMin=start_date_time,
                                                  timeMax=current_time,singleEvents=True,orderBy="startTime").execute()
            except Exception as e:
                emp_ob = employee.objects.get(id=int(employee_id))
                if emp_ob.token:
                    google_credentials = json.loads(emp_ob.token)
                    revoke_access_token(google_credentials['refresh_token'])
                    emp_ob.token = None
                    emp_ob.calender_status = 0
                    emp_ob.auth_gmail = None
                    emp_ob.save()
                return JsonResponse({'status': False}, safe=False)
            # events_result = (
            #     service.events()
            #         .list(
            #         calendarId="primary",
            #         timeMin=now,
            #         maxResults=10,
            #         singleEvents=True,
            #         orderBy="startTime",
            #     ).execute()
            # )
            events = events_result.get('items', [])

            # Display events or handle them as needed
            if not events:
                return HttpResponse('No events found.')
            else:
                for ev in events:
                    try:
                        calender_eid = ev['htmlLink']
                        existing_entry = timeSheet.objects.filter(
                            employee_id=employee_id,
                            calender_eid=calender_eid
                        ).first()
                        if existing_entry:
                            print('THIS ENTRY ALREADY EXIST')
                            continue
                    except Exception as e:
                        print('EXISTING ENTRY CHECK ERROR')

                    attendees = ev.get('attendees', [])
                    # # Skip the event if any attendee has a 'declined' status
                    # if any(attendee.get('responseStatus') == 'declined' for attendee in attendees):
                    #     continue  # Skip this event
                    if any(attendee.get('self') and attendee.get('responseStatus') == 'declined' for attendee in attendees):
                        # continue  # Skip this event
                        status = 'declined'
                    else:
                        status = None

                    event_type = ev.get('eventType', 'default')
                    # Skip specific event types
                    if event_type in ['outOfOffice', 'focusTime', 'workingLocation']:
                        continue

                    title = ev.get('summary', 'No Title')
                    if title.lower() in ['ooo','out of office']:
                        continue

                    if "ooo" in title.lower():
                        continue
                    title_lower = title.lower()
                    title_lower = title_lower.split()
                    print(title_lower,'TEST')
                    if "al" in title_lower or "holiday" in title_lower or "ooo" in title_lower:  # Checks for exact "AL"
                        continue

                    # else:
                    #     class_name = 'border-0 bg-secondary text-white ff-heading fs-18 fw-semibold'

                    try:
                        # client_name_expected = ev['summary'].split()
                        #
                        # client_name_expected = "|".join(
                        #     map(re.escape, client_name_expected))  # Creates a regex pattern like "Vlad|Call|Discuss"
                        # clients = client.objects.filter(client_name__iexact=ev['summary']).first()
                        # client_id = clients.id
                        # category_id = 23
                        ev_summary = ev['summary']
                        client_id = get_client_id(ev_summary, employee_id)
                        print(client_id)
                        if not client_id:
                            client_id = 227
                        if client_id == '':
                            client_id = 227
                        category_id = 23
                    except Exception as e:
                        print(e, 'Name Error')
                        client_id = 227
                        category_id = 23
                    print("Employee id:", employee_id)
                    print("Client ID:", client_id)
                    print("Category ID:", category_id)
                    # print("Category ID:", events)
                    try:
                        # gmail = ev['creator']['email']
                        calender_eid = ev['htmlLink']
                        print("Description:", ev['summary'])
                        # print("Time Seconds:", time_difference_seconds)
                        start_date = ev['start']['dateTime']
                        end_date = ev['end']['dateTime']
                        print("Start Date:", ev['start']['dateTime'])
                        print("End Date:", ev['end']['dateTime'])


                        try:
                            dt_obj1 = datetime.fromisoformat(start_date)
                            # Extract date and time components
                            start_date = dt_obj1.date()
                            start_time = dt_obj1.time()
                            dt_obj2 = datetime.fromisoformat(end_date)
                            # Extract date and time components
                            end_date = dt_obj2.date()
                            end_time = dt_obj2.time()
                        except Exception as e:
                            start_date = ev['start'].get('dateTime', ev['start'].get('date'))
                            end_date = ev['end'].get('dateTime', ev['end'].get('date'))

                            print("Start Date:", start_date)
                            print("End Date:", end_date)

                            # Convert 'Z' format to compatible format
                            if start_date.endswith("Z"):
                                start_date = start_date.replace("Z", "+00:00")
                            if end_date.endswith("Z"):
                                end_date = end_date.replace("Z", "+00:00")

                            # Convert string to datetime
                            dt_obj1 = datetime.fromisoformat(start_date)
                            dt_obj2 = datetime.fromisoformat(end_date)
                            start_date = dt_obj1.date()
                            start_time = dt_obj1.time()
                            end_date = dt_obj2.date()
                            end_time = dt_obj2.time()

                        print(end_date, end_time, "End Date:", start_date, start_time)

                        employee_ob = employee.objects.get(id=employee_id)
    
                        print(country_city)

                        #GET TIMEZONE FROM GOOGLE AND CONVERT IT INTO UTC
                        calender_id = emp_ob.auth_gmail
                        calendar_info_timezone = service.calendars().get(calendarId=calender_id).execute()
                        print(calendar_info_timezone.get("timeZone"),'EMPLOYEE TIMEZONE')
                        country_city_timezone = calendar_info_timezone.get("timeZone")

                        local_tz = pytz.timezone(country_city_timezone)  # Replace with your local timezone
                        # Combine date and time
                        local_start_dt = datetime.combine(start_date, start_time)
                        local_start_dt = local_tz.localize(local_start_dt)  # Make it timezone-aware
                        # Convert to UTC
                        start_date = local_start_dt.astimezone(pytz.utc)
                        # Combine date and time
                        local_end_dt = datetime.combine(end_date, end_time)
                        local_end_dt = local_tz.localize(local_end_dt)  # Make it timezone-aware
                        # Convert to UTC
                        end_date = local_end_dt.astimezone(pytz.utc)
                        print(start_date, '###########################', end_date)
                        start_time = start_date.time()
                        end_time = end_date.time()
                        print(start_time, '###########################', end_time)

                        sd = datetime.strptime(f"{start_date.date()} {start_time}", "%Y-%m-%d %H:%M:%S")
                        ed = datetime.strptime(f"{end_date.date()} {end_time}", "%Y-%m-%d %H:%M:%S")

                        # Calculate time difference
                        time_difference = ed - sd

                        # Convert time difference to seconds
                        time_difference_seconds = time_difference.total_seconds()
                        # Create a new timeSheet entry
                        print(time_difference, 'PRAKASH2')


                        try:
                            visibility = ev.get('visibility', 'public')
                            if visibility == 'private':
                                title = 'Busy'
                        except Exception as e:
                            pass




                    
                        obj, created = timeSheet.objects.get_or_create(
                            employee_id=employee_id,
                            calender_eid=calender_eid,
                            defaults={
                                'client_id': client_id,
                                'category_id': category_id,
                                'description': title,
                                'time_entries_seconds': time_difference_seconds,
                                'time_entries_start_date': start_date,
                                'time_entries_stop_date': end_date,
                                'time_entries_start_time': start_time,
                                'time_entries_stop_time': end_time,
                                'is_google': 1,
                                'gmail': emp_ob.auth_gmail,
                                'status': status
                            }
                        )

                        print('GOOGLE CALENDAR DATA SAVED')
                    except Exception as e:
                        pass
                # END CALENDAR DATA SAVED 20_1_25
        # time_entries = timeSheet.objects.filter(employee_id=employee_id,gmail=employee_ob.auth_gmail)
        # time_entries = timeSheet.objects.filter(Q(employee_id=employee_id) & (Q(gmail=employee_ob.auth_gmail) | Q(gmail=None)))
        time_entries = timeSheet.objects.filter(
            Q(employee_id=employee_id) &
            (Q(gmail=employee_ob.auth_gmail) | (Q(gmail=None) & Q(is_google=0)))
        )

    employee_ob = employee.objects.get(id=employee_id)

    events = []

    current_time_utc = datetime.utcnow().replace(tzinfo=pytz.utc)
    # Convert UTC to the country-specific timezone
    current_local_tz = pytz.timezone(country_city)
    current_time_local = current_time_utc.astimezone(current_local_tz)

    for entry in time_entries:
        if entry.status == 'declined':
            print(entry.status)
            # continue

        start_datetime = datetime.combine(entry.time_entries_start_date, entry.time_entries_start_time)
        end_datetime = datetime.combine(entry.time_entries_stop_date, entry.time_entries_stop_time)

        start_datetime_utc = start_datetime.replace(tzinfo=pytz.utc)
        end_datetime_utc = end_datetime.replace(tzinfo=pytz.utc)
        # Create a timezone object for US Eastern Time (ET)
        local_tz = pytz.timezone(country_city)
        # Convert the datetime to US Eastern Time
        start_datetime = start_datetime_utc.astimezone(local_tz)
        end_datetime = end_datetime_utc.astimezone(local_tz)

        # Format start_datetime in ISO 8601 format with 'Z'
        start_formatted = start_datetime.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
        end_formatted = end_datetime.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'

        # print("muskan ", entry.time_entries_start_date)
        # print(entry.client_id)
        print(start_formatted, 'kkkkkkkkkkkkk')
        # print(entry.description)
        # print(end_formatted)
        try:
            client_name = client.objects.get(id=entry.client_id)
            client_name = client_name.company_name + ', ' + client_name.client_name #client_name.toggl_client_name
            # print(client_name)
        except Exception as e:
            client_name = ''
        try:
            category_name = Work_Category.objects.get(id=entry.category_id)
            category_name = category_name.category
        except Exception as e:
            category_name = ''
        # print(client_name, '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$', category_name)
        class_name = 'border-0 bg-primary text-white ff-heading fs-18 fw-semibold'
        calender_eid = '#'

        if start_datetime > current_time_local:
            # class_name = 'border-0 bg-warning text-white ff-heading fs-18 fw-semibold'  # Light orange background
            class_name = 'border-0 bg-light_dark text-white ff-heading fs-18 fw-semibold'

        if entry.project_id:
            project_id = entry.project_id
            class_name = 'border-0 bg-danger_dark text-white ff-heading fs-18 fw-semibold'
            if start_datetime > current_time_local:
                class_name = 'border-0 bg-danger_light text-white ff-heading fs-18 fw-semibold'

        else:
            project_id = None

        if entry.is_google == 1:
            client_name = entry.description
            class_name = 'border-0 bg-success text-white ff-heading fs-18 fw-semibold'
            calender_eid = entry.calender_eid
            print(calender_eid, 'LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL')
            if entry.status == 'declined':
                class_name = 'border-0 bg-grey text-dark ff-heading fs-18 fw-semibold declined-event'

        events.append({
            'title': client_name,
            'start': start_formatted,
            'end': end_formatted,
            # 'className': 'border-0 bg-primary text-white ff-heading fs-18 fw-semibold',
            'className': class_name,
            'categoryName': category_name,
            'clientId': entry.client_id,
            'categoryId': entry.category_id,
            'description': entry.description,
            'eventId': entry.id,
            'calenderEid': calender_eid,
            'projectId':project_id,
            'eventTimeframe':'past_event',
            'eventStatus':entry.status,
            'city':country_city
        })
    if employee_ob.token and employee_ob.calender_status == 1:

        try:
            # Fetch calendar events
            try:
                events_result = service.events().list(
                    calendarId='primary',
                    # timeMin=start_date_time,
                    timeMin=current_time,
                    singleEvents=True,
                    orderBy='startTime'
                ).execute()
            except Exception as e:
                emp_ob = employee.objects.get(id=int(employee_id))
                if emp_ob.token:
                    google_credentials = json.loads(emp_ob.token)
                    revoke_access_token(google_credentials['refresh_token'])
                    emp_ob.token = None
                    emp_ob.calender_status = 0
                    emp_ob.auth_gmail = None
                    emp_ob.save()
                return JsonResponse({'status': False}, safe=False)

            events_data = events_result.get('items', [])
            print(events_data, 'APPOINTMENT')
            for ev in events_data:
                try:
                    print("Start Date:", ev['start']['dateTime']) #THIS PRINT IS IMPORTANT FOR SKIP EVENT WHEN DATETIME NOT FOUND
                    print("End Date:", ev['end']['dateTime'])
                    start_date = ev['start'].get('dateTime', ev['start'].get('date'))
                    end_date = ev['end'].get('dateTime', ev['end'].get('date'))

                    # START LOCAL TZ
                    try:
                        print(start_date, end_date, 'UPCOMING EVENT TIME')
                        # Convert string to datetime object
                        start_date = datetime.fromisoformat(start_date)
                        # Convert to UTC
                        # start_date_utc_time = start_date.astimezone(pytz.utc)
                        # Convert to New York Time (Eastern Time)
                        start_date_local_tz = pytz.timezone(country_city)
                        start_date_local_tz = start_date.astimezone(start_date_local_tz)
                        # Format in required format
                        start_date = start_date_local_tz.strftime("%Y-%m-%dT%H:%M:%S.000Z")
    
                        end_date = datetime.fromisoformat(end_date)
                        # Convert to UTC
                        # end_date_utc_time = end_date.astimezone(pytz.utc)
                        # Convert to New York Time (Eastern Time)
                        end_date_local_tz = pytz.timezone(country_city)
                        end_date_local_tz = end_date.astimezone(end_date_local_tz)
                        # Format in required format
                        end_date = end_date_local_tz.strftime("%Y-%m-%dT%H:%M:%S.000Z")
                        print(start_date, end_date, 'UPCOMING EVENT TIME CHANGED')
                    except Exception as e:
                        print(e,'FUTURE ENTRY TIME ERROR')
                        
                    # END LOCAL TZ

                    try:
                        running_event = timeSheet.objects.get(employee_id=int(employee_id),
                                                              calender_eid=ev.get('htmlLink', ''))
                        if running_event:
                            continue
                    except Exception as e:
                        print(e, 'EVENT NOT GET')


                    title = ev.get('summary', 'No Title')
                    category_name = 'Google Calendar'
                    client_id = 227
                    category_id = 23

                    # Detect event type for customization
                    event_type = ev.get('eventType', 'default')

                    if title.lower() in ['ooo','out of office']:
                        continue

                    # if "ooo" in title.lower():
                    #     continue

                    title_lower = title.lower()
                    title_lower = title_lower.split()
                    print(title_lower, 'TEST')
                    if "al" in title_lower or "holiday" in title_lower or "ooo" in title_lower:  # Checks for exact "AL"
                        continue

                    attendees = ev.get('attendees', [])
                    # Skip the event if any attendee has a 'declined' status
                    if any(attendee.get('self') and attendee.get('responseStatus') == 'declined' for attendee in attendees):
                        continue  # Skip this event

                    if event_type in ['outOfOffice', 'focusTime', 'workingLocation']:
                        continue
                    else:
                        class_name = 'border-0 bg-info text-white ff-heading fs-18 fw-semibold'

                    try:
                        visibility = ev.get('visibility', 'public')
                        if visibility == 'private':
                            title = 'Busy'
                    except Exception as e:
                        pass


                    # Append event
                    events.append({
                        'title': title,
                        'start': start_date,
                        'end': end_date,
                        'className': class_name,
                        'categoryName': category_name,
                        'clientId': client_id,
                        'categoryId': category_id,
                        'description': title,
                        'calenderEid': ev.get('htmlLink', ''),
                        'eventTimeframe': 'future_event',
                        'eventStatus':None,
                        'city':country_city

                    })
                except Exception as e:
                    print(f"Error processing calendar event: {e}")
                    pass


        except Exception as e:
            print(f"Error fetching events and tasks: {e}")
            return JsonResponse({'error': str(e)}, safe=False)

        # print(events, '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%')
    return JsonResponse(events, safe=False)




@csrf_exempt
def delete_calender_events(request):
    if request.method == 'POST':
        entry_id = request.POST.get('entry_id')
        print(entry_id, '$$$$$$$$$$$$')
        try:
            entry = timeSheet.objects.get(id=entry_id)
            entry.delete()
            return JsonResponse({'status': 'success'}, status=200)
        except timeSheet.DoesNotExist:
            return JsonResponse({'status': 'not found'}, status=404)
    else:
        return JsonResponse({'status': 'invalid request'}, status=400)



@csrf_exempt
def decline_calender_events(request):
    if request.method == 'POST':
        entry_id = request.POST.get('entry_id')
        print(entry_id, '$$$$$$$$$$$$')
        try:
            entry = timeSheet.objects.get(id=entry_id)
            entry.status = 'declined'
            entry.save()
            return JsonResponse({'status': 'success'}, status=200)
        except timeSheet.DoesNotExist:
            return JsonResponse({'status': 'not found'}, status=404)
    else:
        return JsonResponse({'status': 'invalid request'}, status=400)

@csrf_exempt
def accept_calender_events(request):
    if request.method == 'POST':
        entry_id = request.POST.get('entry_id')
        print(entry_id, '$$$$$$$$$$$$')
        try:
            entry = timeSheet.objects.get(id=entry_id)
            entry.status = None
            entry.save()
            return JsonResponse({'status': 'success'}, status=200)
        except timeSheet.DoesNotExist:
            return JsonResponse({'status': 'not found'}, status=404)
    else:
        return JsonResponse({'status': 'invalid request'}, status=400)


@csrf_exempt
def edit_calender_events(request):

    if request.method == 'POST':
        print("muskan------------------")
        entry_id = request.POST.get('entry_id')
        start_time_str = request.POST.get('start_time1')
        end_time_str = request.POST.get('end_time1')
        client_id = request.POST.get('client_id1')
        category_id = request.POST.get('category_id1')
        description = request.POST.get('description1')
        project_id = request.POST.get('project_id1')
        description = description.strip()

        print(start_time_str)
        print(end_time_str)
        print(client_id)
        print(category_id)
        print(description)
        print(project_id)
        # Convert the string representations to datetime objects
        # start_time_str = datetime.strptime(start_time, "%H:%M")
        start_time_obj = datetime.strptime(start_time_str, "%I:%M %p")
        start_time = start_time_obj.time()
        end_time_obj = datetime.strptime(end_time_str, "%I:%M %p")
        end_time = end_time_obj.time()

        # Ensure end_time is after start_time
        # if end_time_obj < start_time_obj:
        #     end_time_obj += timedelta(days=1)

        # Check if end time is less than start time
        emp_timesheet_ob = timeSheet.objects.get(id=entry_id)
        if end_time_obj < start_time_obj:
            # Only increment if stop date is still the same as start date
            if emp_timesheet_ob.time_entries_stop_date == emp_timesheet_ob.time_entries_start_date:
                end_time_obj += timedelta(days=1)
                emp_timesheet_ob.time_entries_stop_date += timedelta(days=1)
                print("End time increased by 1 day due to crossing midnight.")
        else:
            # If end time is now greater, reset stop date to start date
            emp_timesheet_ob.time_entries_stop_date = emp_timesheet_ob.time_entries_start_date
            print("End time and start time are on the same day.")

        emp_timesheet_ob.save()

        # Calculate the time difference in seconds
        time_difference_seconds = (end_time_obj - start_time_obj).seconds

        emp_timesheet_ob = timeSheet.objects.get(id=entry_id)

        employee_ob = employee.objects.get(id=emp_timesheet_ob.employee_id)

        try:
            # country_city = request.session['employee_timezone']
            # country_city = employee_ob.timezone
            country_city = employee_ob.manual_timezone
            if len(country_city) == 0:
                employee_country = Country.objects.get(id=employee_ob.country_id)
                if employee_country.code == 'US':
                    country_city = 'America/New_York'
                elif employee_country.code == 'SA':
                    country_city = 'Africa/Johannesburg'
                elif employee_country.code == 'UK':
                    country_city = 'Europe/London'
                elif employee_country.code == 'PH':
                    country_city = 'Asia/Manila'
                else:
                    country_city = 'America/New_York'
        except Exception as e:
            employee_country = Country.objects.get(id=employee_ob.country_id)
            if employee_country.code == 'US':
                country_city = 'America/New_York'
            elif employee_country.code == 'SA':
                country_city = 'Africa/Johannesburg'
            elif employee_country.code == 'UK':
                country_city = 'Europe/London'
            elif employee_country.code == 'PH':
                country_city = 'Asia/Manila'
            else:
                country_city = 'America/New_York'

        print(country_city)
        local_tz = pytz.timezone(country_city)  # Replace with your local timezone
        # start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
        # end_date = datetime.strptime(end_date, '%Y-%m-%d').date()

        # Combine date and time
        local_start_dt = datetime.combine(emp_timesheet_ob.time_entries_start_date,
                                          emp_timesheet_ob.time_entries_start_time)
        start_datetime_utc = local_start_dt.replace(tzinfo=pytz.utc)
        start_date = start_datetime_utc.astimezone(local_tz)

        local_end_dt = datetime.combine(emp_timesheet_ob.time_entries_stop_date,
                                        emp_timesheet_ob.time_entries_stop_time)
        end_datetime_utc = local_end_dt.replace(tzinfo=pytz.utc)
        end_date = end_datetime_utc.astimezone(local_tz)

        print(start_date, start_date.date(), '###########################', end_date, end_date.date())

        local_start_dt = datetime.combine(start_date.date(), start_time)
        local_start_dt = local_tz.localize(local_start_dt)  # Make it timezone-aware
        # Convert to UTC
        start_date = local_start_dt.astimezone(pytz.utc)
        # Combine date and time

        local_end_dt = datetime.combine(end_date.date(), end_time)
        local_end_dt = local_tz.localize(local_end_dt)  # Make it timezone-aware
        # Convert to UTC
        end_date = local_end_dt.astimezone(pytz.utc)

        start_time = start_date.time()
        end_time = end_date.time()

        try:
            emp_timesheet_ob.client_id = int(client_id)
        except Exception as e:
            emp_timesheet_ob.client_id = 227
        try:
            emp_timesheet_ob.category_id = int(category_id)
        except Exception as e:
            emp_timesheet_ob.category_id = 23


        emp_timesheet_ob.description = description

        emp_timesheet_ob.time_entries_start_time = start_time
        emp_timesheet_ob.time_entries_start_date = start_date
        emp_timesheet_ob.time_entries_stop_time = end_time
        emp_timesheet_ob.time_entries_stop_date = end_date
        emp_timesheet_ob.time_entries_seconds = time_difference_seconds
   

        if emp_timesheet_ob.project_id:
            print('TEST2')
            try:
                if len(project_id) == 0:
                    print('Test3')
                    emp_timesheet_ob.project_id = None
                else:
                    print('HELLO')
                    emp_timesheet_ob.project_id = int(project_id)
            except Exception as e:
                print(e,'TEST EXCEPTION')
                emp_timesheet_ob.project_id = None
        try:
            if len(project_id) > 0:
                print('TEST4')
                emp_timesheet_ob.project_id = int(project_id)
        except Exception as e:
            print('TEST5')
            pass

        emp_timesheet_ob.save()

        get_updated_ob = timeSheet.objects.get(id=entry_id)
        start_datetime = datetime.combine(get_updated_ob.time_entries_start_date,
                                          get_updated_ob.time_entries_start_time)
        end_datetime = datetime.combine(get_updated_ob.time_entries_stop_date, get_updated_ob.time_entries_stop_time)
        start_datetime_utc = start_datetime.replace(tzinfo=pytz.utc)
        end_datetime_utc = end_datetime.replace(tzinfo=pytz.utc)

        start_datetime = start_datetime_utc.astimezone(local_tz)
        end_datetime = end_datetime_utc.astimezone(local_tz)
        # Format start_datetime in ISO 8601 format with 'Z'
        start_formatted = start_datetime.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
        end_formatted = end_datetime.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'

        return JsonResponse({'status': 'success', 'start_formatted': start_formatted,
                             'end_formatted': end_formatted}, status=200)




@csrf_exempt
@login_required(login_url='/')
def upload_contracted_employee(request):
    import csv
    from django.shortcuts import render
    if request.method == 'POST':
        file = request.FILES.get('emp_file1')
        if file:
            reader = csv.reader(file.read().decode('utf-8').splitlines())
            first_row = next(reader, None)  # Returns None if the file is empty

            for row in reader:
                employee_id = row[0].strip()
                employee_name = row[1].strip()
                current_month = int(row[2].strip())
                support = int(row[3].strip())
                account_manager = int(row[4].strip())
                advisor = int(row[5].strip())
                total = int(row[6].strip())
                current_year = 2023
                print(employee_id)
                print(employee_name)
                import calendar
                input_dt = datetime(current_year, current_month, 13)
                res = calendar.monthrange(input_dt.year, input_dt.month)
                last_day = res[1]
                current_date = date(current_year, current_month, last_day)
                if employee_id:
                    try:
                        employee_details = None
                        try:
                            start_date = date(current_year, current_month, 1)  # October 1st of the current year
                            end_date = date(current_year, current_month, 31)
                            print(current_month)
                            # start_date = date(current_year, 9, 1)  # October 1st of the current year
                            # end_date = date(current_year, 9, 30)  # October 31st of the current year

                            employee_details = contracted_employee.objects.filter(
                                employee_id=employee_id,
                                month__range=(start_date, end_date)
                            ).first()
                        except Exception as e:
                            client_details = ''
                        # from django.http import HttpResponse
                        # return HttpResponse(client_details)
                        if employee_details:
                            employee_details.employee_name = employee_name
                            employee_details.month = current_date
                            employee_details.support = support
                            employee_details.account_manager = account_manager
                            employee_details.advisor = advisor
                            employee_details.total = total
                            employee_details.save()
                        else:
                            new_employee_details = contracted_employee(employee_id=employee_id,employee_name=employee_name,month=current_date,support=support,account_manager=account_manager,advisor=advisor,total=total)
                            new_employee_details.save()
                    except Exception as e:
                        print(e)
        return redirect("employees")

    return render(request, "excel/upload_contracted_employee.html", {})

def add_holidays(request):
    if request.method == 'POST':
        # Get data from the form
        country = request.POST.get('country')
        name = request.POST.get('holiday')
        holiday_date = request.POST.get('date').split('-')
        print(holiday_date)

        holiday_date = date(int(holiday_date[2]), int(holiday_date[1]), int(holiday_date[0]))
        # holiday_date = holiday_date.strftime('%Y-%m-%d')
        description = request.POST.get('description', '')
        print(type(country), type(name), type(holiday_date), type(description))
        # Validate the data (you can add more validation as needed)
        if not country or not name or not date:
            print('HELLLLLLL')
            messages.error(request, 'Please fill in all required fields.')
            return redirect('holidays')

        # Create a new Holiday object and save it to the database
        holiday = Holiday(country_id=country, name=name, date=holiday_date, description=description)
        print("HEL@@@@@@@@@@@")
        holiday.save()
        print("HEL33333333333333333")
        messages.success(request, 'Holiday added successfully.')
        return redirect('holidays')

    return render(request, 'employees/holidays.html')

@csrf_exempt
@login_required(login_url='/')
def upload_working_category(request):
    
    if request.method == 'POST':
        file = request.FILES.get('category_file')
        if file:
            reader = csv.reader(file.read().decode('utf-8').splitlines())
            first_row = next(reader, None)  # Returns None if the file is empty

            # from django.http import HttpResponse
            # return HttpResponse(employee_list)
            for row in reader:
                category = row[0].strip()
                # Create and save a new instance of your model
                Work_Category.objects.create(category=category)

    return render(request, "excel/upload_working_category.html", {})

def get_remaining_leave(request):
    if request.method == 'GET':
        try:
            employee_id = request.GET.get('employee_id')
            print(employee_id)
            # leave_details = leave.objects.filter(employee_id=employee_id)
            current_year = datetime.now().year

            # Filter leaves for the current year only
            leave_details = leave.objects.filter(
                employee_id=employee_id,
                start_date__year=current_year  # Ensure start_date falls in the current year
            ).exclude(
                status='declined'
            )
            total_taken_days = 0
            for leave_detail in leave_details:
                start_date = leave_detail.start_date
                end_date = leave_detail.end_date
                current_date = start_date
                # Check each day between start and end date
                if leave_detail.day_type == 1:
                    while current_date <= end_date:
                        if current_date.weekday() < 4:  # Monday to Friday are represented by 0 to 4
                            total_taken_days += 1
                        current_date += timedelta(days=1)  # Move to the next day
                else:
                    total_taken_days += 0.5
            employee_details = employee.objects.get(id=employee_id)
            country_detail = Country.objects.get(id=employee_details.country_id)
            remaining_leave = country_detail.paid_leave - total_taken_days
            print(remaining_leave)
            status = 1
            leave_detail_data = {
                "remaining_leave": remaining_leave,
            }
        except Exception as e:
            status = 0
            leave_detail_data={}

        return JsonResponse({'status': status,'leave_detail':leave_detail_data})



@csrf_exempt
@login_required(login_url='/')
def upload_client_contract_employee(request):
    import csv
    from django.shortcuts import render
    if request.method == 'POST':
        file = request.FILES.get('emp_file3')
        if file:
            reader = csv.reader(file.read().decode('utf-8').splitlines())
            first_row = next(reader, None)  # Returns None if the file is empty

            for row in reader:
                employee_id1 = row[0].strip()
                employee_name = row[1].strip()
                current_month = int(row[2].strip())
                support = int(row[3].strip())
                account_manager = int(row[4].strip())
                advisor = int(row[5].strip())
                total = int(row[6].strip())
                current_year = 2026
                print(employee_id1)
                print(employee_name)
                import calendar
                input_dt = datetime(current_year, current_month, 13)
                res = calendar.monthrange(input_dt.year, input_dt.month)
                last_day = res[1]
                current_date = date(current_year, current_month, last_day)
                if employee_id1:
                    try:
                        emp_obj = employee.objects.get(toggl_user_id=employee_id1)
                        employee_id=emp_obj.id


                        employee_details = None
                        try:
                            start_date = date(current_year, current_month, 1)  # October 1st of the current year
                            end_date = date(current_year, current_month, 28)
                            print(current_month)
                            # start_date = date(current_year, 9, 1)  # October 1st of the current year
                            # end_date = date(current_year, 9, 30)  # October 31st of the current year

                            employee_details = Client_contract_employee.objects.filter(
                                employee_id=employee_id,
                                month__range=(start_date, end_date)
                            ).first()
                        except Exception as e:
                            client_details = ''
                        # from django.http import HttpResponse
                        # return HttpResponse(client_details)
                        if employee_details:
                            employee_details.employee_name = employee_name
                            employee_details.date = current_date
                            employee_details.support = support
                            employee_details.account_manager = account_manager
                            employee_details.advisor = advisor
                            employee_details.total = total
                            employee_details.save()
                        else:
                            new_employee_details = Client_contract_employee(employee_id=employee_id,date=current_date,support=support,account_manager=account_manager,advisor=advisor,total=total)
                            new_employee_details.save()
                    except Exception as e:
                        print(e)
        return redirect("employees")

    return render(request, "excel/upload_client_contract_employee.html", {})

@csrf_exempt
@login_required(login_url='/')
def excel_sheet(request):

    selected_month1 = request.session.get('month_sheet8')

    if selected_month1:
        # current_month = datetime.strptime(selected_month, "%B").month
        selected_month = int(selected_month1)
        print("iffffffffffffff")
        sl=request.session.get('month_sheet8')
    else:
        selected_month= 2
        request.session['month_sheet8'] = selected_month
        sl=request.session.get('month_sheet8')
    print("kkkkkkkkkkkkk")
    del request.session['month_sheet8']
    print(selected_month)



    # Fetch data from Client_contract_work model
    contracts =Client_contract_work.objects.filter(date__year=2026, date__month=selected_month).order_by('-updated_at')

    # Create a list to store the formatted data
    data = []
    employees_with_status_1 = employee.objects.all()
    contracted_employees = Client_contract_employee.objects.filter(employee_id__in=employees_with_status_1.values('id'),date__year=2026, date__month=selected_month)

    employee_list_data = []

    for employee1 in employees_with_status_1:
        employee_data = {
            'id': employee1.id,
            'name': employee1.user_name,
            'support': 0,
            'account_manager': 0,
            'advisor': 0,
            'status':employee1.status
        }

        for contracted_employee in contracted_employees:
            if contracted_employee.employee_id == employee1.id:
                employee_data['support'] = contracted_employee.support
                employee_data['account_manager'] = contracted_employee.account_manager
                employee_data['advisor'] = contracted_employee.advisor
                break

        employee_list_data.append(employee_data)
    print(employee_list_data )

    contract_ids = []
    for contract in contracts:
        # Fetch company name and client name using client_id
        client1 = client.objects.get(id=contract.client_id)

        # Parse the working input as a dictionary
        working_input_dict = json.loads(contract.working_input)

        # Create a list to store employee details
        employee_details = []
        for employee_id, contracted_time in working_input_dict.items():
            # Fetch employee using employee_id
            employee1 = employee.objects.get(id=int(employee_id))


            # Create a dictionary with employee details
            employee_data = {
                'employee_id': employee1.id,
                'employee_name': employee1.user_name,
                'contracted_time': contracted_time,

            }
            employee_details.append(employee_data)

        # Similarly, you can do the same for working roles
        working_role_details = []
        contract.working_roles = json.loads(contract.working_role)
        for working_role_id, role_hours in contract.working_roles.items():
            # Fetch working role using working_role_id
            employee1 = employee.objects.get(id=int(working_role_id))

            # Create a dictionary with working role details
            working_role_data = {
                'working_role_id': employee1.id,
                'role_name': employee1.user_name,
                'role_hours': role_hours,
            }
            working_role_details.append(working_role_data)
        # print(working_role_details)


        # Create a dictionary with the required fields
        contract_data = {
            'id': contract.id,
            'company_name': client1.company_name,
            'client_name': client1.client_name,
            'client_id':contract.client_id,
            'no_of_people_on_account': contract.no_of_people_on_account,
            'cost': contract.cost,
            'total_working_hours': contract.total_working_hours,
            'employee_details': employee_details,  # Add employee details to the contract data
            'working_role_details':working_role_details,
            # 'employees': employee.objects.filter(status=1),  # Add all employees to the context
            'employee_list_data':employee_list_data
        }
        data.append(contract_data)

        contract_ids.append(contract.client_id)
    print('contract_ids',contract_ids)


    # Pass the data to the template
    current_year = 2026
    client_list = client.objects.filter(status=1).all()
    employee_list = employee.objects.filter(status=1).all()
    context = {'data': data,
               'month_view':sl,
               'selected_month':selected_month,
               'current_year':current_year,
               'employee_list':employee_list,
               'client_list':client_list,
               'contract_ids':contract_ids,
            }
    return render(request, 'excel_sheet.html', context)

@csrf_exempt
@login_required(login_url='/')

def update_client_data2(request):
    import calendar
    if request.method == "POST":
        try:
            data = json.loads(request.body)
            client_id = data.get("client_id")
            employees = data.get("employees")

            current_month = int(data.get("month"))
            current_year = int(data.get("year"))
            print(data)
            print('current_month ',current_month)
            print('client_id ',client_id)
            # return HttpResponse('pppp')

            if not client.objects.filter(id=int(client_id)).exists():
                return JsonResponse({"error": "Client does not exist."}, status=400)

            start_date = date(current_year, current_month, 1)
            last_day = calendar.monthrange(current_year, current_month)[1]
            end_date = date(current_year, current_month, last_day)

            client_contract = Client_contract_work.objects.filter(
                client_id=client_id, date__range=(start_date, end_date)
            ).first()

            working_input = {}
            working_roles = {}

            for employee in employees:
                employee_id = employee["employee_id"]
                role = employee["role"]
                contracted_hours = employee["contracted_hours"]

                if employee_id:
                    working_input[employee_id] = contracted_hours
                    working_roles[employee_id] = role

            total_working_hours = sum(float(value) for value in working_input.values())
            no_of_people_on_account = len(working_input)

            json_working_input = json.dumps(working_input)
            json_working_roles = json.dumps(working_roles)

            # Update or create client contract work
            if client_contract:
                previous_employee_role = json.loads(client_contract.working_role)
                client_contract.working_input = json_working_input
                client_contract.total_working_hours = total_working_hours
                client_contract.no_of_people_on_account = no_of_people_on_account
                client_contract.working_role = json_working_roles
                client_contract.save()
            else:
                pass

            for employee_id, previous_role in previous_employee_role.items():
                contract_employee = Client_contract_employee.objects.filter(
                    employee_id=employee_id, date__range=(start_date, end_date)
                ).first()
                print(employee_id)
                print('contract_employee ',contract_employee)
                # return HttpResponse('pp')
                if previous_role:
                    if previous_role == "A":
                        contract_employee.advisor -= 1
                    elif previous_role == "B":
                        contract_employee.support -= 1
                    elif previous_role == "C":
                        contract_employee.account_manager -= 1

                    contract_employee.total -= 1

                    contract_employee.save()

            # return HttpResponse('pp')
            # Update employee roles and contract work
            for employee_id, new_role in working_roles.items():
                contract_employee = Client_contract_employee.objects.filter(
                    employee_id=employee_id, date__range=(start_date, end_date)
                ).first()

                if contract_employee:

                    if new_role == "A":
                        contract_employee.advisor += 1
                    elif new_role == "B":
                        contract_employee.support += 1
                    elif new_role == "C":
                        contract_employee.account_manager += 1

                    contract_employee.total += 1

                    contract_employee.save()

                else:
                    Client_contract_employee.objects.create(
                        employee_id=employee_id,
                        support=1 if new_role == "B" else 0,
                        advisor=1 if new_role == "A" else 0,
                        account_manager=1 if new_role == "C" else 0,
                        total=1,
                        date=end_date
                    )

            return JsonResponse({"status": "success", "message": "Contract updated successfully."})

        except Exception as e:
            return JsonResponse({"error": str(e)}, status=500)

    return JsonResponse({"error": "Invalid request method"}, status=400)

@csrf_exempt
@login_required(login_url='/')
def update_client_data(request):
    import calendar
    if request.method == 'POST':
        client_id = request.POST.get('client_id')
        field = request.POST.get('field')
        value = request.POST.get('value')
        employee_id = request.POST.get('employee_id')
        prev_employee_id = request.POST.get('prev_employee_id')
        role_hours = request.POST.get('role_hours')
        current_year = int(request.POST.get('year'))
        selected_month = int(request.POST.get('selected_month'))

        print(client_id)
        print(field)
        print(value)
        print(employee_id)
        print(prev_employee_id)
        print(role_hours)
        print(selected_month)

        if client_id and field == 'no_of_people_on_account':
            try:
                client_contract_work = Client_contract_work.objects.get(client_id=client_id,date__month=selected_month)
                client_contract_work.no_of_people_on_account = value
                client_contract_work.save()
            except Client_contract_work.DoesNotExist:
                pass
        if client_id and field == 'cost':
            try:
                start_date = date(current_year, selected_month, 1)
                input_dt = datetime(current_year, selected_month, 13)
                res = calendar.monthrange(input_dt.year, input_dt.month)
                last_day = res[1]

                end_date = date(current_year, selected_month, last_day)

                client_contract_work = Client_contract_work.objects.filter(
                    client_id=client_id,
                    date__range=(start_date, end_date)
                ).first()
                client_contract_work.cost = value
                client_contract_work.save()
            except Client_contract_work.DoesNotExist:
                pass
        if client_id and field == 'total_working_hours':
            try:
                client_contract_work = Client_contract_work.objects.get(client_id=client_id,date__month=selected_month)
                client_contract_work.total_working_hours = value
                client_contract_work.save()
            except Client_contract_work.DoesNotExist:
                pass
        if client_id and field == 'employee_name':
            try:
                client_contract_work = Client_contract_work.objects.get(client_id=client_id,date__month=selected_month)

                working_input_dict = json.loads(client_contract_work.working_input)
                working_role_dict = json.loads(client_contract_work.working_role)
                prev_employee_id=prev_employee_id
                employee_id=employee_id
                if prev_employee_id in working_input_dict and working_role_dict:
                    working_input_dict[employee_id] = working_input_dict.pop(prev_employee_id)
                    working_role_dict[employee_id] = working_role_dict.pop(prev_employee_id)

                    client_contract_work.working_input = json.dumps(working_input_dict)
                    client_contract_work.working_role = json.dumps(working_role_dict)

                    client_contract_work.save()

            except Client_contract_work.DoesNotExist:
                pass
        if client_id and field == 'role_hours':
            try:
                client_contract_work = Client_contract_work.objects.get(client_id=client_id,date__month=selected_month)

                working_role_dict = json.loads(client_contract_work.working_role)
                working_role_dict[employee_id] = value
                client_contract_work.working_role = json.dumps(working_role_dict)

                client_contract_work.save()
            except Client_contract_work.DoesNotExist:
                pass
        if client_id and field == 'contracted_time':
            try:
                client_contract_work = Client_contract_work.objects.get(client_id=client_id,date__month=selected_month)
                working_input_dict = json.loads(client_contract_work.working_input)
                working_input_dict[employee_id] = value
                client_contract_work.working_input = json.dumps(working_input_dict)

                client_contract_work.save()
            except Client_contract_work.DoesNotExist:
                pass


        return JsonResponse({'status': 'success'})
    else:
        return JsonResponse({'status': 'error'})

@csrf_exempt
@login_required(login_url='/')
def update_month_sheet(request):
    month1 = request.GET.get('month1')

    request.session['month_sheet8'] = month1

    request.session.save()

    return JsonResponse({"month1": month1})

@csrf_exempt
@login_required(login_url='/')
def search_designation(request):
    if request.user.groups.exists():
        group = request.user.groups.all()
        print("exist group")
        print(group)

        if group[0].name == 'admin' or group[0].name == 'super_admin' or group[0].name == 'super_user':
       
            selected_name = request.GET.get('name')
            selected_country = request.GET.get('country')
            selected_designation = request.GET.get('designation')

            # Query your database based on the selected designation
            # Example:
            print("astha222222222222222")
            
            print(selected_name)
            print(selected_country)
            print(selected_designation)

            if selected_name !='Select Name':
                employee_list = employee.objects.filter(status=1,id=selected_name)
                print(employee_list)
            elif selected_country !='Select Country'and selected_designation !='Select Designation':
                employee_list = employee.objects.filter(status=1,country_id=selected_country,designation=selected_designation)
                print(employee_list)

            elif selected_country !='Select Country':
                employee_list = employee.objects.filter(status=1,country_id=selected_country)
                print(employee_list)
            else:
                employee_list = employee.objects.filter(status=1,designation=selected_designation)
                print(employee_list)

            toggl_user_ids = [employee.toggl_user_id for employee in employee_list]
            # print(toggl_user_ids)
            ids = [employee.id for employee in employee_list]
            # print(ids)
            selected_month = request.session.get('month')

            if selected_month:
                # current_month = datetime.strptime(selected_month, "%B").month
                current_month = int(selected_month)
            else:
                current_month = 2

            if current_month ==1:
                last_month=12
            else:
                last_month=current_month-1
            # print("ssssssssssssssssssssssssssssssssssssss")
            # print(current_month)
            # print(last_month)

            selected_year = request.session.get('year')

            if selected_year:
                # current_month = datetime.strptime(selected_month, "%B").month
                current_year = int(selected_year)
            else:
                current_year = 2026

            if current_month ==1:
                last_year=current_year-1
            else:
                last_year=current_year

            if current_year == 2023 and 9 <= current_month <= 12:
                contracted_employee_for_month = contracted_employee.objects.filter(employee_id__in=toggl_user_ids,month__month=current_month, month__year=current_year
                )
                # print(contracted_employee_for_month)
                contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}
                # print("fffffffffffffffffffffffffffffffffffffffffffffffffffff")
                # print(contracted_employee_dict)

                for emp in employee_list:
                    emp.contracted_employee_info = contracted_employee_dict.get(emp.toggl_user_id, None)

                # print('muskan')
                # print(employee_list)
            else:
                contracted_employee_for_month = Client_contract_employee.objects.filter(employee_id__in=ids,date__month=current_month, date__year=current_year
                )
                # print(contracted_employee_for_month)
                contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}
                # print("iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii")
                # print(contracted_employee_dict)

                for emp in employee_list:
                    emp.contracted_employee_info = contracted_employee_dict.get(emp.id, None)

                # print('muskan')
                # print(employee_list)

            data = {"employee_list": employee_list,
                    "current_year":current_year,
                    "current_month":current_month,
                    "month_list":[],
                    }
            # print(data)
            return render(request, "employees/search_designation.html", data)
        
    group = None


    print("admin")
    selected_name = request.GET.get('name')
    selected_country = request.GET.get('country')
    selected_designation = request.GET.get('designation')

    # Query your database based on the selected designation
    # Example:
    print("astha")
    print(selected_name)
    print(selected_country)
    print(selected_designation)

    if selected_name !='Select Name':
        employee_list = employee.objects.filter(status=1,id=selected_name)
        print(employee_list)
    elif selected_country !='Select Country'and selected_designation !='Select Designation':
        employee_list = employee.objects.filter(status=1,country_id=selected_country,designation=selected_designation)
        print(employee_list)
    elif selected_country !='Select Country':
        employee_list = employee.objects.filter(status=1,country_id=selected_country)
        print(employee_list)
    else:
        employee_list = employee.objects.filter(status=1,designation=selected_designation)
        print(employee_list)

    toggl_user_ids = [employee.toggl_user_id for employee in employee_list]
    # print(toggl_user_ids)
    ids = [employee.id for employee in employee_list]
    # print(ids)
    selected_month = request.session.get('month')

    if selected_month:
        # current_month = datetime.strptime(selected_month, "%B").month
        current_month = int(selected_month)
    else:
        current_month = 2

    if current_month ==1:
        last_month=12
    else:
        last_month=current_month-1
    # print("ssssssssssssssssssssssssssssssssssssss")
    # print(current_month)
    # print(last_month)

    selected_year = request.session.get('year')

    if selected_year:
        # current_month = datetime.strptime(selected_month, "%B").month
        current_year = int(selected_year)
    else:
        current_year = 2026

    if current_month ==1:
        last_year=current_year-1
    else:
        last_year=current_year

    # print("gggggggggggggggggggggggggggggggggggggg")
    # print(current_year)
    # print(last_year)
    if current_year == 2023 and 9 <= current_month <= 12:
        contracted_employee_for_month = contracted_employee.objects.filter(employee_id__in=toggl_user_ids,month__month=current_month, month__year=current_year
        )
        # print(contracted_employee_for_month)
        contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}
        # print("fffffffffffffffffffffffffffffffffffffffffffffffffffff")
        # print(contracted_employee_dict)

        for emp in employee_list:
            emp.contracted_employee_info = contracted_employee_dict.get(emp.toggl_user_id, None)

        # print('muskan')
        # print(employee_list)
    else:
        contracted_employee_for_month = Client_contract_employee.objects.filter(employee_id__in=ids,date__month=current_month, date__year=current_year
        )
        # print(contracted_employee_for_month)
        contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}
        # print("iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii")
        # print(contracted_employee_dict)

        for emp in employee_list:
            emp.contracted_employee_info = contracted_employee_dict.get(emp.id, None)

        print('muskan')
        print(employee_list)

    data = {"employee_list": employee_list,
            "current_year":current_year,
            "current_month":current_month,
            "month_list":[],
            }
    # print(data)
    return render(request, "employees/search_designation.html", data)


@login_required(login_url='/')
def old_search_designation(request):
    if request.user.username == 'Sbhutra' and request.user.id == 6:
        selected_name = request.GET.get('name')
        selected_country = request.GET.get('country')
        selected_designation = request.GET.get('designation')

        # Query your database based on the selected designation
        # Example:
        print("astha3333333333333")
        print(selected_name)
        print(selected_country)
        print(selected_designation)

        if selected_name !='Select Name':
            employee_list = employee.objects.filter(status=2,id=selected_name)
            print(employee_list)
        elif selected_country !='Select Country'and selected_designation !='Select Designation':
            employee_list = employee.objects.filter(status=2,country_id=selected_country,designation=selected_designation)
            print(employee_list)
        elif selected_country !='Select Country':
            employee_list = employee.objects.filter(status=2,country_id=selected_country)
            print(employee_list)
        else:
            employee_list = employee.objects.filter(status=2,designation=selected_designation)
            print(employee_list)

        toggl_user_ids = [employee.toggl_user_id for employee in employee_list]
        # print(toggl_user_ids)
        ids = [employee.id for employee in employee_list]
        # print(ids)
        selected_month = request.session.get('month')

        if selected_month:
            # current_month = datetime.strptime(selected_month, "%B").month
            current_month = int(selected_month)
        else:
            current_month = 2

        if current_month ==1:
            last_month=12
        else:
            last_month=current_month-1

        selected_year = request.session.get('year')

        if selected_year:
            # current_month = datetime.strptime(selected_month, "%B").month
            current_year = int(selected_year)
        else:
            current_year = 2026

        if current_month ==1:
            last_year=current_year-1
        else:
            last_year=current_year


        if current_year == 2023 and 9 <= current_month <= 12:
            contracted_employee_for_month = contracted_employee.objects.filter(employee_id__in=toggl_user_ids,month__month=current_month, month__year=current_year
            )

            contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}

            for emp in employee_list:
                emp.contracted_employee_info = contracted_employee_dict.get(emp.toggl_user_id, None)


        else:
            contracted_employee_for_month = Client_contract_employee.objects.filter(employee_id__in=ids,date__month=current_month, date__year=current_year
            )

            contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}
  

            for emp in employee_list:
                emp.contracted_employee_info = contracted_employee_dict.get(emp.id, None)

            print('muskan')
            print(employee_list)

        data = {"employee_list": employee_list,
                "current_year":current_year,
                "current_month":current_month,
                "month_list":[],
                }
        # print(data)
        return render(request, "employees/search_designation.html", data)
    group = None

    if request.user.groups.exists():
        group = request.user.groups.all()
        print("exist group")
        print(group)

        if group[0].name == 'admin' or group[0].name == 'super_admin' or group[0].name == 'super_user':
            selected_name = request.GET.get('name')
            selected_country = request.GET.get('country')
            selected_designation = request.GET.get('designation')


            print(selected_name)
            print(selected_country)
            print(selected_designation)

            if selected_name !='Select Name':
                employee_list = employee.objects.filter(status=2,id=selected_name)
                print(employee_list)
            elif selected_country !='Select Country'and selected_designation !='Select Designation':
                employee_list = employee.objects.filter(status=2,country_id=selected_country,designation=selected_designation)
                print(employee_list)
            elif selected_country !='Select Country':
                employee_list = employee.objects.filter(status=2,country_id=selected_country)
                print(employee_list)
            else:
                employee_list = employee.objects.filter(status=2,designation=selected_designation)
                print(employee_list)

            toggl_user_ids = [employee.toggl_user_id for employee in employee_list]
            # print(toggl_user_ids)
            ids = [employee.id for employee in employee_list]
            # print(ids)
            selected_month = request.session.get('month')

            if selected_month:
                # current_month = datetime.strptime(selected_month, "%B").month
                current_month = int(selected_month)
            else:
                current_month = 2

            if current_month ==1:
                last_month=12
            else:
                last_month=current_month-1

            selected_year = request.session.get('year')

            if selected_year:
                # current_month = datetime.strptime(selected_month, "%B").month
                current_year = int(selected_year)
            else:
                current_year = 2026

            if current_month ==1:
                last_year=current_year-1
            else:
                last_year=current_year


            if current_year == 2023 and 9 <= current_month <= 12:
                contracted_employee_for_month = contracted_employee.objects.filter(employee_id__in=toggl_user_ids,month__month=current_month, month__year=current_year
                )

                contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}


                for emp in employee_list:
                    emp.contracted_employee_info = contracted_employee_dict.get(emp.toggl_user_id, None)
            else:
                contracted_employee_for_month = Client_contract_employee.objects.filter(employee_id__in=ids,date__month=current_month, date__year=current_year
                )
                # print(contracted_employee_for_month)
                contracted_employee_dict = {employee.employee_id: employee for employee in contracted_employee_for_month}

                for emp in employee_list:
                    emp.contracted_employee_info = contracted_employee_dict.get(emp.id, None)

                print('muskan')
                print(employee_list)

            data = {"employee_list": employee_list,
                    "current_year":current_year,
                    "current_month":current_month,
                    "month_list":[],
                    }
            # print(data)
            return render(request, "employees/search_designation.html", data)

@csrf_exempt
@login_required(login_url='/')
def report(request):
    active = [''] * 15
    active[12] = 'active'
    # Initialize selected_client_ids
    selected_client_ids = []
    selected_employee_ids = []

    # Calculate the date range for the last week
    if request.method == 'POST':
        print("postttttttttttttttttttttttttttttttttttttttttttttttttt")


        from datetime import datetime, timedelta
        from_to_date = request.POST.get('from_to_date', None)
        print("companies111")
        print(from_to_date)

        # Split the string into "from" and "to" dates
        from_date_str, to_date_str = from_to_date.split(" - ")

        # Convert the date strings to datetime objects
        from_date = datetime.strptime(from_date_str, "%m/%d/%Y").date()
        to_date = datetime.strptime(to_date_str, "%m/%d/%Y").date()

        # Print the formatted dates
        print("From date:", from_date)
        print("To date:", to_date)

        # Convert start_date and end_date to datetime objects
        start_date = datetime.combine(from_date, datetime.min.time())
        end_date = datetime.combine(to_date, datetime.min.time())


        selected_client_ids = request.POST.getlist('client_id')
        print("akshay")
        print(selected_client_ids)

        selected_employee_ids = request.POST.getlist('employee_id')
        print("akshay33")
        print(selected_employee_ids)

        selected_option = request.POST.get('selected_option')
        auto_submit = request.POST.get('auto_submit')
        print("selcetddddd")
        print(selected_option)
        if auto_submit == '1':
            # Auto submission occurred, handle it here
            # For example, redirect to a different view based on the selected option
            if selected_option == '0':
                print(selected_option)
            elif selected_option == '1':
                print(selected_option)





    else:

        from datetime import datetime, timedelta

        # Get current date
        # end_date = datetime.now().date()
        # # Calculate start date (7 days ago)
        # start_date = end_date - timedelta(days=6)
        selected_month = request.session.get('month')
        if selected_month:
            current_month = int(selected_month)
        else:
            current_month = 2

        selected_year = request.session.get('year')
        if selected_year:
            current_year = int(selected_year)
        else:
            current_year = 2026

        current_date = datetime.now()
        if current_month == current_date.month:
            start_date = current_date - timedelta(days=current_date.weekday())
            end_date = start_date + timedelta(days=6)
        else:
            start_date = datetime(current_year, current_month, 1, 0, 0, 0)            
            end_date = datetime(current_year, current_month, calendar.monthrange(current_year, current_month)[1], 23, 59, 59)

        # Format the dates as desired
        formatted_start_date = start_date.strftime("%m/%d/%Y")
        formatted_end_date = end_date.strftime("%m/%d/%Y")

        # Concatenate the formatted dates
        formatted_date_range = f"{formatted_start_date} - {formatted_end_date}"

        print(formatted_date_range)
        from_to_date=formatted_date_range
        print("elsedatw")
        print(from_to_date)

        selected_option='0'

    all_clients = client.objects.all()
    all_employees =employee.objects.filter(status__in=[1, 2])

    if selected_client_ids and selected_employee_ids:
        print("if1111111111")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,
            employee_id__in=selected_employee_ids,
            status=None
        )

    elif selected_client_ids :
        print("if222222222222")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,
            status=None

        )
    elif selected_employee_ids:
        print("if3333333333333")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            employee_id__in=selected_employee_ids,
            status=None
        )
    else:
        # print("else")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            status=None
        )

    # Fetch the client objects for the selected client IDs
    # Fetch the client objects for the selected client IDs
    selected_clients = client.objects.filter(id__in=selected_client_ids)
    selected_employees=employee.objects.filter(id__in=selected_employee_ids)

    # Create a list of tuples containing client ID and name for selected clients
    selected_client_names = [(client.id, client.toggl_client_name) for client in selected_clients]
    # print(selected_client_names)

    total_selected_clients = len(selected_client_ids)
    total_selected_employees = len(selected_employee_ids)

    employee_total_time = {}
    client_total_time = {}

    entries_with_details = []
    entries_with_client_details = []

    if selected_option == '0' :
        print("userrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr")
        # Iterate over timeSheet entries
        for entry in time_entries_last_week:
            employee_id = entry.employee_id
            category_id = entry.category_id  # Assuming you have category_id in your entry object

            # Fetch the employee from the employee table
            try:
                emp = employee.objects.get(id=employee_id)
            except employee.DoesNotExist:
                continue

            # If the employee exists, update the total time spent
            if employee_id in employee_total_time:
                if category_id not in employee_total_time[employee_id]['categories']:
                    employee_total_time[employee_id]['entry_count'] += 1
                    employee_total_time[employee_id]['categories'].add(category_id)

                employee_total_time[employee_id]['total_time'] += entry.time_entries_seconds
            else:
                employee_total_time[employee_id] = {
                    'total_time': entry.time_entries_seconds,
                    'entry_count': 1,
                    'first_name': emp.first_name,
                    'last_name': emp.last_name,
                    'image_url': emp.image_url,
                    'categories': {category_id}  # Using a set to store unique category IDs
                }

        # Create a dictionary to store total time spent by each employee

        # Convert seconds to the desired format
        for employee_id, data in employee_total_time.items():
            total_seconds = data['total_time']
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            data['total_time'] = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))
            data['total_time_hour'] = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

        # Convert total_time to seconds before performing arithmetic operations
        for employee_id, data in employee_total_time.items():
            total_time_str = data['total_time']
            try:
                hours, minutes, seconds = map(int, total_time_str.split(':'))
                total_seconds = hours * 3600 + minutes * 60 + seconds
                data['total_time'] = total_seconds
            except ValueError:
                # Handle cases where total_time is not in the expected format
                data['total_time'] = 0

        # Calculate the total time spent by all employees in the last week
        total_time_all_employees = sum(data['total_time'] for data in employee_total_time.values() if isinstance(data['total_time'], int))
        # Convert seconds to hours, minutes, and seconds
        hours = total_time_all_employees // 3600
        minutes = (total_time_all_employees % 3600) // 60
        seconds = total_time_all_employees % 60

        # Format the total time
        total_time_formatted1 = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

        # Calculate the percentage of time spent by each employee and add it to the dictionary
        for employee_id, data in employee_total_time.items():
            total_time_employee = data['total_time']
            if isinstance(total_time_employee, int):
                percentage = (total_time_employee / total_time_all_employees) * 100
                data['percentage'] = round(percentage, 2)
            else:
                # Set percentage to 0 or handle as appropriate if total_time is not a valid integer
                data['percentage'] = 0

        print("table1")
        print(employee_total_time)
        # Iterate through each entry in the queryset
        for entry in time_entries_last_week:
            import datetime
            # Fetch employee details
            employee1 = employee.objects.get(id=entry.employee_id)

            # Calculate total time spent by the employee
            total_time_employee = sum(e.time_entries_seconds for e in time_entries_last_week if e.employee_id == entry.employee_id)
            # print(total_time_employee)

            # Fetch client details
            client1 = client.objects.get(id=entry.client_id)

            # Fetch category details
            category_id = Work_Category.objects.get(id=entry.category_id)

            # Convert time duration from seconds to formatted string
            hours, remainder = divmod(entry.time_entries_seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            duration_formatted = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

            # Calculate percentage time spent for the current entry
            if total_time_employee > 0:
                percentage_time = entry.time_entries_seconds / total_time_employee
            else:
                percentage_time = 0

            # Multiply by data['percentage'] for that employee id
            if entry.employee_id in employee_total_time:
                percentage_multiplier = employee_total_time[entry.employee_id]['percentage']

                percentage_time *= percentage_multiplier

            # Round percentage_time to 2 decimal points
            percentage_time = round(percentage_time, 2)


            # Check if the category ID already exists in entries_with_details for the current employee
            category_exists = False
            for detail in entries_with_details:
                if detail['category_id'] == category_id.id and detail['employee_id'] == entry.employee_id:
                    # Update existing entry
                    detail['percentage_time']=round(detail['percentage_time'],2)
                    detail['percentage_time'] += percentage_time
                    detail['percentage_time']=round(detail['percentage_time'],2)
                    # Convert existing time to seconds, add new time, and then convert back to formatted string
                    existing_seconds = sum(int(x) * 60 ** i for i, x in enumerate(reversed(detail['time'].split(':'))))
                    total_seconds = existing_seconds + entry.time_entries_seconds
                    total_hours, remainder = divmod(total_seconds, 3600)
                    total_minutes, total_seconds = divmod(remainder, 60)
                    total_formatted = '{:02d}:{:02d}:{:02d}'.format(int(total_hours), int(total_minutes), int(total_seconds))
                    detail['time'] = total_formatted
                    category_exists = True
                    break

            if not category_exists:
                # Add additional details to the entry dictionary
                entry_details = {
                    'employee_id': entry.employee_id,
                    'time': duration_formatted,  # Convert time to formatted string
                    'percentage_time': percentage_time,
                    'category_name': category_id.category,
                    'category_id': category_id.id
                }
                entries_with_details.append(entry_details)

        print("table2")
        print(entries_with_details)
        entries_with_details = sorted(
            entries_with_details,
            key=lambda entry: entry['percentage_time'],  # Sort by percentage_time
            reverse=True  # Descending order
        )

        # Create a dictionary to store total time spent by each day
        from collections import defaultdict
        # Create a dictionary to store total time spent by each day
        daily_total_time = defaultdict(int)

        # Calculate total time worked for each day
        for entry in time_entries_last_week:
            # Extract the day of the week and date from the start date of the entry
            day_of_week = entry.time_entries_start_date.strftime('%a')
            date = entry.time_entries_start_date.strftime('%d %b')  # Format date as 'Day Month'
            # Increment the total time for that day
            daily_total_time[f"{date}"] += entry.time_entries_seconds / 3600  # Convert seconds to hours



        print(type(start_date))
        print(end_date)

        if start_date==end_date:
           num_days =1

        else:
           num_days = (end_date - start_date).days +1

        # Generate labels and data for the selected date range
        labels = []
        current_date = start_date
        for i in range(num_days):
            label_date = current_date.strftime('%d %b')  # Format date as 'Day Month'
            labels.append(label_date)
            current_date += timedelta(days=1)

        # Convert the dictionary values to a list for data
        data = [daily_total_time[label] for label in labels]


        print("bar_chart")
        print(labels)
        print(data)

        # Prepare data for the pie chart

        # Create pie_chart_data dictionary
        pie_chart_data = {
            employee_id: {
                'name': f"{data1['first_name']} {data1['last_name']}",
                'percentage': data1['percentage']
            } for employee_id, data1 in employee_total_time.items()
        }

        employee_total_time = sorted(
            employee_total_time.items(),
            key=lambda item: item[1]['total_time'],  # Sort by total_time
            reverse=True  # Descending order
        )
        employee_total_time = dict(employee_total_time)
        
        # print(pie_chart_data)
        # # Extracting labels and data from pie_chart_data
        pie1= []
        pie2 = []
        # #
        for employee_id, data1 in pie_chart_data.items():
            name1 = data1['name']
            percentage1 = data1['percentage']
            # print(name1)
            # print(percentage1)
            pie1.append(name1)
            pie2.append(percentage1)
        #
        print("piechart1")
        print(pie1)
        print(pie2)

        #2nd pie chart

        # Create pie_chart_data_2 dictionary

        pie_chart_data_2 = {}

        # Iterate over timeSheet entries
        for entry in time_entries_last_week:
            category_id = entry.category_id

            # If the category exists, update the total time spent
            if category_id in pie_chart_data_2:
                pie_chart_data_2[category_id] += entry.time_entries_seconds
            else:
                pie_chart_data_2[category_id] = entry.time_entries_seconds

        # Convert seconds to the desired format for each category
        pie3 = []  # List to store category names
        pie4 = []  # List to store total time spent on each category


        # Query category names from the Work_Category table
        category_names = Work_Category.objects.in_bulk(pie_chart_data_2.keys())

        # Calculate total time spent across all categories
        total_time_all_categories = sum(pie_chart_data_2.values())

        for category_id, total_seconds in pie_chart_data_2.items():
            category_name = category_names[category_id].category  # Fetch category name from the queried data
            pie3.append(category_name)
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            time_formatted1 = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))
            # pie4.append(time_formatted)


            # Calculate the percentage of time spent in each category and append it to pie4
            percentage_time = (total_seconds / total_time_all_categories) * 100
            pie4.append(percentage_time)

        print("piechart2222")
        print(pie3)
        print(pie4)


    else:
        print("clientttttttttttttttttttttttttttttttttttttttttttttttttttttttt")
        # Iterate over timeSheet entries
        for entry in time_entries_last_week:
            client_id = entry.client_id
            category_id = entry.category_id

            # Fetch the client from the client table
            try:
                client1 = client.objects.get(id=client_id)
            except client.DoesNotExist:
                continue

            # If the client exists, update the total time spent
            # if client_id in client_total_time:
            #     client_total_time[client_id]['total_time'] += entry.time_entries_seconds
            #     client_total_time[client_id]['entry_count'] += 1
            if client_id in client_total_time:
                client_data = client_total_time[client_id]
                client_data['total_time'] += entry.time_entries_seconds
                # Check if the category ID is new for this client
                if category_id not in client_data['category_ids']:
                    client_data['category_ids'].append(category_id)
                    client_data['entry_count'] += 1  # Increment entry count only if category is different
            else:
                client_total_time[client_id] = {
                    'total_time': entry.time_entries_seconds,
                    'entry_count': 1,
                    'client_name': client1.client_name,
                    'image_url': client1.image_url,
                    'category_ids': [category_id]
                }

        # Convert seconds to the desired format
        for client_id, data in client_total_time.items():
            total_seconds = data['total_time']
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            data['total_time'] = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))
            data['total_time_hour'] = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

        # Convert total_time to seconds before performing arithmetic operations
        for client_id, data in client_total_time.items():
            total_time_str = data['total_time']
            try:
                hours, minutes, seconds = map(int, total_time_str.split(':'))
                total_seconds = hours * 3600 + minutes * 60 + seconds
                data['total_time'] = total_seconds
            except ValueError:
                # Handle cases where total_time is not in the expected format
                data['total_time'] = 0

        # Calculate the total time spent by all clients in the last week
        total_time_all_clients = sum(data['total_time'] for data in client_total_time.values() if isinstance(data['total_time'], int))
        # Convert seconds to hours, minutes, and seconds
        hours = total_time_all_clients // 3600
        minutes = (total_time_all_clients % 3600) // 60
        seconds = total_time_all_clients % 60

        # Format the total time
        total_time_formatted1 = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

        # Calculate the percentage of time spent by each client and add it to the dictionary
        for client_id, data in client_total_time.items():
            total_time_client = data['total_time']
            if isinstance(total_time_client, int):
                percentage = (total_time_client / total_time_all_clients) * 100
                data['percentage'] = round(percentage, 2)
            else:
                # Set percentage to 0 or handle as appropriate if total_time is not a valid integer
                data['percentage'] = 0

        print("table1")
        print(client_total_time)
        # Iterate through each entry in the queryset

        # Iterate through each entry in the queryset
        for entry in time_entries_last_week:
            import datetime

            # Fetch client details
            client1 = client.objects.get(id=entry.client_id)

            # Fetch category details
            category_id = Work_Category.objects.get(id=entry.category_id)
            category_id1 = Work_Category.objects.values('id').get(id=entry.category_id)['id']
            category_id1 = int(category_id1)
            print("myyyyyyyyyyyy")
            print(type(category_id1))


            # Calculate total time spent by the client
            total_time_client = sum(e.time_entries_seconds for e in time_entries_last_week if e.client_id == entry.client_id)

            # Calculate total time spent for the client and category combination
            total_time_client_category = sum(
                e.time_entries_seconds for e in time_entries_last_week if e.client_id == entry.client_id and e.category_id == entry.category_id)

            # Convert time duration from seconds to formatted string
            hours, remainder = divmod(total_time_client_category, 3600)
            minutes, seconds = divmod(remainder, 60)
            duration_formatted = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

            # Calculate percentage time spent for the current entry
            if total_time_client_category > 0:
                percentage_time = entry.time_entries_seconds / total_time_client
            else:
                percentage_time = 0

            # Multiply by data['percentage'] for that client id
            if entry.client_id in client_total_time:
                percentage_multiplier = client_total_time[entry.client_id]['percentage']
                percentage_time *= percentage_multiplier

            # Round percentage_time to 2 decimal points
            percentage_time = round(percentage_time, 2)

            # Check if entry with same client_id and category_id already exists
            existing_entry = next((e for e in entries_with_client_details if e['client_id'] == entry.client_id and e['category_id'] == entry.category_id), None)

            if existing_entry:
                # Update existing entry
                existing_entry['time'] = duration_formatted
                existing_entry['percentage_time'] = round(existing_entry['percentage_time'] + percentage_time, 2)
                existing_entry['total_time_client'] += total_time_client
            else:
                # Add new entry
                entry_details = {
                    'client_id': entry.client_id,
                    'time': duration_formatted,
                    'percentage_time': percentage_time,
                    'total_time_client': total_time_client_category,
                    'client_name': client1.toggl_client_name,
                    'category_name': category_id.category,
                    'category_id': category_id1
                }
                entries_with_client_details.append(entry_details)

        print("table2")
        print(entries_with_client_details)
        entries_with_client_details = sorted(
            entries_with_client_details,
            key=lambda entry: entry['percentage_time'],  # Sort by percentage_time
            reverse=True  # Descending order
        )


        #for bar graphhhhhhh


        # Create a dictionary to store total time spent by each day
        from collections import defaultdict
        # Create a dictionary to store total time spent by each day
        daily_total_time = defaultdict(int)

        # Calculate total time worked for each day
        for entry in time_entries_last_week:
            # Extract the day of the week and date from the start date of the entry
            day_of_week = entry.time_entries_start_date.strftime('%a')
            date = entry.time_entries_start_date.strftime('%d %b')  # Format date as 'Day Month'
            # Increment the total time for that day
            daily_total_time[f"{date}"] += entry.time_entries_seconds / 3600  # Convert seconds to hours



        print(type(start_date))
        print(end_date)

        if start_date==end_date:
           num_days =1

        else:
           num_days = (end_date - start_date).days +1

        # Generate labels and data for the selected date range
        labels = []
        current_date = start_date
        for i in range(num_days):
            label_date = current_date.strftime('%d %b')  # Format date as 'Day Month'
            labels.append(label_date)
            current_date += timedelta(days=1)

        # Convert the dictionary values to a list for data
        data = [daily_total_time[label] for label in labels]


        print("bar_chart")
        print(labels)
        print(data)

        # Prepare data for the pie chart

        # Create pie_chart_data dictionary
        pie_chart_data = {
            client_id: {
                'name': f"{data1['client_name']}",
                'percentage': data1['percentage']
            } for client_id, data1 in client_total_time.items()
        }
        client_total_time = sorted(
            client_total_time.items(),
            key=lambda item: item[1]['total_time'],  # Sort by total_time
            reverse=True  # Descending order
        )
        client_total_time = dict(client_total_time)
        # print(pie_chart_data)
        # # Extracting labels and data from pie_chart_data
        pie1= []
        pie2 = []
        # #
        for client_id, data1 in pie_chart_data.items():
            name1 = data1['name']
            percentage1 = data1['percentage']
            # print(name1)
            # print(percentage1)
            pie1.append(name1)
            pie2.append(percentage1)
        #
        print("piechart1")
        print(pie1)
        print(pie2)


        #2nd pie chart

        # Create pie_chart_data_2 dictionary

        pie_chart_data_2 = {}

        # Iterate over timeSheet entries
        for entry in time_entries_last_week:
            category_id = entry.category_id

            # If the category exists, update the total time spent
            if category_id in pie_chart_data_2:
                pie_chart_data_2[category_id] += entry.time_entries_seconds
            else:
                pie_chart_data_2[category_id] = entry.time_entries_seconds

        # Convert seconds to the desired format for each category
        pie3 = []  # List to store category names
        pie4 = []  # List to store total time spent on each category


        # Query category names from the Work_Category table
        category_names = Work_Category.objects.in_bulk(pie_chart_data_2.keys())

        # Calculate total time spent across all categories
        total_time_all_categories = sum(pie_chart_data_2.values())

        for category_id, total_seconds in pie_chart_data_2.items():
            category_name = category_names[category_id].category  # Fetch category name from the queried data
            pie3.append(category_name)
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            time_formatted1 = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))
            # pie4.append(time_formatted)


            # Calculate the percentage of time spent in each category and append it to pie4
            percentage_time = (total_seconds / total_time_all_categories) * 100
            pie4.append(percentage_time)

        print("piechart2222")
        print(pie3)
        print(pie4)

    print(selected_option)
    print('Vinod from_to_date',from_to_date)
    if from_to_date:
        from datetime import datetime
        try:
            # Convert MM/DD/YYYY format to YYYY-MM-DD
            from_date = datetime.strptime(from_to_date.split(" - ")[0].strip(), "%m/%d/%Y").strftime("%Y-%m-%d")
            to_date = datetime.strptime(from_to_date.split(" - ")[1].strip(), "%m/%d/%Y").strftime("%Y-%m-%d")
        except ValueError:
            from_date, to_date = None, None  # Handle incorrect date format gracefully
    else:
        from_date, to_date = None, None

    context={
        "employee_total_time":employee_total_time,
        "entries_with_details": entries_with_details,
        "client_total_time":client_total_time,
        'entries_with_client_details':entries_with_client_details,
        "total_time":total_time_formatted1,
        "all_clients":all_clients,
        "selected_client_names": selected_client_names,
        'selected_client_ids': selected_client_ids,
        'total_selected_clients':total_selected_clients,
        'from_to_date':from_to_date,
        'from_date':from_date,
        'to_date':to_date,

        "all_employees":all_employees,
        'selected_employee_ids': selected_employee_ids,
        'total_selected_employees':total_selected_employees,
        'selected_option':selected_option,

        "chart_data": {
            "labels": labels,
            "data": data,
        },

        "pie_chart_data": {  # Pie chart data
            "labels1": pie1,
            "data1": pie2,
        },
        "pie_chart_data1": {  # Pie chart data
            "labels2": pie3,
            "data2": pie4,

        },
        "active":active

    }
    return render(request, "report.html", context)

def cal(request):
    return HttpResponse(request.scheme)
    return render(request, "cal.html", {})





def events(request):
    global CLIENT_SECRETS_FILE


    creds = Credentials.from_authorized_user_info(request.session['google_credentials'], SCOPES)
    # Build the service using the authenticated credentials
    service = build('calendar', 'v3', credentials=creds)
    events_result = service.events().list(calendarId='primary', maxResults=10).execute()
    events = events_result.get('items', [])

    # Display events or handle them as needed
    if not events:
        return HttpResponse('No events found.')
    else:
        return render(request, 'events.html', {'events': events})

def check_module(request):
    modules = ["googleapiclient", "google_auth_httplib2", "google_auth_oauthlib"]
    missing_modules = []
    for module in modules:
        try:
            importlib.import_module(module)
        except ImportError:
            missing_modules.append(module)

    if missing_modules:
        message = "The following Google modules are not installed: " + ", ".join(missing_modules)
    else:
        message = "All required Google modules are installed."

    return HttpResponse(message)

@csrf_exempt
@login_required(login_url='/')
def quickbook(request):
    active = [''] * 15
    active[14] = 'active'

    if request.method == 'POST':
        from datetime import datetime, timedelta
        from_to_date = request.POST.get('from_to_date', None)
        print("companies111")
        print(from_to_date)

        # Split the string into "from" and "to" dates
        from_date_str, to_date_str = from_to_date.split(" - ")

        # Convert the date strings to datetime objects
        start_date = datetime.strptime(from_date_str, "%m/%d/%Y").date()
        end_date = datetime.strptime(to_date_str, "%m/%d/%Y").date()

        # Print the formatted dates
        print("From date:", start_date)
        print("To date:", end_date)
        #
        #
        # from datetime import datetime

        # Convert from_date and to_date to strings
        start_date = start_date.strftime('%Y-%m-%d')
        end_date = end_date.strftime('%Y-%m-%d')
        #
        # # Convert start_date_str and end_date_str to datetime objects


        print(start_date)

    else:
        from datetime import datetime, timedelta

        start_date = (datetime.now().replace(day=1) - timedelta(days=1)).replace(day=1).strftime('%Y-%m-%d')
        # for april last
        # end_date = (datetime(2024, 5, 1) - timedelta(days=16)).strftime('%Y-%m-%d')
        end_date = (datetime.now().replace(day=1) - timedelta(days=1)).strftime('%Y-%m-%d')
        print("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$")
        print(start_date)
        print(end_date)

    # Initialize a dictionary to store sums for each month
    sums_by_month = {}
    client_data_for_current_month = []

    # Initialize the current date as the start date
    current_date = start_date

    current_date = datetime.strptime(current_date, "%Y-%m-%d")


        # Initialize the end date
    end_date = datetime.strptime(end_date, "%Y-%m-%d")  # Convert end_date string to d


    # Iterate through each month between start and end dates
    while current_date <= end_date:
        if current_date.month==12:
            next_month = current_date.replace(day=1, month=1,year=current_date.year + 1)
        else:
            next_month = current_date.replace(day=1, month=current_date.month + 1)

        end_of_month = datetime(next_month.year, next_month.month, 1) - timedelta(days=1)
        # Ensure the end date does not exceed the end date of the range
        end_of_month = min(end_of_month, end_date)

        # Get the month and year of the current date
        current_month = current_date.strftime('%m')
        current_year = current_date.strftime('%Y')

        if current_year == '2023' and 9 <= int(current_month) <= 12:
            client_ids_for_current_month = contracted_hours.objects.filter(
                month__month=current_month,
                month__year=current_year
            ).values_list('client_id', flat=True).distinct()


        else:
            client_ids_for_current_month = Client_contract_work.objects.filter(
                date__month=current_month,
                date__year=current_year
            ).values_list('client_id', flat=True).distinct()

        print(client_ids_for_current_month)

        # Create a list to store data for each client


        # Initialize sums for the current month
        sum_of_rates_all_employee = 0.0
        sum_of_contracted_rates_all_employee = 0.0
        sum_one_project_rate = 0.0

        for client_id in client_ids_for_current_month:
            sum_of_rates_employee, contracted_sum_of_rates_employee, one_project_rate,client_id = client_profile2(request, client_id, current_date.strftime('%Y-%m-%d'), end_of_month.strftime('%Y-%m-%d'))

            # Ensure that sum_of_rates_client is a float
            try:
                sum_of_rates_employee = float(sum_of_rates_employee)
                contracted_sum_of_rates_employee = float(contracted_sum_of_rates_employee)
                one_project_rate = float(one_project_rate)
            except ValueError:
                # Handle the case where sum_of_rates_client cannot be converted to a float
                print("Error: Unable to convert sum_of_rates_client to float")
            print("checkingggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggg")
            print(one_project_rate)
            print(sum_of_rates_employee)
            profit=one_project_rate-sum_of_rates_employee
            print(profit)
            contracted_profit=one_project_rate-contracted_sum_of_rates_employee

            # profit=int(profit)
            # print(profit)
            # contracted_profit=int(contracted_profit)
            # one_project_rate=int(one_project_rate)


            profit="{:.2f}".format(profit)
            contracted_profit="{:.2f}".format(contracted_profit)

            try:
                client1 = client.objects.get(id=client_id)
                client_name = client1.client_name
            except client.DoesNotExist:
                # Handle the case where the client with the given ID does not exist
                client_name = None  # Or any other default value or error handling you
            # Store client data for the current month
            client_data_for_current_month.append({
                'client_id': client_id,
                'client_name':client_name,
                'date': current_date.strftime('%Y-%m'),
                'profit': profit,
                'contracted_profit': contracted_profit,
                'one_project_rate': one_project_rate
            })
            # Store client data for the current month

            sum_of_rates_all_employee += sum_of_rates_employee
            sum_of_contracted_rates_all_employee += contracted_sum_of_rates_employee
            sum_one_project_rate += one_project_rate



        profit=sum_one_project_rate-sum_of_rates_all_employee
        contracted_profit=sum_one_project_rate-sum_of_contracted_rates_all_employee

        sum_of_rates_all_employee = "{:.2f}".format(sum_of_rates_all_employee)
        sum_of_contracted_rates_all_employee = "{:.2f}".format(sum_of_contracted_rates_all_employee)
        sum_one_project_rate="{:.2f}".format(sum_one_project_rate)
        profit="{:.2f}".format(profit)
        contracted_profit="{:.2f}".format(contracted_profit)
        #
        # print("profit")
        # print(profit)



        # Store sums for the current month in the dictionary
        sums_by_month[current_date.strftime('%Y-%m')] = {
            'sum_of_rates': sum_of_rates_all_employee,
            'sum_of_contracted_rates': sum_of_contracted_rates_all_employee,
            'earning': sum_one_project_rate,
            'profit':profit,
            'contracted_profit':contracted_profit
        }



        # Move to the next month
        current_date = end_of_month + timedelta(days=1)


    # Calculate totals
    total_earning = 0
    total_profit = 0
    total_contracted_profit = 0

    # Print the sums by month
    for month, sums in sums_by_month.items():
        print(month)
        print(sums['sum_of_rates'])
        print(sums['sum_of_contracted_rates'])
        print(sums['earning'])

        # Calculate totals
        total_earning += float(sums['earning'])
        total_profit += float(sums['profit'])
        total_contracted_profit += float(sums['contracted_profit'])

    # Calculate rounded totals
    total_earning = round(total_earning, 2)
    total_profit = round(total_profit, 2)
    total_contracted_profit = round(total_contracted_profit, 2)



    data = []
    for date, values in sums_by_month.items():
        data.append({
            'date': date,
            'earning': values['earning'],
            'profit': values['profit'],
            'contracted_profit': values['contracted_profit']
        })

    # Add total row
    data.append({
        'date': 'Total',
        'earning': str(total_earning),
        'profit': str(total_profit),
        'contracted_profit': str(total_contracted_profit)
    })
    print(data)

    print(client_data_for_current_month)



    # Pass data to the template context
    context = {
        'data': data,
        'active':active,

        'client_data_for_current_month':client_data_for_current_month
    }



    return render(request, "new.html", context)


@csrf_exempt
@login_required(login_url='/')
def client_profile2(request, client_id,start_date,end_date):
   


    print(start_date)
    print(end_date)

    start_date = datetime.strptime(start_date, '%Y-%m-%d')
    end_date = datetime.strptime(end_date, '%Y-%m-%d')

    # print(start_date)
    # print(end_date)


    # Get the year
    current_year = start_date.year
    current_month=start_date.month
    # month_list = create_month_list(start_date, end_date)
    # print(month_list)

    # Get the start and end months
    start_month = start_date.month
    end_month = end_date.month
    # print(start_month)
    # print(end_month)

    weeks=0
    ui_final_cost={}
    ui_total_hours={}
    ui_formatted_time2={}

    # client_detail = client.objects.get(pk=client_id)
    # toggl_client = client_detail.toggl_client_id
    toggl_client=client_id
    employee_names = {}
    client_details={}
    if current_year == 2023 and 9 <= current_month <= 12:
        employee_details = {}
        print("if")
        print(start_date)
        print(end_date)
        print(current_year)
        print(toggl_client)
        #contracted employee images
        if contracted_hours.objects.filter(client_id=toggl_client).exists():
            # Use the contracted_hours model to query the database
            all = contracted_hours.objects.filter(client_id=toggl_client, month__month__range=(start_month, end_month),month__year=current_year)
            print("rekhaaaa")
            print(all)

            # Check if any records were found
            for record in all:
                # Access the first record in the QuerySet
                first_record = record

                date1=first_record


                date=date1.month

                target_month=date.month
                print(target_month)

                # Access the 'working_input' attribute
                work_json_str = first_record.working_input

                # Parse the JSON string
                work_dict = json.loads(work_json_str)

                # Fetch employee details including image URL based on employee IDs

                for employee_id, hours in work_dict.items():
                    try:
                        # Assuming Employee model has fields 'employee_id', 'first_name', 'last_name', 'user_name', and 'image_url'
                        employee1 = employee.objects.get(toggl_user_id=int(employee_id))

                        # Check if first name and last name are present, otherwise use username
                        if employee1.first_name and employee1.last_name:
                            employee_name = f"{employee1.first_name} {employee1.last_name}"
                        else:
                            employee_name = employee1.user_name

                        # Get the image URL
                        image_url = employee1.image_url if hasattr(employee1, 'image_url') else "/static/assets/img/client/default-profile-pic.jpg"

                        id=employee1.id
                        # Store employee details
                        employee_details[employee_id] = {'name': employee_name, 'image_url': image_url,'id':id}
                    except employee.DoesNotExist:
                        employee_details[employee_id] = {'name': f"Employee {employee_id} not found", 'image_url': "/static/assets/img/client/default-profile-pic.jpg"}
                #client total time contract


                import calendar
                from datetime import datetime
                # Get the number of days in that month

                # print(target_month)
                # print(start_date)
                # print(end_date)
                #
                # print(start_date_str)
                # print(end_date_str)


                target_month_start = start_date.replace(month=target_month, day=1)

                # Ensure that the start date is within the target month
                start_date_in_target_month = max(start_date, target_month_start)
                # print(start_date_in_target_month)
                print("target")
                print(target_month)

                # Get the end date of the target month
                if start_date_in_target_month.month == target_month:
                    # print("if")
                    # If the start date is in the target month, use the end of the month
                    # print("end_date")
                    # print(end_date)
                    print(end_date)
                    print(start_date)
                    print("iffffffffffffffffff")

                    if target_month==12:
                        target_month_end = min(start_date.replace(year=start_date.year +1,month= 1, day=1) - datetime.resolution, end_date)

                    else:
                        target_month_end = min(start_date.replace(month=target_month + 1, day=1) - datetime.resolution, end_date)
                else:
                    # print("else")
                    # If the start date is not in the target month, use the end of the start month
                    target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)

                print(target_month_end)
                # print(target_month_end)
                # Calculate the total days in the target month between the start and end dates
                if target_month_end.month==start_date_in_target_month.month:
                    total_days_between = (target_month_end - start_date_in_target_month).days+1
                else:
                    total_days_between = (target_month_end - start_date_in_target_month).days


                # # Print the total number of days in the specified month between the start and end dates
                # print(f"Total days between {start_date_str} and {end_date_str} in the target month: {total_days_between}")

                date_difference=total_days_between

                days_in_month = calendar.monthrange(date.year, date.month)[1]
                # print(days_in_month)

                # print(days_in_month)

                if date_difference==days_in_month:
                    weeks=4.3
                else:
                    weeks = date_difference / 7

                total_hours1 = float(first_record.total_working_hours) * weeks
                if 'total_time_hours' in client_details:
                    client_details['total_time_hours'] += total_hours1
                else:
                    client_details['total_time_hours'] = total_hours1

                print("rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr")
                print(total_hours1)

                # Convert total hours to total seconds
                total_seconds1 = int(client_details['total_time_hours'] * 3600)

                # Extracting hours, minutes, and seconds
                hoursss1, remainder1 = divmod(total_seconds1, 3600)
                minutes1, seconds1 = divmod(remainder1, 60)

                # Formatting the time
                formatted_time2 = f"{hoursss1:02d}:{minutes1:02d}:{seconds1:02d}"

                import calendar
                from datetime import datetime
                # Calculate the difference between end_date and start_date

                target_month_start = start_date.replace(month=target_month, day=1)

                # Ensure that the start date is within the target month
                start_date_in_target_month = max(start_date, target_month_start)
                # print(start_date_in_target_month)

                # Get the end date of the target month
                if start_date_in_target_month.month == target_month:
                    # print("if")
                    # If the start date is in the target month, use the end of the month
                    # print("end_date")
                    # print(end_date)
                    if target_month==12:
                        target_month_end = min(start_date.replace(year=start_date.year +1,month= 1, day=1) - datetime.resolution, end_date)
                    else:

                        target_month_end = min(start_date.replace(month=target_month + 1, day=1) - datetime.resolution, end_date)
                else:
                    # print("else")
                    # If the start date is not in the target month, use the end of the start month
                    target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                # print(target_month_end)
                # Calculate the total days in the target month between the start and end dates
                print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
                print(start_date_in_target_month)
                print(target_month_end)
                if target_month_end.month==start_date_in_target_month.month:
                    print("if")
                    total_days_between = (target_month_end - start_date_in_target_month).days+1
                else:
                    print("else")
                    total_days_between = (target_month_end - start_date_in_target_month).days


                # # Print the total number of days in the specified month between the start and end dates
                # print(f"Total days between {start_date_str} and {end_date_str} in the target month: {total_days_between}")

                date_difference=total_days_between

                days_in_month = calendar.monthrange(date.year, date.month)[1]

                # print(days_in_month)
                print("differneceeeeeee11")
                print(date_difference)


                if date_difference==days_in_month:
                    weeks=4.3
                    weeks=round(weeks,2)
                    if first_record.rate is None:
                        cost_new=0
                    else:
                        cost_new=first_record.rate

                    print("if--------------------------------------------")
                    print("costtttttttttttttt")
                else:
                    weeks = date_difference / 7
                    weeks=round(weeks,2)
                    if first_record.rate is None:
                        cost_new=0
                    else:
                        c=round((first_record.rate * weeks) , 2)
                        cost_new = round((c) / 4.3, 2)

                if 'cost' in client_details:

                    print(cost_new)
                    client_details['cost'] += cost_new
                    client_details['total_working_hours'] = formatted_time2
                else:

                    client_details['cost'] = cost_new
                    client_details['total_working_hours'] = formatted_time2
                    client_details['total_time_hours']=total_hours1

                client_details['cost']=round(client_details['cost'],2)
                # Print the employee details
                for employee_id, details in employee_details.items():
                    print(f"Employee ID: {employee_id}, Employee Name: {details['name']}, Image URL: {details['image_url']}")
            else:
                print("No records found for the specified client and month.")
        else:
            print("No contracted hours found for the specified client.")

        print(employee_details)
        print(client_details)


        # for work category below boxes
        project_list = project.objects.filter(toggl_client_id=toggl_client)
        print("project_list1")
        print(project_list)
        print("datessssssssssssssssssssssssssss")
        print(start_date)
        print(end_date)
        # Iterate through the project_list and get toggl_project_id for each project
        toggl_project_ids = [project.toggl_project_id for project in project_list]
        filtered_records = toggl_user_detail.objects.filter(
        project_id__in=toggl_project_ids,
        time_entries_start_date__range=(start_date, end_date)
        )
        print(filtered_records)
        unique_project_ids = filtered_records.values('project_id').distinct()
        print(unique_project_ids)

        # Query the Project table to get names of unique project IDs
        project_names = project.objects.filter(toggl_project_id__in=unique_project_ids)
        print("lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll")
        # Now you can display project names on the UI
        print(project_names)

        #working time on toggl

        # Create a dictionary to store the total time spent per client and project
        total_time_spent = {}
        project_rate = {}

        for record in filtered_records:
            # Fetch project details from toggl_project_detail
            project_id_1 = record.project_id

            # project_id_2 = project.objects.filter(toggl_project_id=project_id_1).first()
            # project_id = project_id_2.id
            time_seconds = record.time_entries_seconds

            if project_id_1:
                client_project_key = int(project_id_1)
                if client_project_key in total_time_spent:
                    total_time_spent[client_project_key] += time_seconds
                else:
                    # If the key doesn't exist, create it
                    total_time_spent[client_project_key] = time_seconds
        # Now, total_time_spent dictionary contains the total time spent per client and project
        # You can iterate through it to display the results
        print("client revenue")
        print(total_time_spent)
        print(project_rate)

        total_time_spent_formatted = {}
        for key, seconds in total_time_spent.items():
            hours, remainder = divmod(seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            total_time_spent_formatted[key] = f"{hours:02d}:{minutes:02d}:{seconds:02d}"

        # Now, total_time_spent_formatted dictionary contains the total time spent per client and project in HH:MM:SS format
        # You can iterate through it to display the results
        # print(total_time_spent_formatted)
        for key, formatted_time in total_time_spent_formatted.items():
            print(f"Project {key}: {formatted_time}")


        #project member images on toggl
        project_user_dict_1 = {}

        # Iterate through each project_id
        for project_id in toggl_project_ids:
            # Get unique user_id values for the specified project_id
            user_ids = toggl_user_detail.objects.filter(
                project_id=project_id,
                time_entries_start_date__range=(start_date, end_date)
            ).values_list('user_id', flat=True).distinct()

            # Assign the user_ids to the dictionary with project_id as the key
            project_user_dict_1[project_id] = list(user_ids)

        print("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5")
        print(project_user_dict_1)

        project_user_dict={}

        for project_id, user_ids in project_user_dict_1.items():
            # Initialize a dictionary to store total time spent by each employee on the current project
            total_time_spent_per_project = {}

            for user_id in user_ids:
                # Calculate total time spent by the current user on the current project
                total_time_spent_per_project[user_id] = toggl_user_detail.objects.filter(
                    user_id=user_id,
                    project_id=project_id,
                    time_entries_start_date__range=(start_date, end_date)
                ).aggregate(total_time_spent=Sum('time_entries_seconds'))['total_time_spent'] or 0

            # Fetch employee data for the current project
            employees_data = employee.objects.filter(toggl_user_id__in=user_ids).values('id', 'first_name',
                                                                                        'last_name', 'salary',
                                                                                        'image_url', 'user_name','toggl_user_id').distinct()

            # Update project_user_dict with image_urls, full names, and total time spent for each project_id
            project_user_dict[project_id] = [
                {
                    'id': data['id'],
                    'salary': float(data['salary']),
                    'image_url': data['image_url'],
                    'full_name': f"{data['first_name']} {data['last_name']}",
                    'user_name': data['user_name'],
                    'toggl_user_id': data['toggl_user_id'],
                    'total_time_spent_per_project': total_time_spent_per_project.get(data['toggl_user_id'], 0)
                    # Retrieve total time spent for each employee on the current project
                }
                for data in employees_data]

        print(project_user_dict)


        employee_rate_per_hour = {}

        for project_id, employee_data in project_user_dict.items():
            total_project_cost = 0
            for employee_info in employee_data:
                # Calculate employee's hourly rate
                working_days_per_month = 22
                hours_per_day = 8
                hourly_rate = employee_info['salary'] / (working_days_per_month * hours_per_day)  # Assuming 22 working days and 8 working hours per day
                # Calculate total cost for the employee on the project
                employee_cost = hourly_rate * (employee_info['total_time_spent_per_project'] / 3600)  # Convert seconds to hours
                total_project_cost += employee_cost

            # Store total project cost in the dictionary
            total_project_cost = "{:.2f}".format(total_project_cost)
            employee_rate_per_hour[project_id] = total_project_cost
        print("new cost")
        print(employee_rate_per_hour)

        # Initialize a variable to store the sum of rates
        sum_of_rates_employee = 0.0

        # Iterate through the "Project Rate per Hour" dictionary and add up the rates
        for project_id, rate in employee_rate_per_hour.items():
            sum_of_rates_employee += float(rate)

        # Format total_rate to have 2 decimal places
        sum_of_rates_employee = "{:.2f}".format(sum_of_rates_employee)
        # Print the sum of rates
        print("Sum of Rates Employee:", sum_of_rates_employee)



        #client revenue

        toggl_client = client_id


        if contracted_hours.objects.filter(client_id=toggl_client,month__month__range=[start_month, end_month],month__year=current_year).exists():
        # Filter contracted hours for the project and current month
            contracted_hours_for_month = contracted_hours.objects.filter(client_id= toggl_client,month__month__range=[start_month, end_month],month__year=current_year
                )

            print("88888888888888888888888888888888888888888888888")
            print(contracted_hours_for_month)
            # first_contracted_hour = contracted_hours_for_month.first()
            one_project_rate=0
            for entry in contracted_hours_for_month:

                date1=entry
                # print(date)

                date=date1.month

                target_month=date.month
                # print(target_month)

                print(target_month)

                import calendar
                from datetime import datetime
                # Calculate the difference between end_date and start_date
                target_month_start = start_date.replace(month=target_month, day=1)

                # Ensure that the start date is within the target month
                start_date_in_target_month = max(start_date, target_month_start)
                # print(start_date_in_target_month)

                # Get the end date of the target month
                if start_date_in_target_month.month == target_month:
                    # print("if")
                    # # If the start date is in the target month, use the end of the month
                    # print("end_date")
                    # print(end_date)
                    if target_month==12:
                        target_month_end = min(start_date.replace(year=start_date.year +1,month= 1, day=1) - datetime.resolution, end_date)

                    else:
                        target_month_end = min(start_date.replace(month=target_month + 1, day=1) - datetime.resolution, end_date)
                else:
                    print("else")
                    # If the start date is not in the target month, use the end of the start month
                    target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                print(target_month_end)
                # Calculate the total days in the target month between the start and end dates
                if target_month_end.month==start_date_in_target_month.month:
                    total_days_between = (target_month_end - start_date_in_target_month).days+1
                else:
                    total_days_between = (target_month_end - start_date_in_target_month).days

                date_difference=total_days_between

                # Get the number of days in that month
                days_in_month = calendar.monthrange(date.year, date.month)[1]

                # print(days_in_month)
                if one_project_rate is None:
                    one_project_rate=0
                elif one_project_rate:
                    if date_difference==days_in_month:
                        weeks=4.3
                        weeks=round(weeks,2)
                        if entry.rate is None:
                            one_project_rate=0
                        else:
                            one_project_rate+=entry.rate
                        print("if")
                    else:
                        weeks = date_difference / 7
                        weeks=round(weeks,2)
                        if entry.rate is None:
                            one_project_rate=0
                        else:
                            one_project_rate +=round((entry.rate * weeks) / 4.3, 2)
                        print("else")
                else:
                    if date_difference==days_in_month:
                        weeks=4.3
                        weeks=round(weeks,2)
                        if entry.rate is None:
                            one_project_rate=0
                        else:
                            one_project_rate=entry.rate
                        print("ifff2")
                    else:
                        weeks = date_difference / 7
                        weeks=round(weeks,2)
                        if entry.rate is None:
                            one_project_rate=0
                        else:
                            one_project_rate = round((entry.rate * weeks) / 4.3, 2)
                        print("else222")


            # one_project_rate = first_contracted_hour.cost
        else:
            one_project_rate=0


        one_project_rate=round(one_project_rate,2)
        print("kajal")
        print("Sum of Rates Client revenue:", one_project_rate)
        #new contracted
        employee_salary_dict={}
        emp_id=0
        if contracted_hours.objects.filter(client_id=toggl_client,month__month__range=[start_month, end_month],month__year=current_year).exists():
            contracted_client1 = contracted_hours.objects.filter(client_id=toggl_client,month__year=current_year,month__month__range=[start_month, end_month])
            # contracted_client = contracted_hours.objects.get(client_id=client_id1,month=current_month)

            for contracted_client in contracted_client1:
                date1=contracted_client
                # print(date)

                date=date1.month

                target_month=date.month
                # print(target_month)

                print(target_month)
                import ast
                from decimal import Decimal
                import calendar
                from datetime import datetime
                target_month_start = start_date.replace(month=target_month, day=1)

                # Ensure that the start date is within the target month
                start_date_in_target_month = max(start_date, target_month_start)
                # print(start_date_in_target_month)

                # Get the end date of the target month
                if start_date_in_target_month.month == target_month:
                    # print("if")
                    # # If the start date is in the target month, use the end of the month
                    # print("end_date")
                    # print(end_date)
                    if target_month==12:
                        target_month_end = min(start_date.replace(year=start_date.year +1,month= 1, day=1) - datetime.resolution, end_date)
                    else:

                        target_month_end = min(start_date.replace(month=target_month + 1, day=1) - datetime.resolution, end_date)
                else:
                    print("else")
                    # If the start date is not in the target month, use the end of the start month
                    target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                print(target_month_end)
                # Calculate the total days in the target month between the start and end dates
                if target_month_end.month==start_date_in_target_month.month:
                    total_days_between = (target_month_end - start_date_in_target_month).days+1
                else:
                    total_days_between = (target_month_end - start_date_in_target_month).days


                # Print the total number of days in the specified month between the start and end dates
                # print(f"Total days between {start_date_str} and {end_date_str} in the target month: {total_days_between}")

                date_difference=total_days_between

                # Get the number of days in that month
                days_in_month = calendar.monthrange(date.year, date.month)[1]

                print(days_in_month)

                if date_difference==days_in_month:
                    weeks=4.3
                else:
                    weeks = date_difference / 7
                print(date_difference)
                print("###########################")
                print(weeks)

                contracted_working_hours_1 = contracted_client.working_input
                print(contracted_working_hours_1)
                contracted_hours_for_project=contracted_client.total_working_hours
                print("contracted")
                print(contracted_hours_for_project)
                    # Convert the JSON string to a dictionary
                contracted_working_hours_1_dict1 = json.loads(contracted_working_hours_1)
                print('muksn')
                print(contracted_working_hours_1_dict1)
                contracted_working_hours_1_dict = {key.strip(): value for key, value in contracted_working_hours_1_dict1.items()}
                # Fetch the hourly rate for the user from the Employee table
                employee_ids = list(contracted_working_hours_1_dict.keys())
                print(employee_ids)
                # Fetch hourly rate for each employee
                hourly_rates = {}
                hourly_rate=0
                for emp_id in employee_ids:
                    try:
                        employee1 = employee.objects.get(toggl_user_id=emp_id)
                        hourly_rates[emp_id] = employee1.salary
                        print("salary")
                        print(hourly_rates[emp_id])

                    except employee.DoesNotExist:
                        print(f"Employee with ID {emp_id} not found.")

                # Calculate total salary
                total_salary = sum(hourly_rates[emp_id] for emp_id in employee_ids)
                print(total_salary)



                if contracted_hours_for_project != 0:
                    print("calculation")
                    print(total_salary)
                    print(contracted_hours_for_project)
                    hourly_rate1 = float(total_salary) / (22*8)
                    print(hourly_rate1)
                    hourly_rate=hourly_rate1 * contracted_hours_for_project * weeks
                    print(hourly_rate)

                else:
                    contracted_hours_for_project = 0
                    total_salary=0
                    hourly_rate = 0

                if int(emp_id) in employee_salary_dict:
                        print("ifff")
                        # If it exists, add the new salary to the existing one
                        employee_salary_dict[int(emp_id)] += hourly_rate
                        employee_salary_dict[int(emp_id)] = round(employee_salary_dict[int(emp_id)], 2)

                else:
                    print("else")
                    # If it doesn't exist, create a new entry
                    employee_salary_dict[int(emp_id)] = hourly_rate
                    employee_salary_dict[int(emp_id)] = round(employee_salary_dict[int(emp_id)], 2)


        contracted_sum_of_rates_employee=0.0
        # Convert all values in employee_salary_dict to float
        employee_salary_dict = {k: float(v) for k, v in employee_salary_dict.items()}

        # Sum the values in employee_salary_dict
        contracted_sum_of_rates_employee = sum(employee_salary_dict.values())
        contracted_sum_of_rates_employee = "{:.2f}".format(contracted_sum_of_rates_employee)
        print("Total contracted sum of rates for employees:", contracted_sum_of_rates_employee)


        client_category_list={}
        employee_info_dict={}
        category_time_dict={}
        category_cost_dict={}

        category_time_dict_client={}
        employee_data={}
        employee_salary_dict={}

        client_id1=client.objects.filter(toggl_client_id=toggl_client).first()
        client_id=client_id1.id


    else:

        employee_details = {}
        client_details={}
        ui_client_data=[]

        if Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month]).exists():
                # Use the contracted_hours model to query the database
            all = Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month])


            # Check if any records were found
            # Iterate over each record in the queryset
            for record in all:

                # Access the current record in the queryset
                first_record = record
                # print(first_record)

                ui_final_cost=first_record.cost
                # print(ui_final_cost)

                date1=first_record

                date=date1.date

                target_month=date.month
                # print(target_month)

                # Access the 'working_input' attribute
                work_json_str = first_record.working_input

                # Parse the JSON string
                work_dict = json.loads(work_json_str)

                # Access the 'working_role' attribute
                role_json_str = first_record.working_role

                # Parse the JSON string for role information
                role_dict = json.loads(role_json_str)

                # Fetch employee details including image URL based on employee IDs

                for employee_id, hours in work_dict.items():
                    try:
                        # Assuming Employee model has fields 'employee_id', 'first_name', 'last_name', 'user_name', and 'image_url'
                        employee1 = employee.objects.get(id=int(employee_id))

                        # Check if first name and last name are present, otherwise use username
                        if employee1.first_name and employee1.last_name:
                            employee_name = f"{employee1.first_name} {employee1.last_name}"
                        else:
                            employee_name = employee1.user_name

                        # Get the image URL
                        image_url = employee1.image_url if hasattr(employee1, 'image_url') else "/static/assets/img/client/default-profile-pic.jpg"

                        id=employee1.id
                        salary=employee1.salary
                        # Store employee details
                        # Get the role
                        role = role_dict.get(employee_id, "Unknown")

                        target_month_start = start_date.replace(month=target_month, day=1)

                        # Ensure that the start date is within the target month
                        start_date_in_target_month = max(start_date, target_month_start)
                        # print(start_date_in_target_month)

                        # Get the end date of the target month
                        if start_date_in_target_month.month == target_month:

                            if target_month == 12:
                                next_month_date = start_date.replace(year=start_date.year + 1, month=1, day=1)
                            else:
                                next_month_date = start_date.replace(month=target_month + 1, day=1)

                            # Calculate target month end
                            target_month_end = min(next_month_date - timedelta(days=1), end_date)
                        
                        else:
                            # print("else")
                            # If the start date is not in the target month, use the end of the start month
                            target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                        print(target_month_end)
                        # Calculate the total days in the target month between the start and end dates
                        if target_month_end.month==start_date_in_target_month.month:
                            total_days_between = (target_month_end - start_date_in_target_month).days+1
                        else:
                            total_days_between = (target_month_end - start_date_in_target_month).days


                        # Print the total number of days in the specified month between the start and end dates
                        # print(f"Total days between {start_date_str} and {end_date_str} in the target month: {total_days_between}")

                        date_difference=total_days_between
                        # Get the number of days in that month
                        days_in_month = calendar.monthrange(date.year, date.month)[1]

                        # print(days_in_month)

                        if date_difference==days_in_month:
                            weeks=4.3
                        else:
                            weeks = date_difference / 7



                        # Convert hours to an integer
                        hours = float(hours)


                        if int(employee_id) in employee_details:

                            # print("777777777777777777777777777777777777")
                            # print(hours)

                            employee_details[int(employee_id)]['total_hours'] += hours
                            total_hours = float(employee_details[int(employee_id)]['total_hours'])  * weeks
                        else:
                            total_hours = float(hours)  * weeks

                        total_seconds = int(total_hours * 3600)

                        # Extracting hours, minutes, and seconds
                        hoursss, remainder = divmod(total_seconds, 3600)
                        minutes, seconds = divmod(remainder, 60)

                        # Formatting the time
                        formatted_time = f"{hoursss:02d}:{minutes:02d}:{seconds:02d}"

                        if int(employee_id) in employee_details:
                            new_role = role_dict.get(employee_id)
                            # Use set to avoid duplicates
                            current_roles = set(employee_details[int(employee_id)]['role'])
                            if new_role not in current_roles:
                                # Convert back to list after ensuring it's not already a list
                                employee_details[int(employee_id)]['role'] = list(current_roles | {new_role})

                            # Add hours worked to existing hours
                            employee_details[int(employee_id)]['hours_worked'] = formatted_time
                        else:
                            employee_details[int(employee_id)] = {'name': employee_name, 'image_url': image_url,'id':id,'salary':salary,'role': role,'hours_worked':formatted_time,'total_hours':hours}
                    except employee.DoesNotExist:
                        employee_details[int(employee_id)] = {'name': f"Employee {employee_id} not found", 'image_url': "/static/assets/img/client/default-profile-pic.jpg"}
                #client total time contract
                if first_record.total_working_hours:

                    target_month_start = start_date.replace(month=target_month, day=1)

                    # Ensure that the start date is within the target month
                    start_date_in_target_month = max(start_date, target_month_start)
                    # print(start_date_in_target_month)

                    # Get the end date of the target month
                    if start_date_in_target_month.month == target_month:
 
                        if target_month == 12:
                            next_month_date = start_date.replace(year=start_date.year + 1, month=1, day=1)
                        else:
                            next_month_date = start_date.replace(month=target_month + 1, day=1)

                        # Calculate target month end
                        target_month_end = min(next_month_date - timedelta(days=1), end_date)                        
                    else:
                        # print("else")
                        # If the start date is not in the target month, use the end of the start month
                        target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                    # print(target_month_end)
                    # Calculate the total days in the target month between the start and end dates
                    if target_month_end.month==start_date_in_target_month.month:
                        total_days_between = (target_month_end - start_date_in_target_month).days+1
                    else:
                        total_days_between = (target_month_end - start_date_in_target_month).days

                    date_difference=total_days_between

                    days_in_month = calendar.monthrange(date.year, date.month)[1]
                    # print(days_in_month)

                    # print(days_in_month)

                    if date_difference==days_in_month:
                        weeks=4.3
                    else:
                        weeks = date_difference / 7
                    total_hours1 = float(first_record.total_working_hours) * weeks
                    ui_total_hours=first_record.total_working_hours
                else:
                    total_hours1 = 0
                    ui_total_hours=0

                # print("rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr/////////////////////////////////")

                if 'total_time_hours' in client_details:
                    client_details['total_time_hours'] += total_hours1
                else:
                    client_details['total_time_hours'] = total_hours1


                # Convert total hours to total seconds
                total_seconds1 = int(client_details['total_time_hours'] * 3600)

                # Extracting hours, minutes, and seconds
                hoursss1, remainder1 = divmod(total_seconds1, 3600)
                minutes1, seconds1 = divmod(remainder1, 60)



                target_month_start = start_date.replace(month=target_month, day=1)

                # Ensure that the start date is within the target month
                start_date_in_target_month = max(start_date, target_month_start)
                # print(start_date_in_target_month)

                # Get the end date of the target month
                if start_date_in_target_month.month == target_month:

                    if target_month == 12:
                        next_month_date = start_date.replace(year=start_date.year + 1, month=1, day=1)
                    else:
                        next_month_date = start_date.replace(month=target_month + 1, day=1)

                    # Calculate target month end
                    target_month_end = min(next_month_date - timedelta(days=1), end_date)
                else:
                    # print("else")
                    # If the start date is not in the target month, use the end of the start month
                    target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)

                if target_month_end.month==start_date_in_target_month.month:
                    # print("if")
                    total_days_between = (target_month_end - start_date_in_target_month).days+1
                else:
                    # print("else")
                    total_days_between = (target_month_end - start_date_in_target_month).days


    
                date_difference=total_days_between

                days_in_month = calendar.monthrange(date.year, date.month)[1]
                if date_difference==days_in_month:
                    weeks=4.3
                    weeks=round(weeks,2)
                    cost_new=first_record.cost
                else:
                    weeks = date_difference / 7
                    weeks=round(weeks,2)
                    c=round((first_record.cost * weeks) , 2)
                    cost_new = round((c) / 4.3, 2)

                # Formatting the time
                formatted_time2 = f"{hoursss1:02d}:{minutes1:02d}:{seconds1:02d}"
                ui_formatted_time2=formatted_time2
     

                if 'cost' in client_details:
                    client_details['cost'] += cost_new
                    client_details['total_working_hours'] = formatted_time2
                else:
                    client_details['cost'] = cost_new
                    client_details['total_working_hours'] = formatted_time2
                    client_details['total_time_hours']=total_hours1

                client_details['cost']=round(client_details['cost'],2)
                ui_client_data1 = {

                        'ui_cost': first_record.cost,
                        'ui_weeks': weeks
                    }

                    # Append this dictionary to the list
                ui_client_data.append(ui_client_data1)
                # client_details = {'cost': cost_new,'total_working_hours':formatted_time2}
                # Print the employee details
                # for employee_id, details in employee_details.items():
                #     print(f"Employee ID: {employee_id}, Employee Name: {details['name']}, Image URL: {details['image_url']}")
        else:
            print("No contracted hours found for the specified client.")
        # print("ghhhhh")

        # print(client_details)

        #new clients tab on client



        #end of clients tab

        # for work category below boxes
        # Assuming your models are imported and project_list is obtained as in your code

        # Get unique category IDs for a specific client
        unique_category_ids = timeSheet.objects.filter(client_id=client_id,time_entries_start_date__range=(start_date, end_date)).values('category_id').distinct()

        # Prepare a list to store client and category information
        client_category_list = []

        # Iterate over unique category IDs and fetch corresponding category names
        for unique_category_id in unique_category_ids:

            category_id = unique_category_id['category_id']

            # Fetch the corresponding category name from the WorkCategory table
            try:


                category_1 = Work_Category.objects.get(id=category_id)
                category_name = category_1.category

                # Append client and category information to the list
                client_category_list.append({'id': category_id, 'category_name': category_name})

            except Work_Category.DoesNotExist:
                print(f"Category with ID {category_id} does not exist in the WorkCategory table.")

        # Now client_category_list contains client IDs and corresponding category names
        # You can use this list to pass information to your UI or perform further processing
        # print("client_category_list")
        # print(client_category_list)

       # project member of timer
        # Get unique timeSheet entries for a specific client
        unique_timesheet_entries = timeSheet.objects.filter(client_id=client_id,time_entries_start_date__range=(start_date, end_date)).values('category_id', 'employee_id').distinct()

        # Prepare a dictionary to store employee information
        employee_info_dict = {}

        # Iterate over unique timeSheet entries
        for timesheet_entry in unique_timesheet_entries:
            category_id = timesheet_entry['category_id']
            employee_id = timesheet_entry['employee_id']

            # Fetch the employee from the Employee table
            try:
                employee1 = employee.objects.get(id=employee_id)
                employee_name = f"{employee1.first_name} {employee1.last_name}"
                employee_image_url = employee1.image_url
                employee_salary = employee1.salary

                # Check if the category exists in the dictionary, if not, create an entry
                if category_id not in employee_info_dict:
                    employee_info_dict[category_id] = []

                # Append employee information to the dictionary
                employee_info_dict[category_id].append({
                    'id': employee_id,
                    'name': employee_name,
                    'image_url': employee_image_url,
                    'salary':employee_salary
                })

            except employee.DoesNotExist:
                print(f"Employee with ID {employee_id} does not exist in the Employee table.")

        # Now employee_info_dict contains information about employees in each category
        # You can use this dictionary to look up employees based on the category
        # print("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk")
        # print(employee_info_dict)

        #working time for timer
        # Calculate total time spent for all distinct category_id values for the given client_id
        # total_time_spent_by_category = timeSheet.objects.filter(client_id=client_id) \
        #                                                .values('category_id') \
        #                                                .annotate(total_time=Sum('time_entries_seconds'))

        total_time_spent_by_category = timeSheet.objects.filter(client_id=client_id,
                                                        time_entries_start_date__gte=start_date,
                                                        time_entries_stop_date__lte=end_date) \
                                                 .values('category_id') \
                                                 .annotate(total_time=Sum('time_entries_seconds'))

        # Create a dictionary to store category_id and total time spent
        category_time_dict = {}

        # Loop through the results to populate the dictionary
        for entry in total_time_spent_by_category:
            category_id = entry['category_id']
            total_time_spent_seconds = entry['total_time']

            # Convert total_time_spent_seconds to a more readable format
            total_time_spent_hours, remainder = divmod(total_time_spent_seconds, 3600)
            total_time_spent_minutes, total_time_spent_seconds = divmod(remainder, 60)

            # Store the values in the dictionary
            category_time_dict[category_id] = {
                'formatted_time': f"{total_time_spent_hours:02d}:{total_time_spent_minutes:02d}:{total_time_spent_seconds:02d}",
                'total_time_seconds':entry['total_time'],
                'hours': total_time_spent_hours,
                'minutes': total_time_spent_minutes,
                'seconds': total_time_spent_seconds
            }

        # # Print or use the category_time_dict as needed
        # print(category_time_dict)

        # print("kiki")
        total_time_spent_by_client = timeSheet.objects.filter(
        client_id=client_id,
        time_entries_start_date__gte=start_date,  # Filter based on start date
        time_entries_stop_date__lte=end_date     # Filter based on end date
        ).values('client_id', 'employee_id').annotate(total_time=Sum('time_entries_seconds'))
        # print(total_time_spent_by_client)
        # Create a dictionary to store category_id and total time spent
        category_time_dict_client = {}

        # Loop through the results to populate the dictionary
        for entry in total_time_spent_by_client:
            employee_id = entry['employee_id']
            client_id = entry['client_id']
            total_time_spent_seconds = entry['total_time']

            # Convert total_time_spent_seconds to a more readable format
            total_time_spent_hours, remainder = divmod(total_time_spent_seconds, 3600)
            total_time_spent_minutes, total_time_spent_seconds = divmod(remainder, 60)

            # Store the values in the dictionary
            category_time_dict_client[employee_id] = {
                'formatted_time': f"{total_time_spent_hours:02d}:{total_time_spent_minutes:02d}:{total_time_spent_seconds:02d}",
                'total_time_seconds':entry['total_time'],
                'client_id':entry['client_id'],
                'hours': total_time_spent_hours,
                'minutes': total_time_spent_minutes,
                'seconds': total_time_spent_seconds
            }
        # print(category_time_dict_client)

        if Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month]).exists():
                # Use the contracted_hours model to query the database
            all = Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month])
            # print("lllllllllllllllllllllllllllllllll")
            # print(all)

            # Check if any records were found
            # Iterate over each record in the queryset
            for record in all:
                # print("ppppppppppppppppppppppppppppppppppppppppppppp")
                # Access the current record in the queryset
                first_record = record
                # print(first_record)

                # Access the 'working_input' attribute
                work_json_str = first_record.working_input

                # Parse the JSON string
                work_dict = json.loads(work_json_str)

                # print("jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj")
                # print(work_dict)
                for employee_id in work_dict.keys():
                    if int(employee_id) not in category_time_dict_client:
                        category_time_dict_client[int(employee_id)] = {
                            'formatted_time': '00:00:00',
                            'total_time_seconds': 0,
                            'client_id': '',  # You may set this to appropriate default value
                            'hours': 0,
                            'minutes': 0,
                            'seconds': 0
                        }

        # Print or use the category_time_dict as needed
        # print("birth")
        # print(category_time_dict_client)
        # print(category_time_dict)

        #employee cost in task tab

        # print("employeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee")
        # print(employee_info_dict)
        # Create a dictionary to store category_id and total cost
        category_cost_dict = {}

        # Iterate over the categories in employee_info_dict
        for category_id, employees in employee_info_dict.items():
            total_salary = 0

            # Calculate total salary for employees in the category
            for employee_info in employees:
                if employee_info['salary']:
                    total_salary += float(employee_info['salary'])  # Convert Decimal to float

            # Calculate cost per hour
            cost_per_hour = total_salary / (22 * 8)
            # print("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")
            # print(cost_per_hour)

            # Fetch total time spent for the category from category_time_dict
            total_time_seconds = category_time_dict.get(category_id, {}).get('total_time_seconds', 0)

            # Convert Decimal to float for total_cost calculation and round to 2 decimal places
            # total_cost = round(float((total_time_seconds / 3600) * cost_per_hour), 2)
            yoo=float(total_time_seconds / 3600)
            # print(yoo)

            total_cost=round(cost_per_hour*yoo,2)

            # Store the values in the category_cost_dict
            category_cost_dict[category_id] = {
                'total_cost': total_cost,
                # 'cost_per_hour': cost_per_hour,
                # 'total_time_seconds': total_time_seconds
            }

        # Print or use the category_cost_dict as needed
        # print("ppppppppppppppppppppppppppppppppppppppppppppppp")
        # print(category_cost_dict)

        #employee cost in client tab   $$$$$$$$$$$$$$$$$$$$$$$$$$
        # Get unique timeSheet entries for a specific client
        timesheets = timeSheet.objects.filter(client_id=client_id,time_entries_start_date__range=(start_date, end_date))

        # Dictionary to store employee IDs and their total time worked
        employee_data = {}
        ui={}
        from decimal import Decimal
        # Calculate total time worked by each employee for the client
        for timesheet1 in timesheets:
            employee_id = timesheet1.employee_id
            time_worked_seconds = timesheet1.time_entries_seconds

            # Update total time worked for the employee
            if employee_id in employee_data:
                employee_data[employee_id]['time_worked'] += time_worked_seconds
            else:
                employee_data[employee_id] = {'time_worked': time_worked_seconds, 'salary': 0}

        if Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month]).exists():
                # Use the contracted_hours model to query the database
            all = Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month])
            # print("lllllllllllllllllllllllllllllllll")
            # print(all)

            # Check if any records were found
            # Iterate over each record in the queryset
            for record in all:
                # print("ppppppppppppppppppppppppppppppppppppppppppppp")
                # Access the current record in the queryset
                first_record = record
                # print(first_record)

                # Access the 'working_input' attribute
                work_json_str = first_record.working_input

                # Parse the JSON string
                work_dict = json.loads(work_json_str)
                for employee_id in work_dict.keys():
                    if int(employee_id) not in employee_data:
                        employee_data[int(employee_id)] = {'time_worked': 0, 'salary': 0}

        for employee_id in employee_data.keys():
            employee1 = employee.objects.get(id=employee_id)

            if employee1.salary:
                employee_data[employee_id]['salary'] = employee1.salary
                adjusted_salary = float(employee1.salary) / (22 * 8)
                salary=employee1.salary
            else:
                employee_data[employee_id]['salary']=0
                adjusted_salary = 0
                salary=0

            time_worked_hours = employee_data[employee_id]['time_worked'] / 3600

            if employee1.first_name and employee1.last_name:
                name=employee1.first_name + ' ' + employee1.last_name
            else:
                name=employee1.user_name


            ui[str(employee_id)] = {
                        'ui_employee_name':name,
                        'ui_employee_salary': salary,
                        'ui_working_hours': time_worked_hours
                    }
            # print("new@@@@@@@@@@@")
            # print(adjusted_salary)
            # print(time_worked_hours)
            # Multiply adjusted salary and time worked
            total_payment = adjusted_salary * time_worked_hours
            total_payment = round(total_payment,2)
            # Update employee_data with total_payment
            employee_data[employee_id]['total_payment'] = total_payment
        # print("qqqqqqqqqqqqqqqqqq")
        # print(employee_data)

        # print(ui)
       # end employee cost in client tab $$$$$$$$$$$$$$$$$$
       #  print("vedansh")
       #  print(category_cost_dict)


       # Initialize a variable to store the sum of rates
        sum_of_rates_employee = 0.0  # Initialize the variable to store the sum of all costs

        # Iterate over the categories in category_cost_dict
        # for category_id, category_cost_info in category_cost_dict.items():
        #     # Add the total_cost for the current category to the sum
        #     sum_of_rates_employee += category_cost_info['total_cost']

        sum_of_rates_employee = sum(employee['total_payment'] for employee in employee_data.values())
        # print("Total payment sum:",  sum_of_rates_employee)

        # Format the sum_of_rates_employee as a string with two decimal places when printing
        sum_of_rates_employee= "{:.2f}".format(sum_of_rates_employee)

        # Print or use the sum_of_rates_employee_str as needed
        # print("Sum of all costs:", sum_of_rates_employee)




        #client revenue
        client_detail = client.objects.get(pk=client_id)
        client_id= client_detail.id
        # print(start_month)
        # print(end_month)
        if Client_contract_work.objects.filter(client_id=client_id,date__month__range=[start_month, end_month],date__year=current_year).exists():
        # Filter contracted hours for the project and current month
            contracted_hours_for_month = Client_contract_work.objects.filter(client_id= client_id,date__month__range=[start_month, end_month],date__year=current_year
                )

            # print("88888888888888888888888888888888888888888888888")
            # print(contracted_hours_for_month)
            # first_contracted_hour = contracted_hours_for_month.first()
            one_project_rate=0
            for entry in contracted_hours_for_month:

                date1=entry
                # print(date)

                date=date1.date

                target_month=date.month
                # print(target_month)

                # print(target_month)

                import calendar
                from datetime import datetime
                # Calculate the difference between end_date and start_date
                target_month_start = start_date.replace(month=target_month, day=1)

                # Ensure that the start date is within the target month
                start_date_in_target_month = max(start_date, target_month_start)
                # print(start_date_in_target_month)

                # Get the end date of the target month
                if start_date_in_target_month.month == target_month:
                    # print("if")
                    # # If the start date is in the target month, use the end of the month
                    # print("end_date")
                    # print(end_date)
                    if target_month == 12:
                        next_month_date = start_date.replace(year=start_date.year + 1, month=1, day=1)
                    else:
                        next_month_date = start_date.replace(month=target_month + 1, day=1)

                    # Calculate target month end
                    target_month_end = min(next_month_date - timedelta(days=1), end_date)
                else:
                    # print("else")
                    # If the start date is not in the target month, use the end of the start month
                    target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                # print(target_month_end)
                # Calculate the total days in the target month between the start and end dates
                if target_month_end.month==start_date_in_target_month.month:
                    total_days_between = (target_month_end - start_date_in_target_month).days+1
                else:
                    total_days_between = (target_month_end - start_date_in_target_month).days


                # # Print the total number of days in the specified month between the start and end dates
                # print(f"Total days between {start_date_str} and {end_date_str} in the target month: {total_days_between}")

                date_difference=total_days_between

                # Get the number of days in that month
                days_in_month = calendar.monthrange(date.year, date.month)[1]

                # print(days_in_month)
                if one_project_rate:
                    if date_difference==days_in_month:
                        weeks=4.3
                        weeks=round(weeks,2)
                        # print(entry.cost)
                        one_project_rate+=entry.cost
                        # print("if")
                    else:
                        weeks = date_difference / 7
                        weeks=round(weeks,2)
                        one_project_rate +=round((entry.cost * weeks) / 4.3, 2)
                        # print("else")
                else:
                    if date_difference==days_in_month:
                        weeks=4.3
                        weeks=round(weeks,2)
                        # print(entry.cost)
                        one_project_rate=entry.cost
                        # print("ifff2")
                    else:
                        weeks = date_difference / 7
                        weeks=round(weeks,2)
                        one_project_rate = round((entry.cost * weeks) / 4.3, 2)
                        # print("else222")


            # one_project_rate = first_contracted_hour.cost
        else:
            one_project_rate=0


        one_project_rate=round(one_project_rate,2)
        # print("kajal")
        # print("Sum of Rates Client revenue:", one_project_rate)

        #contracted employee cost
        employee_salary_dict = {}
        ui_data=[]

        if Client_contract_work.objects.filter(client_id=client_id,date__month__range=[start_month, end_month],date__year=current_year).exists():
            contracted_client1 = Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month])
            # contracted_client = contracted_hours.objects.get(client_id=client_id1,month=current_month)

            for contracted_client in contracted_client1:

                date1=contracted_client
                # print(date)

                date=date1.date

                target_month=date.month
                # print(target_month)
                #
                # print(target_month)
                import ast
                from decimal import Decimal
                import calendar
                from datetime import datetime
                target_month_start = start_date.replace(month=target_month, day=1)

                # Ensure that the start date is within the target month
                start_date_in_target_month = max(start_date, target_month_start)
                # print(start_date_in_target_month)

                # Get the end date of the target month
                if start_date_in_target_month.month == target_month:
                    # print("if")
                    # # If the start date is in the target month, use the end of the month
                    # print("end_date")
                    # print(end_date)

                    if target_month == 12:
                        next_month_date = start_date.replace(year=start_date.year + 1, month=1, day=1)
                    else:
                        next_month_date = start_date.replace(month=target_month + 1, day=1)

                    # Calculate target month end
                    target_month_end = min(next_month_date - timedelta(days=1), end_date)
                else:
                    # print("else")
                    # If the start date is not in the target month, use the end of the start month
                    target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                # print(target_month_end)
                # Calculate the total days in the target month between the start and end dates
                if target_month_end.month==start_date_in_target_month.month:
                    total_days_between = (target_month_end - start_date_in_target_month).days+1
                else:
                    total_days_between = (target_month_end - start_date_in_target_month).days


                # Print the total number of days in the specified month between the start and end dates
                # print(f"Total days between {start_date_str} and {end_date_str} in the target month: {total_days_between}")

                date_difference=total_days_between

                # Get the number of days in that month
                days_in_month = calendar.monthrange(date.year, date.month)[1]

                # print(days_in_month)

                if date_difference==days_in_month:
                    weeks=4.3
                else:
                    weeks = date_difference / 7
                # print(date_difference)
                # print("###########################")
                # print(weeks)

                contracted_working_hours_1_str = contracted_client.working_input
                contracted_working_hours_1 = ast.literal_eval(contracted_working_hours_1_str)
                # print(contracted_working_hours_1)


                    # Assuming 'working_input' is a dictionary with employee_id as keys
                for employee_id, working_hours in contracted_working_hours_1.items():
                    # Fetch the employee from the Employee table
                    employee3 = employee.objects.get(id=employee_id)
                    # Calculate salary per hour
                    ui_employee_salary=float(employee3.salary)
                    salary_per_hour = float(employee3.salary) / (22 * 8)
                    salary_per_hour=round(salary_per_hour,2)
                    # Convert working hours to float
                    working_hours = float(working_hours)
                    ui_working_hours=working_hours
                    # Calculate total salary for the given working hours



                    if employee3.first_name and employee3.last_name:
                        name=employee3.first_name + ' ' + employee3.last_name
                    else:
                        name=employee3.user_name

                    # ui_data[employee_id] = {
                    #         'ui_employee_name': name,
                    #         'ui_employee_salary': employee3.salary,
                    #         'ui_working_hours': working_hours,
                    #         'ui_weeks':weeks
                    #     }
                    weeks=round(weeks,2)
                    ui_employee_data = {
                        'ui_employee_name': name,
                        'ui_employee_salary': employee3.salary,
                        'ui_working_hours': working_hours,
                        'ui_weeks': weeks
                    }

                    # Append this dictionary to the list
                    ui_data.append(ui_employee_data)

                    mul=round(working_hours *weeks,2)

                    total_salary = round(salary_per_hour * mul,2)
                    # print("22222222222222222222222222222")
                    # print(salary_per_hour)
                    # print(working_hours)
                    # print(total_salary)
                    # total_salary  = "{:.2f}".format(total_salary)

                    total_salary = round(total_salary, 2)
                    # Store the total salary in the dictionary
                    # print(type(employee_id))
                    employee_id=int(employee_id)
                    # print(type(employee_id))
                    if int(employee_id) in employee_salary_dict:
                        # print("ifff")
                        # If it exists, add the new salary to the existing one
                        employee_salary_dict[int(employee_id)] += total_salary
                        employee_salary_dict[int(employee_id)] = round(employee_salary_dict[int(employee_id)], 2)

                    else:
                        # print("else")
                        # If it doesn't exist, create a new entry
                        employee_salary_dict[int(employee_id)] = total_salary
                        employee_salary_dict[int(employee_id)] = round(employee_salary_dict[int(employee_id)], 2)


                    # print(employee_salary_dict)


            # print("llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll")
            # print(employee_salary_dict)



        contracted_sum_of_rates_employee=0.0
        # Convert all values in employee_salary_dict to float
        employee_salary_dict = {k: float(v) for k, v in employee_salary_dict.items()}

        # Sum the values in employee_salary_dict
        contracted_sum_of_rates_employee = sum(employee_salary_dict.values())
        contracted_sum_of_rates_employee = "{:.2f}".format(contracted_sum_of_rates_employee)
        # print("Total contracted sum of rates for employees:", contracted_sum_of_rates_employee)


        total_time_spent_formatted={}
        project_names={}
        project_user_dict={}
        employee_rate_per_hour={}



    # print("finallllll")
    #
    # print(ui_data)
    # # print(ui)
    # # print(weeks)
    # print(ui_client_data)


    return sum_of_rates_employee,contracted_sum_of_rates_employee,one_project_rate,client_id




# Define your scopes and credentials file
# SCOPES = ["https://www.googleapis.com/auth/calendar.readonly","https://www.googleapis.com/auth/tasks.readonly"]

SCOPES = [
    "https://www.googleapis.com/auth/calendar.readonly",
    "https://www.googleapis.com/auth/tasks.readonly",
    "https://www.googleapis.com/auth/userinfo.email",
    "https://www.googleapis.com/auth/spreadsheets",
    "https://www.googleapis.com/auth/userinfo.profile",
    "openid"
]

CLIENT_SECRETS_FILE = "credentials.json"



def get_authenticated_service(request):
    global CLIENT_SECRETS_FILE
    print('1')
    # Check if there are already stored credentials in the session
    employee_id = request.session.get('user_id')
    employee_ob = employee.objects.get(id=int(employee_id))
    if employee_ob.token:
        google_credentials = json.loads(employee_ob.token)
        print(google_credentials['refresh_token'])
        revoke_access_token(google_credentials['refresh_token'])
    absolute_url1 = request.build_absolute_uri('/callback')
    if absolute_url1.startswith('http://'):
        absolute_url1 = 'https://' + absolute_url1[len('http://'):]
    flow = InstalledAppFlow.from_client_secrets_file(
        CLIENT_SECRETS_FILE, SCOPES,
        redirect_uri=absolute_url1
        # redirect_uri=request.build_absolute_uri('/callback')
    )
    print('2')
    authorization_url, _ = flow.authorization_url(
        access_type='offline',
        include_granted_scopes='true',
        prompt='consent'
    )
    print('3')
    return redirect(authorization_url)

    # # Build the service using the authenticated credentials
    # service = build('calendar', 'v3', credentials=creds)
    # events_result = service.events().list(calendarId='primary', maxResults=10).execute()
    # events = events_result.get('items', [])
    #
    # # Display events or handle them as needed
    # if not events:
    #     return HttpResponse('No events found.')
    # else:
    #     return render(request, 'events.html', {'events': events})


def callback(request: HttpRequest):
    global CLIENT_SECRETS_FILE
    print('4')
    # Build the flow object
    absolute_url = request.build_absolute_uri()
    if absolute_url.startswith('http://'):
        absolute_url = 'https://' + absolute_url[len('http://'):]
    absolute_url1 = request.build_absolute_uri('/callback')
    if absolute_url1.startswith('http://'):
        absolute_url1 = 'https://' + absolute_url1[len('http://'):]

    flow = InstalledAppFlow.from_client_secrets_file(
        CLIENT_SECRETS_FILE, SCOPES,
        # redirect_uri=request.build_absolute_uri('/callback')
        redirect_uri=absolute_url1
    )
    print('5')
    # Exchange the authorization code for credentials
    # flow.fetch_token(authorization_response=request.build_absolute_uri())
    flow.fetch_token(authorization_response=absolute_url)
    creds = flow.credentials
    print('6')
    employee_id = request.session.get('user_id')

    service = build('calendar', 'v3', credentials=creds)
    current_time = datetime.utcnow().isoformat() + 'Z'
    events_result = service.events().list(calendarId='primary', timeMax=current_time).execute()
    events = events_result.get('items', [])
    print(events, 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa')
    # print(events[0]['creator']['email'], 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')
    # user_email = events[0]['creator']['email']
    # user_email = id_token.verify_oauth2_token(creds.id_token, requests.Request()).get('email', '')

    try:
        from google.auth.transport import requests
        user_email = id_token.verify_oauth2_token(creds.id_token, requests.Request(),clock_skew_in_seconds=300).get('email', '')
        print(user_email, 'LOGIN USER EMAIL')
    except Exception as e:
        employee_ob = employee.objects.get(id=int(employee_id))
        user_email = employee_ob.email
        print(user_email,e, 'LOGIN PERSONAL EMAIL')


    if creds.refresh_token != None:
        # Store the credentials in the session
        google_credentials_json = json.dumps({
            'token': creds.token,
            'refresh_token': creds.refresh_token,
            'token_uri': creds.token_uri,
            'client_id': creds.client_id,
            'client_secret': creds.client_secret,
            'scopes': creds.scopes
        })

        # Assuming you have an employee instance
        employee_ob = employee.objects.get(id=int(employee_id))  # Replace employee_id with the actual ID
        print(google_credentials_json, 'PAWAN')
        # Store the serialized credentials in the token field
        employee_ob.token = google_credentials_json
        employee_ob.auth_gmail = user_email
        employee_ob.calender_status = 1
        employee_ob.save()

    #url = reverse('profile', kwargs={'employee_id': int(employee_id)})
    url = reverse('profile_with_optional', kwargs={'employee_id': int(employee_id), 'my_profile_tab': '3'})
    response = HttpResponseRedirect(url)
    return response




def remove(request):
    employee_id = request.session.get('user_id')
    emp_ob = employee.objects.get(id=int(employee_id))
    if emp_ob.token:
        google_credentials = json.loads(emp_ob.token)
        print(google_credentials['refresh_token'])
        status = revoke_access_token(google_credentials['refresh_token'])

        emp_ob.token = None
        emp_ob.calender_status = 0
        emp_ob.auth_gmail = None
        emp_ob.save()

    url = reverse('profile_with_optional', kwargs={'employee_id': int(employee_id), 'my_profile_tab': '3'})
    # url = reverse('profile', kwargs={'employee_id': int(employee_id)})
    print(url)
    response = HttpResponseRedirect(url)  # Redirect to a home page or a login pag
    return response  # Redirect user to a login or home page after signout



def toggle_cookie(request):
    employee_id = request.session.get('user_id')
    emp_ob = employee.objects.get(id=int(employee_id))
    print(emp_ob.calender_status, 'KKK')
    if emp_ob.calender_status == 1:
        print('Hello')
        emp_ob.calender_status = 0
        emp_ob.save()
        response = HttpResponse("Toggle is now off. Cookie deleted.")
    else:
        print('YYYYYYY')
        emp_ob.calender_status = 1
        emp_ob.save()
        response = HttpResponse("Toggle is now on. Cookie set.")
    return response


@csrf_exempt
@login_required(login_url='/')
def summary(request):

    # Initialize selected_client_ids
    selected_client_ids = []
    selected_employee_ids = []

    # Calculate the date range for the last week
    if request.method == 'POST':
        print("postttttttttttttttttttttttttttttttttttttttttttttttttt")


        from datetime import datetime, timedelta
        from_to_date = request.POST.get('from_to_date', None)
        print("companies111")
        print(from_to_date)

        # Split the string into "from" and "to" dates
        from_date_str, to_date_str = from_to_date.split(" - ")

        # Convert the date strings to datetime objects
        from_date = datetime.strptime(from_date_str, "%m/%d/%Y").date()
        to_date = datetime.strptime(to_date_str, "%m/%d/%Y").date()

        # Print the formatted dates
        print("From date:", from_date)
        print("To date:", to_date)

        # Convert start_date and end_date to datetime objects
        start_date = datetime.combine(from_date, datetime.min.time())
        end_date = datetime.combine(to_date, datetime.min.time())


        selected_client_ids = request.POST.getlist('client_id')
        print("akshay")
        print(selected_client_ids)

        selected_employee_ids = request.POST.getlist('employee_id')
        print("akshay33")
        print(selected_employee_ids)

        selected_option = request.POST.get('selected_option')
        auto_submit = request.POST.get('auto_submit')
        print("selcetddddd")
        print(selected_option)
        if auto_submit == '1':
            # Auto submission occurred, handle it here
            # For example, redirect to a different view based on the selected option
            if selected_option == '0':
                print(selected_option)
            elif selected_option == '1':
                print(selected_option)





    else:

        from datetime import datetime, timedelta

        # Get current date
        # end_date = datetime.now().date()
        # # Calculate start date (7 days ago)
        # start_date = end_date - timedelta(days=6)
        selected_month = request.session.get('month')
        if selected_month:
            current_month = int(selected_month)
        else:
            current_month = 2

        selected_year = request.session.get('year')
        if selected_year:
            current_year = int(selected_year)
        else:
            current_year = 2026

        current_date = datetime.now()
        if current_month == current_date.month:
            start_date = current_date - timedelta(days=current_date.weekday())
            end_date = start_date + timedelta(days=6)
        else:
            start_date = datetime(current_year, current_month, 1, 0, 0, 0)            
            end_date = datetime(current_year, current_month, calendar.monthrange(current_year, current_month)[1], 23, 59, 59)

        # Format the dates as desired
        formatted_start_date = start_date.strftime("%m/%d/%Y")
        formatted_end_date = end_date.strftime("%m/%d/%Y")

        # Concatenate the formatted dates
        formatted_date_range = f"{formatted_start_date} - {formatted_end_date}"

        print(formatted_date_range)
        from_to_date=formatted_date_range
        print("elsedatw")
        print(from_to_date)

        selected_option='0'

    all_clients = client.objects.all()
    all_employees =employee.objects.filter(status__in=[1, 2])

    if selected_client_ids and selected_employee_ids:
        print("if1111111111")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,
            employee_id__in=selected_employee_ids
        )

    elif selected_client_ids :
        print("if222222222222")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,

        )
    elif selected_employee_ids:
        print("if3333333333333")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            employee_id__in=selected_employee_ids
        )
    else:
        # print("else")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date
        )

    # Fetch the client objects for the selected client IDs
    # Fetch the client objects for the selected client IDs
    selected_clients = client.objects.filter(id__in=selected_client_ids)
    selected_employees=employee.objects.filter(id__in=selected_employee_ids)

    # Create a list of tuples containing client ID and name for selected clients
    selected_client_names = [(client.id, client.toggl_client_name) for client in selected_clients]
    # print(selected_client_names)

    total_selected_clients = len(selected_client_ids)
    total_selected_employees = len(selected_employee_ids)

    employee_total_time = {}
    client_total_time = {}

    entries_with_details = []
    entries_with_client_details = []

    if selected_option == '0' :
        print("userrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr")
        # Iterate over timeSheet entries
        for entry in time_entries_last_week:
            employee_id = entry.employee_id
            category_id = entry.category_id  # Assuming you have category_id in your entry object

            # Fetch the employee from the employee table
            try:
                emp = employee.objects.get(id=employee_id)
            except employee.DoesNotExist:
                continue

            # If the employee exists, update the total time spent
            if employee_id in employee_total_time:
                if category_id not in employee_total_time[employee_id]['categories']:
                    employee_total_time[employee_id]['entry_count'] += 1
                    employee_total_time[employee_id]['categories'].add(category_id)

                employee_total_time[employee_id]['total_time'] += entry.time_entries_seconds
            else:
                employee_total_time[employee_id] = {
                    'total_time': entry.time_entries_seconds,
                    'entry_count': 1,
                    'first_name': emp.first_name,
                    'last_name': emp.last_name,
                    'image_url': emp.image_url,
                    'categories': {category_id}  # Using a set to store unique category IDs
                }

        # Create a dictionary to store total time spent by each employee

        # Convert seconds to the desired format
        for employee_id, data in employee_total_time.items():
            total_seconds = data['total_time']
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            data['total_time'] = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))
            data['total_time_hour'] = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

        # Convert total_time to seconds before performing arithmetic operations
        for employee_id, data in employee_total_time.items():
            total_time_str = data['total_time']
            try:
                hours, minutes, seconds = map(int, total_time_str.split(':'))
                total_seconds = hours * 3600 + minutes * 60 + seconds
                data['total_time'] = total_seconds
            except ValueError:
                # Handle cases where total_time is not in the expected format
                data['total_time'] = 0

        # Calculate the total time spent by all employees in the last week
        total_time_all_employees = sum(data['total_time'] for data in employee_total_time.values() if isinstance(data['total_time'], int))
        # Convert seconds to hours, minutes, and seconds
        hours = total_time_all_employees // 3600
        minutes = (total_time_all_employees % 3600) // 60
        seconds = total_time_all_employees % 60

        # Format the total time
        total_time_formatted1 = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

        # Calculate the percentage of time spent by each employee and add it to the dictionary
        for employee_id, data in employee_total_time.items():
            total_time_employee = data['total_time']
            if isinstance(total_time_employee, int):
                percentage = (total_time_employee / total_time_all_employees) * 100
                data['percentage'] = round(percentage, 2)
            else:
                # Set percentage to 0 or handle as appropriate if total_time is not a valid integer
                data['percentage'] = 0

        print("table1")
        print(employee_total_time)
        # Iterate through each entry in the queryset
        for entry in time_entries_last_week:
            import datetime
            # Fetch employee details
            employee1 = employee.objects.get(id=entry.employee_id)

            # Calculate total time spent by the employee
            total_time_employee = sum(e.time_entries_seconds for e in time_entries_last_week if e.employee_id == entry.employee_id)
            # print(total_time_employee)

            # Fetch client details
            client1 = client.objects.get(id=entry.client_id)

            # Fetch category details
            category_id = Work_Category.objects.get(id=entry.category_id)

            # Convert time duration from seconds to formatted string
            hours, remainder = divmod(entry.time_entries_seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            duration_formatted = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

            # Calculate percentage time spent for the current entry
            if total_time_employee > 0:
                percentage_time = entry.time_entries_seconds / total_time_employee
            else:
                percentage_time = 0

            # Multiply by data['percentage'] for that employee id
            if entry.employee_id in employee_total_time:
                percentage_multiplier = employee_total_time[entry.employee_id]['percentage']
                percentage_time *= percentage_multiplier

            # Round percentage_time to 2 decimal points
            percentage_time = round(percentage_time, 2)

            # Check if the category ID already exists in entries_with_details for the current employee
            category_exists = False
            for detail in entries_with_details:
                if detail['category_id'] == category_id.id and detail['employee_id'] == entry.employee_id:
                    # Update existing entry
                    detail['percentage_time']=round(detail['percentage_time'],2)
                    detail['percentage_time'] += percentage_time
                    detail['percentage_time']=round(detail['percentage_time'],2)
                    # Convert existing time to seconds, add new time, and then convert back to formatted string
                    existing_seconds = sum(int(x) * 60 ** i for i, x in enumerate(reversed(detail['time'].split(':'))))
                    total_seconds = existing_seconds + entry.time_entries_seconds
                    total_hours, remainder = divmod(total_seconds, 3600)
                    total_minutes, total_seconds = divmod(remainder, 60)
                    total_formatted = '{:02d}:{:02d}:{:02d}'.format(int(total_hours), int(total_minutes), int(total_seconds))
                    detail['time'] = total_formatted
                    category_exists = True
                    break

            if not category_exists:
                # Add additional details to the entry dictionary
                entry_details = {
                    'employee_id': entry.employee_id,
                    'time': duration_formatted,  # Convert time to formatted string
                    'percentage_time': percentage_time,
                    'category_name': category_id.category,
                    'category_id': category_id.id
                }
                entries_with_details.append(entry_details)

        print("table2")
        print(entries_with_details)



        # # Iterate through each entry in the queryset
        # for entry in time_entries_last_week:
        #     import datetime
        #     # Fetch employee details
        #     employee1 = employee.objects.get(id=entry.employee_id)
        #
        #     # Calculate total time spent by the employee
        #     total_time_employee = sum(e.time_entries_seconds for e in time_entries_last_week if e.employee_id == entry.employee_id)
        #     # print(total_time_employee)
        #
        #     # Fetch client details
        #     client1 = client.objects.get(id=entry.client_id)
        #
        #     # Fetch category details
        #     category_id = Work_Category.objects.get(id=entry.category_id)
        #
        #     # Convert time duration from seconds to formatted string
        #     hours, remainder = divmod(entry.time_entries_seconds, 3600)
        #     minutes, seconds = divmod(remainder, 60)
        #     duration_formatted = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))
        #
        #     # Calculate percentage time spent for the current entry
        #     if total_time_employee > 0:
        #         percentage_time = entry.time_entries_seconds / total_time_employee
        #     else:
        #         percentage_time = 0
        #
        #     # Multiply by data['percentage'] for that employee id
        #     if entry.employee_id in employee_total_time:
        #         percentage_multiplier = employee_total_time[entry.employee_id]['percentage']
        #         percentage_time *= percentage_multiplier
        #
        #     # Round percentage_time to 2 decimal points
        #     percentage_time = round(percentage_time, 2)
        #
        #
        #     # Add additional details to the entry dictionary
        #     entry_details = {
        #         'employee_id': entry.employee_id,
        #         'time': duration_formatted,
        #         'percentage_time': percentage_time,
        #         'category_name': category_id.category,
        #          'category_id':category_id.id
        #     }
        #     entries_with_details.append(entry_details)
        #
        # print("table2")
        #
        # print(entries_with_details)

            #for bar graphhhhhhh

        # print(employee_total_time)
        # Create a dictionary to store total time spent by each day
        from collections import defaultdict
        # Create a dictionary to store total time spent by each day
        daily_total_time = defaultdict(int)

        # Calculate total time worked for each day
        for entry in time_entries_last_week:
            # Extract the day of the week and date from the start date of the entry
            day_of_week = entry.time_entries_start_date.strftime('%a')
            date = entry.time_entries_start_date.strftime('%d %b')  # Format date as 'Day Month'
            # Increment the total time for that day
            daily_total_time[f"{date}"] += entry.time_entries_seconds / 3600  # Convert seconds to hours



        print(type(start_date))
        print(end_date)
        # Convert start_date and end_date to datetime objects
        # Convert start_date and end_date to datetime objects
        # Convert start_date and end_date to datetime objects

        if start_date==end_date:
           num_days =1

        else:
           num_days = (end_date - start_date).days +1

        # Generate labels and data for the selected date range
        labels = []
        current_date = start_date
        for i in range(num_days):
            label_date = current_date.strftime('%d %b')  # Format date as 'Day Month'
            labels.append(label_date)
            current_date += timedelta(days=1)

        # Convert the dictionary values to a list for data
        data = [daily_total_time[label] for label in labels]


        print("bar_chart")
        print(labels)
        print(data)

        # Prepare data for the pie chart

        # Create pie_chart_data dictionary
        pie_chart_data = {
            employee_id: {
                'name': f"{data1['first_name']} {data1['last_name']}",
                'percentage': data1['percentage']
            } for employee_id, data1 in employee_total_time.items()
        }
        # print(pie_chart_data)
        # # Extracting labels and data from pie_chart_data
        pie1= []
        pie2 = []
        # #
        for employee_id, data1 in pie_chart_data.items():
            name1 = data1['name']
            percentage1 = data1['percentage']
            # print(name1)
            # print(percentage1)
            pie1.append(name1)
            pie2.append(percentage1)
        #
        print("piechart1")
        print(pie1)
        print(pie2)

        #2nd pie chart

        # Create pie_chart_data_2 dictionary

        pie_chart_data_2 = {}

        # Iterate over timeSheet entries
        for entry in time_entries_last_week:
            category_id = entry.category_id

            # If the category exists, update the total time spent
            if category_id in pie_chart_data_2:
                pie_chart_data_2[category_id] += entry.time_entries_seconds
            else:
                pie_chart_data_2[category_id] = entry.time_entries_seconds

        # Convert seconds to the desired format for each category
        pie3 = []  # List to store category names
        pie4 = []  # List to store total time spent on each category


        # Query category names from the Work_Category table
        category_names = Work_Category.objects.in_bulk(pie_chart_data_2.keys())

        # Calculate total time spent across all categories
        total_time_all_categories = sum(pie_chart_data_2.values())

        for category_id, total_seconds in pie_chart_data_2.items():
            category_name = category_names[category_id].category  # Fetch category name from the queried data
            pie3.append(category_name)
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            time_formatted1 = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))
            # pie4.append(time_formatted)


            # Calculate the percentage of time spent in each category and append it to pie4
            percentage_time = (total_seconds / total_time_all_categories) * 100
            pie4.append(percentage_time)

        print("piechart2222")
        print(pie3)
        print(pie4)


    else:
        print("clientttttttttttttttttttttttttttttttttttttttttttttttttttttttt")
        # Iterate over timeSheet entries
        for entry in time_entries_last_week:
            client_id = entry.client_id
            category_id = entry.category_id

            # Fetch the client from the client table
            try:
                client1 = client.objects.get(id=client_id)
            except client.DoesNotExist:
                continue

            # If the client exists, update the total time spent
            # if client_id in client_total_time:
            #     client_total_time[client_id]['total_time'] += entry.time_entries_seconds
            #     client_total_time[client_id]['entry_count'] += 1
            if client_id in client_total_time:
                client_data = client_total_time[client_id]
                client_data['total_time'] += entry.time_entries_seconds
                # Check if the category ID is new for this client
                if category_id not in client_data['category_ids']:
                    client_data['category_ids'].append(category_id)
                    client_data['entry_count'] += 1  # Increment entry count only if category is different
            else:
                client_total_time[client_id] = {
                    'total_time': entry.time_entries_seconds,
                    'entry_count': 1,
                    'client_name': client1.client_name,
                    'image_url': client1.image_url,
                    'category_ids': [category_id]
                }

        # Convert seconds to the desired format
        for client_id, data in client_total_time.items():
            total_seconds = data['total_time']
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            data['total_time'] = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))
            data['total_time_hour'] = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

        # Convert total_time to seconds before performing arithmetic operations
        for client_id, data in client_total_time.items():
            total_time_str = data['total_time']
            try:
                hours, minutes, seconds = map(int, total_time_str.split(':'))
                total_seconds = hours * 3600 + minutes * 60 + seconds
                data['total_time'] = total_seconds
            except ValueError:
                # Handle cases where total_time is not in the expected format
                data['total_time'] = 0

        # Calculate the total time spent by all clients in the last week
        total_time_all_clients = sum(data['total_time'] for data in client_total_time.values() if isinstance(data['total_time'], int))
        # Convert seconds to hours, minutes, and seconds
        hours = total_time_all_clients // 3600
        minutes = (total_time_all_clients % 3600) // 60
        seconds = total_time_all_clients % 60

        # Format the total time
        total_time_formatted1 = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

        # Calculate the percentage of time spent by each client and add it to the dictionary
        for client_id, data in client_total_time.items():
            total_time_client = data['total_time']
            if isinstance(total_time_client, int):
                percentage = (total_time_client / total_time_all_clients) * 100
                data['percentage'] = round(percentage, 2)
            else:
                # Set percentage to 0 or handle as appropriate if total_time is not a valid integer
                data['percentage'] = 0

        print("table1")
        print(client_total_time)
        # Iterate through each entry in the queryset

        # Iterate through each entry in the queryset
        for entry in time_entries_last_week:
            import datetime

            # Fetch client details
            client1 = client.objects.get(id=entry.client_id)

            # Fetch category details
            category_id = Work_Category.objects.get(id=entry.category_id)
            category_id1 = Work_Category.objects.values('id').get(id=entry.category_id)['id']
            category_id1 = int(category_id1)
            print("myyyyyyyyyyyy")
            print(type(category_id1))


            # Calculate total time spent by the client
            total_time_client = sum(e.time_entries_seconds for e in time_entries_last_week if e.client_id == entry.client_id)

            # Calculate total time spent for the client and category combination
            total_time_client_category = sum(
                e.time_entries_seconds for e in time_entries_last_week if e.client_id == entry.client_id and e.category_id == entry.category_id)

            # Convert time duration from seconds to formatted string
            hours, remainder = divmod(total_time_client_category, 3600)
            minutes, seconds = divmod(remainder, 60)
            duration_formatted = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

            # Calculate percentage time spent for the current entry
            if total_time_client_category > 0:
                percentage_time = entry.time_entries_seconds / total_time_client
            else:
                percentage_time = 0

            # Multiply by data['percentage'] for that client id
            if entry.client_id in client_total_time:
                percentage_multiplier = client_total_time[entry.client_id]['percentage']
                percentage_time *= percentage_multiplier

            # Round percentage_time to 2 decimal points
            percentage_time = round(percentage_time, 2)

            # Check if entry with same client_id and category_id already exists
            existing_entry = next((e for e in entries_with_client_details if e['client_id'] == entry.client_id and e['category_id'] == entry.category_id), None)

            if existing_entry:
                # Update existing entry
                existing_entry['time'] = duration_formatted
                existing_entry['percentage_time'] = round(existing_entry['percentage_time'] + percentage_time, 2)
                existing_entry['total_time_client'] += total_time_client
            else:
                # Add new entry
                entry_details = {
                    'client_id': entry.client_id,
                    'time': duration_formatted,
                    'percentage_time': percentage_time,
                    'total_time_client': total_time_client_category,
                    'client_name': client1.toggl_client_name,
                    'category_name': category_id.category,
                    'category_id': category_id1
                }
                entries_with_client_details.append(entry_details)

        print("table2")
        print(entries_with_client_details)


        #for bar graphhhhhhh


        # Create a dictionary to store total time spent by each day
        from collections import defaultdict
        # Create a dictionary to store total time spent by each day
        daily_total_time = defaultdict(int)

        # Calculate total time worked for each day
        for entry in time_entries_last_week:
            # Extract the day of the week and date from the start date of the entry
            day_of_week = entry.time_entries_start_date.strftime('%a')
            date = entry.time_entries_start_date.strftime('%d %b')  # Format date as 'Day Month'
            # Increment the total time for that day
            daily_total_time[f"{date}"] += entry.time_entries_seconds / 3600  # Convert seconds to hours



        print(type(start_date))
        print(end_date)
        # Convert start_date and end_date to datetime objects
        # Convert start_date and end_date to datetime objects
        # Convert start_date and end_date to datetime objects

        if start_date==end_date:
           num_days =1

        else:
           num_days = (end_date - start_date).days +1

        # Generate labels and data for the selected date range
        labels = []
        current_date = start_date
        for i in range(num_days):
            label_date = current_date.strftime('%d %b')  # Format date as 'Day Month'
            labels.append(label_date)
            current_date += timedelta(days=1)

        # Convert the dictionary values to a list for data
        data = [daily_total_time[label] for label in labels]


        print("bar_chart")
        print(labels)
        print(data)

        # Prepare data for the pie chart

        # Create pie_chart_data dictionary
        pie_chart_data = {
            client_id: {
                'name': f"{data1['client_name']}",
                'percentage': data1['percentage']
            } for client_id, data1 in client_total_time.items()
        }
        # print(pie_chart_data)
        # # Extracting labels and data from pie_chart_data
        pie1= []
        pie2 = []
        # #
        for client_id, data1 in pie_chart_data.items():
            name1 = data1['name']
            percentage1 = data1['percentage']
            # print(name1)
            # print(percentage1)
            pie1.append(name1)
            pie2.append(percentage1)
        #
        print("piechart1")
        print(pie1)
        print(pie2)


        #2nd pie chart

        # Create pie_chart_data_2 dictionary

        pie_chart_data_2 = {}

        # Iterate over timeSheet entries
        for entry in time_entries_last_week:
            category_id = entry.category_id

            # If the category exists, update the total time spent
            if category_id in pie_chart_data_2:
                pie_chart_data_2[category_id] += entry.time_entries_seconds
            else:
                pie_chart_data_2[category_id] = entry.time_entries_seconds

        # Convert seconds to the desired format for each category
        pie3 = []  # List to store category names
        pie4 = []  # List to store total time spent on each category


        # Query category names from the Work_Category table
        category_names = Work_Category.objects.in_bulk(pie_chart_data_2.keys())

        # Calculate total time spent across all categories
        total_time_all_categories = sum(pie_chart_data_2.values())

        for category_id, total_seconds in pie_chart_data_2.items():
            category_name = category_names[category_id].category  # Fetch category name from the queried data
            pie3.append(category_name)
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            time_formatted1 = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))
            # pie4.append(time_formatted)


            # Calculate the percentage of time spent in each category and append it to pie4
            percentage_time = (total_seconds / total_time_all_categories) * 100
            pie4.append(percentage_time)

        print("piechart2222")
        print(pie3)
        print(pie4)

    print(selected_option)

    context={
        "employee_total_time":employee_total_time,
        "entries_with_details": entries_with_details,
        "client_total_time":client_total_time,
        'entries_with_client_details':entries_with_client_details,
        "total_time":total_time_formatted1,
        "all_clients":all_clients,
        "selected_client_names": selected_client_names,
        'selected_client_ids': selected_client_ids,
        'total_selected_clients':total_selected_clients,
        'from_to_date':from_to_date,

        "all_employees":all_employees,
        'selected_employee_ids': selected_employee_ids,
        'total_selected_employees':total_selected_employees,
        'selected_option':selected_option,

         "chart_data": {
            "labels": labels,
            "data": data,
        },

        "pie_chart_data": {  # Pie chart data
        "labels1": pie1,
        "data1": pie2,
    },
        "pie_chart_data1": {  # Pie chart data
        "labels2": pie3,
        "data2": pie4,

    }
    }
    return render(request, "summary.html", context)

@csrf_exempt
@login_required(login_url='/')
def weekly(request):
    print("weekly")
        # Initialize selected_client_ids
    selected_client_ids = []
    selected_employee_ids=[]

    # Calculate the date range for the last week
    if request.method == 'POST':
        from datetime import datetime, timedelta
        from_to_date = request.POST.get('from_to_date', None)
        # print("companies111")
        # print(from_to_date)

        # Split the string into "from" and "to" dates
        from_date_str, to_date_str = from_to_date.split(" - ")

        # Convert the date strings to datetime objects
        from_date = datetime.strptime(from_date_str, "%m/%d/%Y").date()
        to_date = datetime.strptime(to_date_str, "%m/%d/%Y").date()

        # Print the formatted dates
        print("From date:", from_date)
        print("To date:", to_date)

        # Convert start_date and end_date to datetime objects
        start_date = datetime.combine(from_date, datetime.min.time())
        end_date = datetime.combine(to_date, datetime.min.time())


        selected_client_ids = request.POST.getlist('client_id')
        print("akshay")
        print(selected_client_ids)
        start_date=from_date
        end_date=to_date

        selected_employee_ids = request.POST.getlist('employee_id')
        print("akshay33")
        print(selected_employee_ids)

        selected_option = request.POST.get('selected_option')
        auto_submit = request.POST.get('auto_submit')
        print("selcetddddd")
        print(selected_option)
        if auto_submit == '1':
            # Auto submission occurred, handle it here
            # For example, redirect to a different view based on the selected option
            if selected_option == '0':
                print(selected_option)
            elif selected_option == '1':
                print(selected_option)
    else:

        from datetime import datetime, timedelta

        # Get current date
        end_date = datetime.now().date()

        # Calculate start date (Monday of the current week)
        start_date = end_date - timedelta(days=end_date.weekday())

        # Adjust end date to be the last date of the week (Sunday)
        end_date += timedelta(days=(6 - end_date.weekday()))

        # Format the dates as desired
        formatted_start_date = start_date.strftime("%m/%d/%Y")
        formatted_end_date = end_date.strftime("%m/%d/%Y")

        # Concatenate the formatted dates
        formatted_date_range = f"{formatted_start_date} - {formatted_end_date}"

        print(formatted_date_range)
        from_to_date=formatted_date_range
        # print("elsedatw")
        # print(from_to_date)
        selected_option='0'

    print(start_date)
    print(end_date)

    all_clients = client.objects.all()
    all_employees =employee.objects.filter(status__in=[1, 2])

    if selected_client_ids and selected_employee_ids:
        print("if")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,
            employee_id__in=selected_employee_ids,
            status=None
        )

    elif selected_client_ids :
        print("if")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,
            status=None

        )
    elif selected_employee_ids:
        print("if")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            employee_id__in=selected_employee_ids,
            status=None
        )
    else:
        print("else")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            status=None
        )

    # Fetch the client objects for the selected client IDs
    # Fetch the client objects for the selected client IDs
    selected_clients = client.objects.filter(id__in=selected_client_ids)
    selected_employees=employee.objects.filter(id__in=selected_employee_ids)

    # Create a list of tuples containing client ID and name for selected clients
    selected_client_names = [(client.id, client.toggl_client_name) for client in selected_clients]
    print(selected_client_names)
    # new eekly

    print(start_date)
    print(end_date)
    time_data={}



    from datetime import timedelta

    # Function to convert total time from seconds to hours in 12-hour format
    def convert_seconds_to_12_hour_format(total_seconds):
        hours, remainder = divmod(total_seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        return "{:02}:{:02}:{:02}".format(hours, minutes, seconds)

    def convert_12_hour_format_to_seconds(time_str):

        # If time_str is already an integer (in seconds), return it
        if isinstance(time_str, int):
            return time_str

        # Split the time string into hours, minutes, and seconds
        hours, minutes, seconds = map(int, time_str.split(':'))
        # Calculate the total time in seconds
        total_seconds = hours * 3600 + minutes * 60 + seconds
        return total_seconds


    # print(dates_increasing_order)

    from datetime import datetime, timedelta

    print(start_date)
    print(end_date)

    start_date = datetime.strptime(str(start_date), '%Y-%m-%d').date()
    end_date = datetime.strptime(str(end_date), '%Y-%m-%d').date()
    dates_increasing_order = {}

    # Populate the dictionary
    current_date = start_date
    day_count = 1
    while current_date <= end_date:
        day_str = 'date{}'.format(day_count)
        dates_increasing_order[day_str] = {'day': current_date.strftime('%a'), 'date': current_date.strftime('%m-%d')}
        current_date += timedelta(days=1)
        day_count += 1

    # Add a 'Total' entry
    dates_increasing_order['date{}'.format(day_count)] = {'day': 'Total'}
    print("new datessssssssssssssssss")
    print(dates_increasing_order)


    employee_total_time = {}
    total_entries_by_employee = {}
    employee_date_time = {}
    employee_date_time_with_details = {}
    client_date_time_with_details={}
    total_time_by_date = {}
    result_dict = {}

    client_category_time = {}
    client_category_date_time = {}
    total_time_by_date_client={}
    total_time_by_employee_for_client_category={}


    if selected_option=='0':

        # Create a dictionary to store total time for each employee for each date

        # Iterate through the time entries and calculate total time for each employee for each date
        for entry in time_entries_last_week:
            employee_id = entry.employee_id
            date = entry.time_entries_start_date
            total_time_spent_seconds = entry.time_entries_seconds

            # Initialize a dictionary for the employee if it doesn't exist
            if employee_id not in employee_total_time:
                employee_total_time[employee_id] = {}

            # Increment the total time spent for the date for the employee
            employee_total_time[employee_id][date] = employee_total_time[employee_id].get(date, 0) + total_time_spent_seconds

            if employee_id not in total_entries_by_employee:
                total_entries_by_employee[employee_id] = 0
            total_entries_by_employee[employee_id] += 1

        # Iterate over all employees to ensure that all dates are included and set to 0 if no time is spent
        for employee_id in employee_total_time:
            # Get all unique dates for the employee
            all_dates = set(employee_total_time[employee_id].keys())
            # Iterate over all dates in the date range
            for date in (start_date + timedelta(n) for n in range((end_date - start_date).days + 1)):
                # If the date is not in the employee's total time dictionary, set it to 0
                if date not in all_dates:
                    employee_total_time[employee_id][date] = 0


        # print(employee_total_time)

        # Create a dictionary to store each employee's total time spent on the first date (date1)



        # Iterate over the employee_total_time dictionary to extract the total time spent on each date for each employee
        for employee_id, time_data in employee_total_time.items():
            # Sort the dates in increasing order
            sorted_dates = sorted(time_data.keys())
            # Create a dictionary to store the employee's total time on each date
            employee_date_time[employee_id] = {}
            total_time_until_date7 = 0
            # Iterate over the sorted dates to assign them to 'date1', 'date2', ...
            for i, date in enumerate(sorted_dates, start=1):
                # Create the key name dynamically
                key_name = f"date{i}"
                # Store the total time spent on the date
                employee_date_time[employee_id][key_name] = convert_seconds_to_12_hour_format(time_data[date])

                if i <= 7:
                    total_time_until_date7 += time_data[date]
            # Adding total time until date7 to the dictionary
            employee_date_time[employee_id]['total'] = convert_seconds_to_12_hour_format(total_time_until_date7)

        # print(employee_date_time)



        # Iterate over the employee_total_time dictionary to extract the total time spent on each date for each employee
        for employee_id, time_data in employee_total_time.items():
            # Fetch additional details for the employee from the Employee model
            employee1 = employee.objects.get(id=employee_id)  # Assuming 'id' is the primary key of your Employee model

            # Create a dictionary to store the employee's details along with total time on each date
            employee_data = {
                'image_url': employee1.image_url,
                'first_name': employee1.first_name,
                'last_name': employee1.last_name,
                'designation': employee1.designation,
                'time_entries': {},
                'total_entries': 0  # Initialize total entries count
            }

            # Sort the dates in increasing order
            sorted_dates = sorted(time_data.keys())

            # Initialize a set to keep track of unique client_id-category_id combinations for this employee
            unique_combinations = set()
               #     # Variable to store the total time for the employee
            total_time_employee = 0

            # Iterate over the sorted dates to assign them to 'date1', 'date2', ...
            for i, date in enumerate(sorted_dates, start=1):
                # Create the key name dynamically
                key_name = f"date{i}"
                # Store the total time spent on the date
                employee_data['time_entries'][key_name] = convert_seconds_to_12_hour_format(time_data[date])
                #         # Add to the total time for the employee
                total_time_employee += time_data[date]

                # Fetch all entries for the current employee on the current date
                entries_on_date = time_entries_last_week.filter(employee_id=employee_id, time_entries_start_date=date)
                # Iterate over each entry to count unique combinations
                for entry in entries_on_date:
                    combination = (entry.client_id, entry.category_id)
                    if combination not in unique_combinations:
                        # Increment total entries count if the combination is unique
                        employee_data['total_entries'] += 1
                        # Add the combination to the set of unique combinations for this employee
                        unique_combinations.add(combination)

            employee_data['time_entries']['total'] = convert_seconds_to_12_hour_format(total_time_employee)

            # Add the employee data to the dictionary
            employee_date_time_with_details[employee_id] = employee_data



        print(employee_date_time_with_details)


        # Create an empty dictionary to store total time for each date

        if employee_date_time_with_details:

            sorted_dates = sorted(time_data.keys())

            # Iterate over each date from date1 to date7
             # Iterate over the sorted dates to assign them to 'date1', 'date2', ...
            for i, date in enumerate(sorted_dates, start=1):
                # Initialize total time for the current date
                total_time_for_date = 0

                # Iterate over each employee's data
                for employee_data in employee_date_time_with_details.values():
                    # Get the time worked for the current date for this employee
                    time_worked_for_date = employee_data['time_entries'][f'date{i}']
                    # Convert the time worked to seconds and add it to the total for the current date
                    total_time_for_date += convert_12_hour_format_to_seconds(time_worked_for_date)

                # Store the total time for the current date in the dictionary
                total_time_by_date[f'date{i}'] = convert_seconds_to_12_hour_format(total_time_for_date)

            # Calculate the overall total time (sum of all individual date totals)
            overall_total_time = sum(convert_12_hour_format_to_seconds(time_data) for time_data in total_time_by_date.values())

            # Update the total time from date1 to date7 and the overall total
            total_time_by_date['date1_to_date7'] = convert_seconds_to_12_hour_format(overall_total_time)

        else:
            # If employee_date_time_with_details is empty, create an empty total_time_by_date dictionary
            total_time_by_date = {}

        print("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")

        print(total_time_by_date)


        if employee_date_time_with_details:
            # Store the value of date1_to_date7 in a separate variable
            total_time = total_time_by_date['date1_to_date7']
        else:
            total_time='00:00:00'

        print(total_time)


        #for box click
        import calendar

        # Extract all dates from the employee_total_time dictionary and store them in a list
        all_dates = set()
        for time_data in employee_total_time.values():
            all_dates.update(time_data.keys())

        # Sort the dates in increasing order
        sorted_dates = sorted(all_dates)

        #
        print("newwwwwwwwwwwwww")
        time_entries_summary = time_entries_last_week.values(
        'employee_id', 'client_id', 'category_id', 'time_entries_start_date'
        ).annotate(
            total_time_spent=Sum('time_entries_seconds')
        )
        # Initialize an empty dictionary to store the results


        # Iterate over the query results
        for entry in time_entries_summary:
            employee_id = entry['employee_id']
            client_id = entry['client_id']
            category_id = entry['category_id']
            start_date = entry['time_entries_start_date']
            total_time_spent = entry['total_time_spent']

            # Check if the employee_id exists in the dictionary
            if employee_id not in result_dict:
                result_dict[employee_id] = {}

            # Check if the client_id exists for the employee
            if client_id not in result_dict[employee_id]:
                result_dict[employee_id][client_id] = {}

            # Check if the category_id exists for the client
            if category_id not in result_dict[employee_id][client_id]:
                result_dict[employee_id][client_id][category_id] = {}

            # Store the total time spent for the date
            result_dict[employee_id][client_id][category_id][start_date] = total_time_spent

        # Fill in any missing dates with 0 time spent
        for employee_id, clients in result_dict.items():
            for client_id, categories in clients.items():
                for category_id, dates in categories.items():
                    for date in all_dates:  # assuming you have a list of all dates between start_date and end_date
                        if date not in dates:
                            result_dict[employee_id][client_id][category_id][date] = 0

        # Print the resulting dictionary
        print(result_dict)




        # Iterate over the result_dict to extract the total time spent on each date for each client
        for employee_id, clients in result_dict.items():
            for client_id, categories in clients.items():
                # Fetch additional details for the client from the Client model
                client1 = client.objects.get(id=client_id)  # Assuming 'id' is the primary key of your Client model

                # Create a dictionary to store the client's details along with total time on each date
                client_data = {
                    'client_name': client1.client_name,  # Assuming 'name' is the attribute containing the client's name
                    'categories': {}
                }

                # Iterate over the categories for the client
                for category_id, dates in categories.items():

                    # Fetch additional details for the category from the WorkCategory model
                    category1 = Work_Category.objects.get(id=category_id)  # Assuming 'id' is the primary key of your WorkCategory model

                    # Initialize category data
                    category_data = {
                        'category_id': category_id,
                        'category_name': category1.category,  # Assuming 'name' is the attribute containing the category name
                        'time_entries': {}
                    }

                    # Initialize total time for the category
                    total_time_category = 0

                    # Sort the dates in increasing order
                    sorted_dates = sorted(dates.keys())

                    # Iterate over the sorted dates to assign them to 'date1', 'date2', ...
                    for i, date in enumerate(sorted_dates, start=1):
                        # Create the key name dynamically
                        key_name = f"date{i}"
                        # Store the total time spent on the date for the category
                        category_data['time_entries'][key_name] = convert_seconds_to_12_hour_format(dates[date])
                        # Add to the total time for the category
                        total_time_category += dates[date]


                    # Add total time for the category to the client's total time
                    category_data['time_entries']['total'] = convert_seconds_to_12_hour_format(total_time_category)

                    # Add category data to the client's categories, treating each combination of client ID and category ID as different
                    client_data['categories'][(client_id, category_id)] = category_data

                # Add the client data to the dictionary
                if employee_id not in client_date_time_with_details:
                    client_date_time_with_details[employee_id] = {}
                client_date_time_with_details[employee_id][client_id] = client_data

        print(client_date_time_with_details)

    #end new weekly
    else:

        print("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%")

        # Create a dictionary to store total time for each client-category combination for each date


        # Iterate through the time entries and calculate total time for each client-category combination for each date
        for entry in time_entries_last_week:
            client_id = entry.client_id
            category_id = entry.category_id
            date = entry.time_entries_start_date
            total_time_spent_seconds = entry.time_entries_seconds

            # Create a unique key for each client-category combination
            key = (client_id, category_id)

            # If the key doesn't exist in the dictionary, initialize it
            if key not in client_category_time:
                client_category_time[key] = {}

            # Increment the total time spent for the date for the client-category combination
            client_category_time[key][date] = client_category_time[key].get(date, 0) + total_time_spent_seconds

        # Iterate over all client-category combinations to ensure that all dates are included and set to 0 if no time is spent
        for client_category, time_data in client_category_time.items():
            # Get all unique dates for the client-category combination
            all_dates = set(time_data.keys())
            # Iterate over all dates in the date range
            for date in (start_date + timedelta(n) for n in range((end_date - start_date).days + 1)):
                # If the date is not in the client-category combination's total time dictionary, set it to 0
                if date not in all_dates:
                    client_category_time[client_category][date] = 0


        # Dictionary to store total time entries for each client ID and work category combination
        # total_entries = {}
        #
        # # Iterate through the time entries
        # for entry in time_entries_last_week:
        #     client_id = entry.client_id
        #     category_id = entry.category_id
        #
        #     # Create a unique key for each client ID and category combination
        #     key = (client_id, category_id)
        #
        #     # If the key doesn't exist in the dictionary, initialize it
        #     if key not in total_entries:
        #         total_entries[key] = 0
        #
        #     # Increment the total time entries for the client ID and category combination
        #     total_entries[key] += 1
        # Dictionary to store total entries for each combination of client ID and work category
         # Dictionary to store total entries for each client ID and work category combination
        # Dictionary to store total entries for each client ID and work category combination
        total_entries = {}

        # Iterate through the time entries
        for entry in time_entries_last_week:
            client_id = entry.client_id
            category_id = entry.category_id
            employee_id = entry.employee_id

            # Create a unique key for each client ID and category combination
            key = (client_id, category_id)

            # If the key doesn't exist in the dictionary, initialize it
            if key not in total_entries:
                total_entries[key] = set()

            # Add the employee ID to the set of unique employees for this client ID and category combination
            total_entries[key].add(employee_id)

        # Print the total entries dictionary
        print(total_entries)

        # Dictionary to store the count of unique employee IDs for each client ID and work category combination
        unique_employee_count = {}

        # Iterate through the items of the total_entries dictionary
        for client_category, employees in total_entries.items():
            # Get the count of unique employee IDs for the current client ID and work category combination
            unique_employee_count[client_category] = len(employees)

        print(unique_employee_count)



        # Create a dictionary to store each client-category combination's total time spent on each date
        # Iterate over the client-category_time dictionary to extract the total time spent on each date for each client-category combination
        for client_category, time_data in client_category_time.items():
            # Fetch client and category names
            client_id, category_id = client_category
            client1 = client.objects.get(id=client_id)
            category_name = Work_Category.objects.get(id=category_id)

            # Get the total number of entries for the client-category combination
            total_entries_count = unique_employee_count.get(client_category, 0)

            # Sort the dates in increasing order
            sorted_dates = sorted(time_data.keys())
            # Create a dictionary to store the client-category combination's total time on each date
            client_category_date_time[client_category] = {
                'client_name': client1.client_name,
                'category_name': category_name.category,
                'total_entries': total_entries_count,
                'time_entries': {}
            }
            total_time_until_date = 0
            # Iterate over the sorted dates to assign them to 'date1', 'date2', ...
            for i, date in enumerate(sorted_dates, start=1):
                # Create the key name dynamically
                key_name = f"date{i}"
                # Store the total time spent on the date
                client_category_date_time[client_category]['time_entries'][key_name] = convert_seconds_to_12_hour_format(time_data[date])
                total_time_until_date += time_data[date]
            # Adding total time until last date to the dictionary
            client_category_date_time[client_category]['time_entries']['total'] = convert_seconds_to_12_hour_format(total_time_until_date)

        print(client_category_date_time)


        #fro last total line

        if client_category_date_time:

            # Get the sorted list of dates available in the data
            dates = set(date for data in client_category_date_time.values() for date in data['time_entries'].keys() if date != 'total')
            sorted_dates = sorted(dates)

            # Iterate over each date from date1 to date7
            for i, date in enumerate(sorted_dates, start=1):
                # Initialize total time for the current date
                total_time_for_date = 0

                # Iterate over each client-category combination
                for client_category, data in client_category_date_time.items():
                    # Get the time worked for the current date for this client-category combination
                    time_worked_for_date = data['time_entries'].get(date, '00:00:00')
                    # Convert the time worked to seconds and add it to the total for the current date
                    total_time_for_date += convert_12_hour_format_to_seconds(time_worked_for_date)

                # Store the total time for the current date in the dictionary
                total_time_by_date_client[f'date{i}'] = convert_seconds_to_12_hour_format(total_time_for_date)

            # Calculate the overall total time (sum of all individual date totals)
            overall_total_time_client = sum(convert_12_hour_format_to_seconds(time_data) for time_data in total_time_by_date_client.values())

            # Update the total time from date1 to date7 and the overall total for clients
            total_time_by_date_client['date1_to_date7'] = convert_seconds_to_12_hour_format(overall_total_time_client)
        else:
            total_time_by_date_client={}

        print("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")

        print(total_time_by_date_client)

        # Store the value of date1_to_date7 in a separate variable
        total_time = total_time_by_date_client.get('date1_to_date7', '00:00:00')
        print(total_time)


        # # Create a dictionary to store total time for each employee for each date
        employee_total_time_by_client_category = {}

        # Iterate through the time entries and calculate total time for each employee for each date
        for entry in time_entries_last_week:
            employee_id = entry.employee_id
            client_id = entry.client_id
            category_id = entry.category_id
            date = entry.time_entries_start_date
            total_time_spent_seconds = entry.time_entries_seconds

            # Create a unique key for each client ID and category ID combination
            key = (client_id, category_id)

            # If the key doesn't exist in the dictionary, initialize it
            if key not in employee_total_time_by_client_category:
                employee_total_time_by_client_category[key] = {}

            # If the employee ID doesn't exist for the client-category combination, initialize it
            if employee_id not in employee_total_time_by_client_category[key]:
                employee_total_time_by_client_category[key][employee_id] = {}

            # Increment the total time spent for the date for the employee for the client-category combination
            employee_total_time_by_client_category[key][employee_id][date] = \
                employee_total_time_by_client_category[key][employee_id].get(date, 0) + total_time_spent_seconds
        #
        # Iterate over all client-category combinations to ensure that all employees and dates are included
        for client_category, employee_data in employee_total_time_by_client_category.items():
            for employee_id, time_data in employee_data.items():
                # Get all unique dates for the employee
                all_dates = set(time_data.keys())
                # Iterate over all dates in the date range
                for date in (start_date + timedelta(n) for n in range((end_date - start_date).days + 1)):
                    # If the date is not in the employee's total time dictionary, set it to 0
                    if date not in all_dates:
                        employee_total_time_by_client_category[client_category][employee_id][date] = 0

        # Dictionary to store total time for each employee for each client-category combination
        total_time_by_employee_for_client_category = {}

        # Iterate over the employee_total_time_by_client_category dictionary
        for client_category, employee_data in employee_total_time_by_client_category.items():
            # Fetch client and category names
            client_id, category_id = client_category
            client1 = client.objects.get(id=client_id)
            category_name = Work_Category.objects.get(id=category_id)

            # Create a dictionary to store each employee's total time spent on each date for the client-category combination
            total_time_by_employee_for_client_category[client_category] = {
                'client_name': client1.client_name,
                'category_name': category_name.category,
                'employees': {}
            }

            # Iterate over each employee's data
            for employee_id, time_data in employee_data.items():
                employee_info = employee.objects.get(id=employee_id)
                employee_name = f"{employee_info.first_name} {employee_info.last_name}"
                employee_image_url=employee_info.image_url
                # Sort the dates in increasing order
                sorted_dates = sorted(time_data.keys())
                # Create a dictionary to store the employee's total time on each date
                total_time_by_employee_for_client_category[client_category]['employees'][employee_id] = {
                   'employee_name': employee_name,
                    'employee_image_url':employee_image_url,
                    'total_time_by_date': {
                        f'date{i}': convert_seconds_to_12_hour_format(time_data[date]) for i, date in enumerate(sorted_dates, start=1)
                    }
                    # f'date{i}': convert_seconds_to_12_hour_format(time_data[date]) for i, date in enumerate(sorted_dates, start=1)
                }

                # Calculate the overall total time for the employee
                overall_total_time = sum(time_data.values())
                # Add the overall total time for the employee to the dictionary
                total_time_by_employee_for_client_category[client_category]['employees'][employee_id]['total'] = \
                    convert_seconds_to_12_hour_format(overall_total_time)

        print(total_time_by_employee_for_client_category)










    # print(all_clients)

    total_selected_clients = len(selected_client_ids)
    print(selected_client_ids)
    print(total_selected_clients)

    total_selected_employees = len(selected_employee_ids)



    context={

        "all_clients":all_clients,
        "selected_client_names": selected_client_names,
        'selected_client_ids': selected_client_ids,
        'total_selected_clients':total_selected_clients,
        'from_to_date':from_to_date,

         "all_employees":all_employees,
        'selected_employee_ids': selected_employee_ids,
        'total_selected_employees':total_selected_employees,

        'employee_date_time_with_details':employee_date_time_with_details,
        'dates_increasing_order':dates_increasing_order,
        'client_date_time_with_details':client_date_time_with_details,
        'total_time_by_date':total_time_by_date,
        'total_time':total_time,
        'selected_option':selected_option,
        'client_category_date_time':client_category_date_time,

        'total_time_by_date_client':total_time_by_date_client,
        'total_time_by_employee_for_client_category':total_time_by_employee_for_client_category


    }
    return render(request, "weekly.html", context)

@csrf_exempt
@login_required(login_url='/')
def detailed(request):
    selected_client_ids = []
    selected_employee_ids = []

    # Calculate the date range for the last week
    if request.method == 'POST':
        from datetime import datetime, timedelta
        from_to_date = request.POST.get('from_to_date', None)
        print("companies111")
        print(from_to_date)

        # Split the string into "from" and "to" dates
        from_date_str, to_date_str = from_to_date.split(" - ")

        # Convert the date strings to datetime objects
        from_date = datetime.strptime(from_date_str, "%m/%d/%Y").date()
        to_date = datetime.strptime(to_date_str, "%m/%d/%Y").date()

        # Print the formatted dates
        print("From date:", from_date)
        print("To date:", to_date)

        # Convert start_date and end_date to datetime objects
        start_date = datetime.combine(from_date, datetime.min.time())
        end_date = datetime.combine(to_date, datetime.min.time())


        selected_client_ids = request.POST.getlist('client_id')
        print("akshay")
        print(selected_client_ids)

        selected_employee_ids = request.POST.getlist('employee_id')
        print("akshay33")
        print(selected_employee_ids)


    else:

        from datetime import datetime, timedelta

        # Get current date
        # end_date = datetime.now().date()
        # # Calculate start date (7 days ago)
        # start_date = end_date - timedelta(days=6)

        selected_month = request.session.get('month')
        if selected_month:
            current_month = int(selected_month)
        else:
            current_month = 2

        selected_year = request.session.get('year')
        if selected_year:
            current_year = int(selected_year)
        else:
            current_year = 2026

        current_date = datetime.now()
        if current_month == current_date.month:
            start_date = current_date - timedelta(days=current_date.weekday())
            end_date = start_date + timedelta(days=6)
        else:
            start_date = datetime(current_year, current_month, 1, 0, 0, 0)            
            end_date = datetime(current_year, current_month, calendar.monthrange(current_year, current_month)[1], 23, 59, 59)

        # Format the dates as desired
        formatted_start_date = start_date.strftime("%m/%d/%Y")
        formatted_end_date = end_date.strftime("%m/%d/%Y")

        # Concatenate the formatted dates
        formatted_date_range = f"{formatted_start_date} - {formatted_end_date}"

        print(formatted_date_range)
        from_to_date=formatted_date_range
        print("elsedatw")
        print(from_to_date)

    all_clients = client.objects.all()
    all_employees =employee.objects.filter(status__in=[1, 2])

    if selected_client_ids and selected_employee_ids:
        print("if")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,
            employee_id__in=selected_employee_ids,
            status=None
        )

    elif selected_client_ids :
        print("if")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,
            status=None

        )
    elif selected_employee_ids:
        print("if")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            employee_id__in=selected_employee_ids,
            status=None
        )
    else:
        print("else")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            status=None
        )

    # Fetch the client objects for the selected client IDs
    # Fetch the client objects for the selected client IDs
    selected_clients = client.objects.filter(id__in=selected_client_ids)
    selected_employees=employee.objects.filter(id__in=selected_employee_ids)

    # Create a list of tuples containing client ID and name for selected clients
    selected_client_names = [(client.id, client.toggl_client_name) for client in selected_clients]
    # print(selected_client_names)


    total_selected_clients = len(selected_client_ids)
    # print(selected_client_ids)
    # print(total_selected_clients)

    total_selected_employees = len(selected_employee_ids)



    entries_with_details = []
    total_duration_seconds=0

    # Iterate through each entry in the queryset
    for entry in time_entries_last_week:
        # Fetch employee details
        employee1 = employee.objects.get(id=entry.employee_id)

        # Fetch client details
        client1 = client.objects.get(id=entry.client_id)

        # Fetch category details
        category_id = Work_Category.objects.get(id=entry.category_id)
        total_duration_seconds += entry.time_entries_seconds

        # Convert time duration from seconds to formatted string
        hours, remainder = divmod(entry.time_entries_seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        duration_formatted = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

        start_date_formatted = entry.time_entries_start_date.strftime("%m/%d/%Y")

        # Format start_time and stop_time
        start_time_formatted = entry.time_entries_start_time.strftime("%I:%M %p")  # 12-hour format with AM/PM
        stop_time_formatted = entry.time_entries_stop_time.strftime("%I:%M %p")  # 12-hour format with AM/PM

        employee_ob = employee.objects.get(id=employee1.id)
        try:
            employee_country = Country.objects.get(id=employee_ob.country_id)
            if employee_country.code == 'US':
                country_city = 'America/New_York'
            elif employee_country.code == 'SA':
                country_city = 'Africa/Johannesburg'
            elif employee_country.code == 'UK':
                country_city = 'Europe/London'
            elif employee_country.code == 'PH':
                country_city = 'Asia/Manila'
            else:
                country_city = 'America/New_York'
        except Exception as e:
            country_city = 'America/New_York'
        print('country_city ',country_city)
        local_tz = pytz.timezone(country_city)

        start_datetime = datetime.combine(entry.time_entries_start_date, entry.time_entries_start_time)
        end_datetime = datetime.combine(entry.time_entries_stop_date, entry.time_entries_stop_time)

        start_datetime = start_datetime.astimezone(local_tz)
        end_datetime = end_datetime.astimezone(local_tz)

        if entry.description:
            description = entry.description
        else:
            description = 'No Description'

        project_data = None
        if entry.project_id:
            try:
                project_data = project.objects.get(id=int(entry.project_id))
            except (ValueError, ObjectDoesNotExist):
                project_data = None
        print('Vinod project_data', project_data)
        # Add additional details to the entry dictionary
        entry_details = {
            'employee_name': employee1.user_name,
            'time': duration_formatted,
            'client_name': client1.toggl_client_name,
            'project_name': project_data.project_name if project_data else '',
            'category_name': category_id.category,
            'description': description,
            'start_date': start_date_formatted,
            # 'start_time': start_time_formatted,
            # 'stop_time': stop_time_formatted
            'start_time': start_datetime.strftime("%I:%M %p").lstrip('0'),
            'stop_time': end_datetime.strftime("%I:%M %p").lstrip('0')
        }
        entries_with_details.append(entry_details)

    total_hours, remainder = divmod(total_duration_seconds, 3600)
    total_minutes, total_seconds = divmod(remainder, 60)

    # Format the total duration as desired
    total_duration_formatted = '{:02d}:{:02d}:{:02d}'.format(total_hours, total_minutes, total_seconds)



    print("Entries with details:")
    print(entries_with_details)




    context={
        'entries_with_details':entries_with_details,
        "all_clients":all_clients,
        "selected_client_names": selected_client_names,
        'selected_client_ids': selected_client_ids,
        'total_selected_clients':total_selected_clients,
        'from_to_date':from_to_date,

        "all_employees":all_employees,
        'selected_employee_ids': selected_employee_ids,
        'total_selected_employees':total_selected_employees,
        'total_time':total_duration_formatted



    }
    return render(request, "detailed.html", context)

@csrf_exempt
@login_required(login_url='/')
def client_entries(request, client_id):

    selected_client_ids = []
    selected_employee_ids = []

    # Calculate the date range for the last week
    if request.method == 'POST':
        from datetime import datetime, timedelta
        from_to_date = request.POST.get('from_to_date', None)
        print("companies111")
        print(from_to_date)

        # Split the string into "from" and "to" dates
        from_date_str, to_date_str = from_to_date.split(" - ")

        # Convert the date strings to datetime objects
        from_date = datetime.strptime(from_date_str, "%m/%d/%Y").date()
        to_date = datetime.strptime(to_date_str, "%m/%d/%Y").date()

        # Print the formatted dates
        print("From date:", from_date)
        print("To date:", to_date)

        # Convert start_date and end_date to datetime objects
        start_date = datetime.combine(from_date, datetime.min.time())
        end_date = datetime.combine(to_date, datetime.min.time())


        selected_client_ids = request.POST.getlist('client_id')
        print("akshay")
        print(selected_client_ids)

        selected_employee_ids = request.POST.getlist('employee_id')
        print("akshay33")
        print(selected_employee_ids)


    else:

        from datetime import datetime, timedelta

        # Get current date
        # end_date = datetime.now().date()
        # # Calculate start date (7 days ago)
        # start_date = end_date - timedelta(days=6)
        start_date_str = request.GET.get('from')
        end_date_str = request.GET.get('to')

        # If the dates are present, convert them to datetime objects
        if start_date_str and end_date_str:
            from datetime import datetime
            start_date = datetime.fromisoformat(start_date_str)
            end_date = datetime.fromisoformat(end_date_str)

        else:
            selected_month = request.session.get('month')
            if selected_month:
                current_month = int(selected_month)
            else:
                current_month = 2

            selected_year = request.session.get('year')
            if selected_year:
                current_year = int(selected_year)
            else:
                current_year = 2026

            current_date = datetime.now()
            if current_month == current_date.month:
                start_date = current_date - timedelta(days=current_date.weekday())
                end_date = start_date + timedelta(days=6)
            else:
                start_date = datetime(current_year, current_month, 1, 0, 0, 0)
                end_date = datetime(current_year, current_month, calendar.monthrange(current_year, current_month)[1], 23, 59, 59)


        # Format the dates as desired
        formatted_start_date = start_date.strftime("%m/%d/%Y")
        formatted_end_date = end_date.strftime("%m/%d/%Y")

        # Concatenate the formatted dates
        formatted_date_range = f"{formatted_start_date} - {formatted_end_date}"

        print(formatted_date_range)
        from_to_date=formatted_date_range
        print("elsedatw")
        print(from_to_date)
            # Here, we ensure that the client_id is included in the selected_client_ids list
        if str(client_id) not in selected_client_ids:
            selected_client_ids.append(str(client_id))

    all_clients = client.objects.all()
    all_employees =employee.objects.filter(status__in=[1, 2])

    if selected_client_ids and selected_employee_ids:
        print("if")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,
            employee_id__in=selected_employee_ids,
            status=None
        )

    elif selected_client_ids :
        print("if")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,
            status=None

        )
    elif selected_employee_ids:
        print("if")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            employee_id__in=selected_employee_ids,
            status=None

        )
    else:
        print("else")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            status=None

        )


    # Fetch the client objects for the selected client IDs
    # Fetch the client objects for the selected client IDs
    selected_clients = client.objects.filter(id__in=selected_client_ids)
    selected_employees=employee.objects.filter(id__in=selected_employee_ids)

    # Create a list of tuples containing client ID and name for selected clients
    selected_client_names = [(client.id, client.toggl_client_name) for client in selected_clients]
    print(selected_client_names)


    total_selected_clients = len(selected_client_ids)
    print(selected_client_ids)
    print(total_selected_clients)

    total_selected_employees = len(selected_employee_ids)



    entries_with_details = []
    total_duration_seconds = 0

    # Iterate through each entry in the queryset
    for entry in time_entries_last_week:
        # Fetch employee details
        employee1 = employee.objects.get(id=entry.employee_id)

        # Fetch client details
        client1 = client.objects.get(id=entry.client_id)

        # Fetch category details
        category_id = Work_Category.objects.get(id=entry.category_id)

        # Convert time duration from seconds to formatted string
        hours, remainder = divmod(entry.time_entries_seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        duration_formatted = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

        start_date_formatted = entry.time_entries_start_date.strftime("%m/%d/%Y")

        # Format start_time and stop_time
        start_time_formatted = entry.time_entries_start_time.strftime("%I:%M %p")  # 12-hour format with AM/PM
        stop_time_formatted = entry.time_entries_stop_time.strftime("%I:%M %p")  # 12-hour format with AM/PM

        employee_ob = employee.objects.get(id=employee1.id)
        try:
            employee_country = Country.objects.get(id=employee_ob.country_id)
            if employee_country.code == 'US':
                country_city = 'America/New_York'
            elif employee_country.code == 'SA':
                country_city = 'Africa/Johannesburg'
            elif employee_country.code == 'UK':
                country_city = 'Europe/London'
            elif employee_country.code == 'PH':
                country_city = 'Asia/Manila'
            else:
                country_city = 'America/New_York'
        except Exception as e:
            country_city = 'America/New_York'
        print('country_city ',country_city)
        local_tz = pytz.timezone(country_city)

        start_datetime = datetime.combine(entry.time_entries_start_date, entry.time_entries_start_time)
        end_datetime = datetime.combine(entry.time_entries_stop_date, entry.time_entries_stop_time)

        start_datetime = start_datetime.astimezone(local_tz)
        end_datetime = end_datetime.astimezone(local_tz)

        total_duration_seconds += entry.time_entries_seconds

        if entry.description:
            description=entry.description
        else:
            description='No Description'

        project_data = None
        if entry.project_id:
            try:
                project_data = project.objects.get(id=int(entry.project_id))
            except ValueError:
                project_data = None
        print('Vinod project_data', project_data)
        # Add additional details to the entry dictionary
        entry_details = {
            'employee_name': employee1.user_name,
            'time': duration_formatted,

            'client_name': client1.toggl_client_name,
            'category_name': category_id.category,
            'project_name': project_data.project_name if project_data else '',
            'description': description,
            'start_date': start_date_formatted,
            # 'start_time': start_time_formatted,
            # 'stop_time': stop_time_formatted,
            'start_time': start_datetime.strftime("%I:%M %p").lstrip('0'),
            'stop_time': end_datetime.strftime("%I:%M %p").lstrip('0'),
            'client_id': client_id,
        }
        entries_with_details.append(entry_details)

    total_hours, remainder = divmod(total_duration_seconds, 3600)
    total_minutes, total_seconds = divmod(remainder, 60)

    # Format the total duration as desired
    total_duration_formatted = '{:02d}:{:02d}:{:02d}'.format(total_hours, total_minutes, total_seconds)

    print("Entries with details:")
    print(entries_with_details)

    print(client_id)
    print(selected_client_ids)

    context={
        'entries_with_details':entries_with_details,
        "all_clients":all_clients,
        "selected_client_names": selected_client_names,
        'selected_client_ids': selected_client_ids,
        'total_selected_clients':total_selected_clients,
        'from_to_date':from_to_date,

        "all_employees":all_employees,
        'selected_employee_ids': selected_employee_ids,
        'total_selected_employees':total_selected_employees,
        'client_id': client_id,
        'total_time':total_duration_formatted

    }

    return render(request, 'client_entries.html', context)


@csrf_exempt
@login_required(login_url='/')
def client_category_details(request, client_id, category_id):

    selected_client_ids = []
    selected_employee_ids = []

    # Calculate the date range for the last week
    if request.method == 'POST':
        from datetime import datetime, timedelta
        from_to_date = request.POST.get('from_to_date', None)
        print("companies111")
        print(from_to_date)

        # Split the string into "from" and "to" dates
        from_date_str, to_date_str = from_to_date.split(" - ")

        # Convert the date strings to datetime objects
        from_date = datetime.strptime(from_date_str, "%m/%d/%Y").date()
        to_date = datetime.strptime(to_date_str, "%m/%d/%Y").date()

        # Print the formatted dates
        print("From date:", from_date)
        print("To date:", to_date)

        # Convert start_date and end_date to datetime objects
        start_date = datetime.combine(from_date, datetime.min.time())
        end_date = datetime.combine(to_date, datetime.min.time())


        selected_client_ids = request.POST.getlist('client_id')
        print("akshay")
        print(selected_client_ids)

        selected_employee_ids = request.POST.getlist('employee_id')
        print("akshay33")
        print(selected_employee_ids)


    else:

        from datetime import datetime, timedelta

        # Get current date
        # end_date = datetime.now().date()
        # # Calculate start date (7 days ago)
        # start_date = end_date - timedelta(days=6)

        start_date_str = request.GET.get('from')
        end_date_str = request.GET.get('to')

        if start_date_str and end_date_str:
            try:
                start_date = datetime.fromisoformat(start_date_str)
                end_date = datetime.fromisoformat(end_date_str)
            except ValueError:
                start_date, end_date = None, None
        else:
            start_date, end_date = None, None

        if not start_date or not end_date:
            selected_month = request.session.get('month')
            if selected_month:
                current_month = int(selected_month)
            else:
                current_month = 2

            selected_year = request.session.get('year')
            if selected_year:
                current_year = int(selected_year)
            else:
                current_year = 2026
            current_date = datetime.now()

            if current_month == current_date.month:
                start_date = current_date - timedelta(days=current_date.weekday())
                end_date = start_date + timedelta(days=6)
            else:
                start_date = datetime(current_year, current_month, 1)
                end_date = datetime(current_year, current_month, calendar.monthrange(current_year, current_month)[1], 23, 59, 59)

        # Format the dates as desired
        formatted_start_date = start_date.strftime("%m/%d/%Y")
        formatted_end_date = end_date.strftime("%m/%d/%Y")

        # Concatenate the formatted dates
        formatted_date_range = f"{formatted_start_date} - {formatted_end_date}"

        from_to_date=formatted_date_range
        if str(client_id) not in selected_client_ids:
            selected_client_ids.append(str(client_id))

    all_clients = client.objects.all()
    all_employees =employee.objects.filter(status__in=[1, 2])

    print("client)category_detailssssssssssssssssss")


    if selected_client_ids and selected_employee_ids:
        print("if sleected 11")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,
            employee_id__in=selected_employee_ids,
            category_id=category_id,
            status=None

        )

    elif selected_client_ids :
        print("if slecetdddddddddddddddddddddddddddd 222")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,
            category_id=category_id,
            status=None

        )

    elif selected_employee_ids:
        print("if 333333333333")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            employee_id__in=selected_employee_ids,
            client_id=client_id,
            category_id=category_id,
            status=None

        )
    else:
        print("else")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,

            category_id=category_id,
            status=None


        )


    # Fetch the client objects for the selected client IDs
    # Fetch the client objects for the selected client IDs
    selected_clients = client.objects.filter(id__in=selected_client_ids)
    selected_employees=employee.objects.filter(id__in=selected_employee_ids)

    # Create a list of tuples containing client ID and name for selected clients
    selected_client_names = [(client.id, client.toggl_client_name) for client in selected_clients]
    print(selected_client_names)


    total_selected_clients = len(selected_client_ids)
    print(selected_client_ids)
    print(total_selected_clients)

    total_selected_employees = len(selected_employee_ids)



    entries_with_details = []
    total_duration_seconds = 0

    for entry in time_entries_last_week:
        # Fetch employee details
        employee1 = employee.objects.get(id=entry.employee_id)

        # Fetch client details
        client1 = client.objects.get(id=entry.client_id)

        # Fetch category details (renamed variable to avoid overwriting category_id)
        category = Work_Category.objects.get(id=entry.category_id)

        # Convert time duration from seconds to formatted string
        hours, remainder = divmod(entry.time_entries_seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        duration_formatted = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

        start_date_formatted = entry.time_entries_start_date.strftime("%m/%d/%Y")

        # Format start_time and stop_time
        start_time_formatted = entry.time_entries_start_time.strftime("%I:%M %p")  # 12-hour format with AM/PM
        stop_time_formatted = entry.time_entries_stop_time.strftime("%I:%M %p")  # 12-hour format with AM/PM

        employee_ob = employee.objects.get(id=employee1.id)
        try:
            employee_country = Country.objects.get(id=employee_ob.country_id)
            if employee_country.code == 'US':
                country_city = 'America/New_York'
            elif employee_country.code == 'SA':
                country_city = 'Africa/Johannesburg'
            elif employee_country.code == 'UK':
                country_city = 'Europe/London'
            elif employee_country.code == 'PH':
                country_city = 'Asia/Manila'
            else:
                country_city = 'America/New_York'
        except Exception as e:
            country_city = 'America/New_York'
        print('country_city ',country_city)
        local_tz = pytz.timezone(country_city)

        start_datetime = datetime.combine(entry.time_entries_start_date, entry.time_entries_start_time)
        end_datetime = datetime.combine(entry.time_entries_stop_date, entry.time_entries_stop_time)

        start_datetime = start_datetime.astimezone(local_tz)
        end_datetime = end_datetime.astimezone(local_tz)

        total_duration_seconds += entry.time_entries_seconds

        if entry.description:
            description = entry.description
        else:
            description = 'No Description'

        project_data = None
        if entry.project_id:
            try:
                project_data = project.objects.get(id=int(entry.project_id))
            except ValueError:
                project_data = None
        print('Vinod project_data', project_data)
        # Add additional details to the entry dictionary
        entry_details = {
            'employee_name': employee1.user_name,
            'time': duration_formatted,
            'client_name': client1.toggl_client_name,
            'project_name': project_data.project_name if project_data else '',
            'category_name': category.category,
            'description': description,
            'start_date': start_date_formatted,
            # 'start_time': start_time_formatted,
            # 'stop_time': stop_time_formatted,
            'start_time': start_datetime.strftime("%I:%M %p").lstrip('0'),
            'stop_time': end_datetime.strftime("%I:%M %p").lstrip('0'),
            'client_id': client_id,
        }
        entries_with_details.append(entry_details)

    total_hours, remainder = divmod(total_duration_seconds, 3600)
    total_minutes, total_seconds = divmod(remainder, 60)

    # Format the total duration as desired
    total_duration_formatted = '{:02d}:{:02d}:{:02d}'.format(total_hours, total_minutes, total_seconds)
    #
    #
    print(entries_with_details)

    print(client_id)
    print(category_id)
    print('Vinod from_to_date',from_to_date)

    context={
        'entries_with_details':entries_with_details,
        "all_clients":all_clients,
        "selected_client_names": selected_client_names,
        'selected_client_ids': selected_client_ids,
        'total_selected_clients':total_selected_clients,
        'from_to_date':from_to_date,

        "all_employees":all_employees,
        'selected_employee_ids': selected_employee_ids,
        'total_selected_employees':total_selected_employees,
        'client_id': client_id,
        'category_id':category_id,
        'total_time':total_duration_formatted

    }

    return render(request, 'client_category_details.html', context)


@csrf_exempt
@login_required(login_url='/')
def employee_entries(request, employee_id):

    selected_client_ids = []
    selected_employee_ids = []

    # Calculate the date range for the last week
    if request.method == 'POST':
        from datetime import datetime, timedelta
        from_to_date = request.POST.get('from_to_date', None)
        print("companies111")
        print(from_to_date)

        # Split the string into "from" and "to" dates
        from_date_str, to_date_str = from_to_date.split(" - ")

        # Convert the date strings to datetime objects
        from_date = datetime.strptime(from_date_str, "%m/%d/%Y").date()
        to_date = datetime.strptime(to_date_str, "%m/%d/%Y").date()

        # Print the formatted dates
        print("From date:", from_date)
        print("To date:", to_date)

        # Convert start_date and end_date to datetime objects
        start_date = datetime.combine(from_date, datetime.min.time())
        end_date = datetime.combine(to_date, datetime.min.time())


        selected_client_ids = request.POST.getlist('client_id')
        print("akshay")
        print(selected_client_ids)

        selected_employee_ids = request.POST.getlist('employee_id')
        print("akshay33")
        print(selected_employee_ids)


    else:

        from datetime import datetime, timedelta

        # Get current date
        # end_date = datetime.now().date()
        # # Calculate start date (7 days ago)
        # start_date = end_date - timedelta(days=6)

        start_date_str = request.GET.get('from')
        end_date_str = request.GET.get('to')

        # If the dates are present, convert them to datetime objects
        if start_date_str and end_date_str:
            from datetime import datetime
            start_date = datetime.fromisoformat(start_date_str)
            end_date = datetime.fromisoformat(end_date_str)

        else:
            selected_month = request.session.get('month')
            if selected_month:
                current_month = int(selected_month)
            else:
                current_month = 2

            selected_year = request.session.get('year')
            if selected_year:
                current_year = int(selected_year)
            else:
                current_year = 2026

            current_date = datetime.now()
            if current_month == current_date.month:
                start_date = current_date - timedelta(days=current_date.weekday())
                end_date = start_date + timedelta(days=6)
            else:
                start_date = datetime(current_year, current_month, 1, 0, 0, 0)
                end_date = datetime(current_year, current_month, calendar.monthrange(current_year, current_month)[1], 23, 59, 59)


        # Format the dates as desired
        formatted_start_date = start_date.strftime("%m/%d/%Y")
        formatted_end_date = end_date.strftime("%m/%d/%Y")

        # Concatenate the formatted dates
        formatted_date_range = f"{formatted_start_date} - {formatted_end_date}"

        print(formatted_date_range)
        from_to_date=formatted_date_range
        print("elsedatw")
        print(from_to_date)
            # Here, we ensure that the client_id is included in the selected_client_ids list
        if str(employee_id) not in selected_employee_ids:
            selected_employee_ids.append(str(employee_id))

    all_clients = client.objects.all()
    all_employees =employee.objects.filter(status__in=[1, 2])

    if selected_client_ids and selected_employee_ids:
        print("if")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,
            employee_id__in=selected_employee_ids,
            status=None
        )

    elif selected_client_ids :
        print("if")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,
            status=None

        )
    elif selected_employee_ids:
        print("if")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            employee_id__in=selected_employee_ids,
            status=None

        )
    else:
        print("else")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            status=None

        )


    # Fetch the client objects for the selected client IDs
    # Fetch the client objects for the selected client IDs
    selected_clients = client.objects.filter(id__in=selected_client_ids)
    selected_employees=employee.objects.filter(id__in=selected_employee_ids)

    # Create a list of tuples containing client ID and name for selected clients
    selected_client_names = [(client.id, client.toggl_client_name) for client in selected_clients]
    print(selected_client_names)


    total_selected_clients = len(selected_client_ids)
    print(selected_client_ids)
    print(total_selected_clients)

    total_selected_employees = len(selected_employee_ids)



    entries_with_details = []
    total_duration_seconds = 0

    # Iterate through each entry in the queryset
    for entry in time_entries_last_week:
        # Fetch employee details
        employee1 = employee.objects.get(id=entry.employee_id)

        # Fetch client details
        client1 = client.objects.get(id=entry.client_id)

        # Fetch category details
        category_id = Work_Category.objects.get(id=entry.category_id)

        # Convert time duration from seconds to formatted string
        hours, remainder = divmod(entry.time_entries_seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        duration_formatted = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

        start_date_formatted = entry.time_entries_start_date.strftime("%m/%d/%Y")

        # Format start_time and stop_time
        start_time_formatted = entry.time_entries_start_time.strftime("%I:%M %p")  # 12-hour format with AM/PM
        stop_time_formatted = entry.time_entries_stop_time.strftime("%I:%M %p")  # 12-hour format with AM/PM

        employee_ob = employee.objects.get(id=employee1.id)
        try:
            employee_country = Country.objects.get(id=employee_ob.country_id)
            if employee_country.code == 'US':
                country_city = 'America/New_York'
            elif employee_country.code == 'SA':
                country_city = 'Africa/Johannesburg'
            elif employee_country.code == 'UK':
                country_city = 'Europe/London'
            elif employee_country.code == 'PH':
                country_city = 'Asia/Manila'
            else:
                country_city = 'America/New_York'
        except Exception as e:
            country_city = 'America/New_York'
        print('country_city ',country_city)
        local_tz = pytz.timezone(country_city)

        start_datetime = datetime.combine(entry.time_entries_start_date, entry.time_entries_start_time)
        end_datetime = datetime.combine(entry.time_entries_stop_date, entry.time_entries_stop_time)

        start_datetime = start_datetime.astimezone(local_tz)
        end_datetime = end_datetime.astimezone(local_tz)
        

        total_duration_seconds += entry.time_entries_seconds

        if entry.description:
            description=entry.description
        else:
            description='No Description'

        project_data = None
        if entry.project_id:
            try:
                project_data = project.objects.get(id=int(entry.project_id))
            except ValueError:
                project_data = None
        print('Vinod project_data', project_data)
        # Add additional details to the entry dictionary
        entry_details = {
            'employee_name': employee1.user_name,
            'time': duration_formatted,
            'client_name': client1.toggl_client_name,
            'category_name': category_id.category,
            'project_name': project_data.project_name if project_data else '',
            'description': description,
            'start_date': start_date_formatted,
            'start_time': start_datetime.strftime("%I:%M %p").lstrip('0'),
            'stop_time': end_datetime.strftime("%I:%M %p").lstrip('0'),
            # 'start_time': start_time_formatted,
            # 'stop_time': stop_time_formatted,
            'employee_id': employee_id,
        }
        entries_with_details.append(entry_details)

    total_hours, remainder = divmod(total_duration_seconds, 3600)
    total_minutes, total_seconds = divmod(remainder, 60)

    # Format the total duration as desired
    total_duration_formatted = '{:02d}:{:02d}:{:02d}'.format(total_hours, total_minutes, total_seconds)

    print("Entries with details:")
    print(entries_with_details)

    print(employee_id)
    print(selected_client_ids)

    context={
        'entries_with_details':entries_with_details,
        "all_clients":all_clients,
        "selected_client_names": selected_client_names,
        'selected_client_ids': selected_client_ids,
        'total_selected_clients':total_selected_clients,
        'from_to_date':from_to_date,

        "all_employees":all_employees,
        'selected_employee_ids': selected_employee_ids,
        'total_selected_employees':total_selected_employees,
        'employee_id': employee_id,
        'total_time':total_duration_formatted

    }

    return render(request, 'employee_entries.html', context)

@csrf_exempt
@login_required(login_url='/')
def employee_category_details(request, employee_id, category_id):

    selected_client_ids = []
    selected_employee_ids = []

    # Calculate the date range for the last week
    if request.method == 'POST':
        from datetime import datetime, timedelta
        from_to_date = request.POST.get('from_to_date', None)
        print("companies111")
        print(from_to_date)

        # Split the string into "from" and "to" dates
        from_date_str, to_date_str = from_to_date.split(" - ")

        # Convert the date strings to datetime objects
        from_date = datetime.strptime(from_date_str, "%m/%d/%Y").date()
        to_date = datetime.strptime(to_date_str, "%m/%d/%Y").date()

        # Print the formatted dates
        print("From date:", from_date)
        print("To date:", to_date)

        # Convert start_date and end_date to datetime objects
        start_date = datetime.combine(from_date, datetime.min.time())
        end_date = datetime.combine(to_date, datetime.min.time())


        selected_client_ids = request.POST.getlist('client_id')
        print("akshay")
        print(selected_client_ids)

        selected_employee_ids = request.POST.getlist('employee_id')
        print("akshay33")
        print(selected_employee_ids)


    else:

        from datetime import datetime, timedelta

        # # Get current date
        # end_date = datetime.now().date()
        # # Calculate start date (7 days ago)
        # start_date = end_date - timedelta(days=6)

        start_date_str = request.GET.get('from')
        end_date_str = request.GET.get('to')

        # If the dates are present, convert them to datetime objects
        if start_date_str and end_date_str:
            from datetime import datetime
            start_date = datetime.fromisoformat(start_date_str)
            end_date = datetime.fromisoformat(end_date_str)

        else:
            selected_month = request.session.get('month')
            if selected_month:
                current_month = int(selected_month)
            else:
                current_month = 2

            selected_year = request.session.get('year')
            if selected_year:
                current_year = int(selected_year)
            else:
                current_year = 2026

            current_date = datetime.now()
            if current_month == current_date.month:
                start_date = current_date - timedelta(days=current_date.weekday())
                end_date = start_date + timedelta(days=6)
            else:
                start_date = datetime(current_year, current_month, 1, 0, 0, 0)
                end_date = datetime(current_year, current_month, calendar.monthrange(current_year, current_month)[1], 23, 59, 59)



        # Format the dates as desired
        formatted_start_date = start_date.strftime("%m/%d/%Y")
        formatted_end_date = end_date.strftime("%m/%d/%Y")

        # Concatenate the formatted dates
        formatted_date_range = f"{formatted_start_date} - {formatted_end_date}"

        print(formatted_date_range)
        from_to_date=formatted_date_range
        print("elsedatw")
        print(from_to_date)
            # Here, we ensure that the client_id is included in the selected_client_ids list
        if str(employee_id) not in selected_employee_ids:
            selected_employee_ids.append(str(employee_id))

    all_clients = client.objects.all()
    all_employees =employee.objects.filter(status__in=[1, 2])

    print("client)category_detailssssssssssssssssss")


    if selected_client_ids and selected_employee_ids:
        print("if sleected 11")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,
            employee_id__in=selected_employee_ids,
            category_id=category_id,
            status=None

        )

    elif selected_client_ids :
        print("if slecetdddddddddddddddddddddddddddd 222")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            client_id__in=selected_client_ids,
            category_id=category_id,
            status=None

        )

    elif selected_employee_ids:
        print("if 333333333333")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            employee_id__in=selected_employee_ids,
            category_id=category_id,
            status=None

        )
    else:
        print("else")
        time_entries_last_week = timeSheet.objects.filter(
            time_entries_start_date__gte=start_date,
            time_entries_stop_date__lte=end_date,
            category_id=category_id,
            status=None


        )


    # Fetch the client objects for the selected client IDs
    # Fetch the client objects for the selected client IDs
    selected_clients = client.objects.filter(id__in=selected_client_ids)
    selected_employees=employee.objects.filter(id__in=selected_employee_ids)

    # Create a list of tuples containing client ID and name for selected clients
    selected_client_names = [(client.id, client.toggl_client_name) for client in selected_clients]
    print(selected_client_names)


    total_selected_clients = len(selected_client_ids)
    print(selected_client_ids)
    print(total_selected_clients)

    total_selected_employees = len(selected_employee_ids)



    entries_with_details = []
    total_duration_seconds = 0

    for entry in time_entries_last_week:
        # Fetch employee details
        employee1 = employee.objects.get(id=entry.employee_id)

        # Fetch client details
        client1 = client.objects.get(id=entry.client_id)

        # Fetch category details (renamed variable to avoid overwriting category_id)
        category = Work_Category.objects.get(id=entry.category_id)

        # Convert time duration from seconds to formatted string
        hours, remainder = divmod(entry.time_entries_seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        duration_formatted = '{:02d}:{:02d}:{:02d}'.format(int(hours), int(minutes), int(seconds))

        start_date_formatted = entry.time_entries_start_date.strftime("%m/%d/%Y")

        # Format start_time and stop_time
        start_time_formatted = entry.time_entries_start_time.strftime("%I:%M %p")  # 12-hour format with AM/PM
        stop_time_formatted = entry.time_entries_stop_time.strftime("%I:%M %p")  # 12-hour format with AM/PM

        employee_ob = employee.objects.get(id=employee1.id)
        try:
            employee_country = Country.objects.get(id=employee_ob.country_id)
            if employee_country.code == 'US':
                country_city = 'America/New_York'
            elif employee_country.code == 'SA':
                country_city = 'Africa/Johannesburg'
            elif employee_country.code == 'UK':
                country_city = 'Europe/London'
            elif employee_country.code == 'PH':
                country_city = 'Asia/Manila'
            else:
                country_city = 'America/New_York'
        except Exception as e:
            country_city = 'America/New_York'
        print('country_city ',country_city)
        local_tz = pytz.timezone(country_city)

        start_datetime = datetime.combine(entry.time_entries_start_date, entry.time_entries_start_time)
        end_datetime = datetime.combine(entry.time_entries_stop_date, entry.time_entries_stop_time)

        start_datetime = start_datetime.astimezone(local_tz)
        end_datetime = end_datetime.astimezone(local_tz)

        total_duration_seconds += entry.time_entries_seconds

        if entry.description:
            description = entry.description
        else:
            description = 'No Description'

        project_data = None
        if entry.project_id:
            try:
                project_data = project.objects.get(id=int(entry.project_id))
            except ValueError:
                project_data = None
        print('Vinod project_data', project_data)
        # Add additional details to the entry dictionary
        entry_details = {
            'employee_name': employee1.user_name,
            'time': duration_formatted,
            'client_name': client1.toggl_client_name,
            'project_name': project_data.project_name if project_data else '',
            'category_name': category.category,
            'description': description,
            'start_date': start_date_formatted,
            # 'start_time': start_time_formatted,
            # 'stop_time': stop_time_formatted,
            'start_time': start_datetime.strftime("%I:%M %p").lstrip('0'),
            'stop_time': end_datetime.strftime("%I:%M %p").lstrip('0'),
            'employee_id': employee_id,
        }
        entries_with_details.append(entry_details)

    total_hours, remainder = divmod(total_duration_seconds, 3600)
    total_minutes, total_seconds = divmod(remainder, 60)

    # Format the total duration as desired
    total_duration_formatted = '{:02d}:{:02d}:{:02d}'.format(total_hours, total_minutes, total_seconds)
    #
    #
    print(entries_with_details)

    print(employee_id)
    print(category_id)
    # print(category_id.id)

    context={
        'entries_with_details':entries_with_details,
        "all_clients":all_clients,
        "selected_client_names": selected_client_names,
        'selected_client_ids': selected_client_ids,
        'total_selected_clients':total_selected_clients,
        'from_to_date':from_to_date,

        "all_employees":all_employees,
        'selected_employee_ids': selected_employee_ids,
        'total_selected_employees':total_selected_employees,
        'employee_id': employee_id,
        'category_id':category_id,
        'total_time':total_duration_formatted

    }

    return render(request, 'employee_category_details.html', context)


@csrf_exempt
@login_required(login_url='/')
def client_profile_export(request, client_id):


    selected_month = request.session.get('month')

    if selected_month:
        current_month = int(selected_month)
    else:
        current_month = 2

    if current_month == 1:
        last_month = 12
    else:
        last_month = current_month - 1

    selected_year = request.session.get('year')

    if selected_year:
        current_year = int(selected_year)
    else:
        current_year = 2026

    if current_month == 1:
        last_year = current_year - 1
    else:
        last_year = current_year

    start_date = datetime(current_year, current_month, 1, 0, 0, 0)
    current_month1 = datetime.now().month

    # Calculate end date

    end_date = datetime(current_year, current_month, calendar.monthrange(current_year, current_month)[1], 0, 0, 0)

    # Convert dates to string format
    start_date_str = start_date.strftime('%Y-%m-%d %H:%M:%S')
    end_date_str = end_date.strftime('%Y-%m-%d %H:%M:%S')

    print("Start date:", start_date_str)
    print("End date:", end_date_str)

    working_days = count_working_days_in_month(current_month, current_year)

    if start_date and end_date:
    # Print dates as date only
        start_date=start_date.date()
        end_date=end_date.date()
        print("devu")
        print(start_date)
        print(end_date)




    # month_list = create_month_list(start_date, end_date)
    # print(month_list)

    # Get the start and end months
    start_month = start_date.month
    end_month = end_date.month
    print(start_month)
    print(end_month)

    weeks=0
    ui_final_cost={}
    ui_total_hours={}
    ui_formatted_time2={}
    ui_data={}
    ui_client_data={}
    ui={}

    client_detail = client.objects.get(pk=client_id)
    toggl_client = client_detail.toggl_client_id
    client_details={}
    employee_names = {}
    if current_year == 2023 and 9 <= current_month <= 12:
        employee_details = {}
        print("if")
        print(start_date)
        print(end_date)
        print(current_year)
        print(toggl_client)
        #contracted employee images
        if contracted_hours.objects.filter(client_id=toggl_client).exists():
            # Use the contracted_hours model to query the database
            all = contracted_hours.objects.filter(client_id=toggl_client, month__month__range=(start_month, end_month),month__year=current_year)
            print("rekhaaaa")
            print(all)

            # Check if any records were found
            for record in all:
                # Access the first record in the QuerySet
                first_record = record

                date1=first_record
                print(date)

                date=date1.month

                target_month=date.month
                print(target_month)

                # Access the 'working_input' attribute
                work_json_str = first_record.working_input

                # Parse the JSON string
                work_dict = json.loads(work_json_str)

                # Fetch employee details including image URL based on employee IDs

                for employee_id, hours in work_dict.items():
                    try:
                        # Assuming Employee model has fields 'employee_id', 'first_name', 'last_name', 'user_name', and 'image_url'
                        employee1 = employee.objects.get(toggl_user_id=int(employee_id))

                        # Check if first name and last name are present, otherwise use username
                        if employee1.first_name and employee1.last_name:
                            employee_name = f"{employee1.first_name} {employee1.last_name}"
                        else:
                            employee_name = employee1.user_name

                        # Get the image URL
                        image_url = employee1.image_url if hasattr(employee1, 'image_url') else "/static/assets/img/client/default-profile-pic.jpg"

                        id=employee1.id
                        # Store employee details
                        employee_details[employee_id] = {'name': employee_name, 'image_url': image_url,'id':id}
                    except employee.DoesNotExist:
                        employee_details[employee_id] = {'name': f"Employee {employee_id} not found", 'image_url': "/static/assets/img/client/default-profile-pic.jpg"}
                #client total time contract


                import calendar
                from datetime import datetime
                # Get the number of days in that month

                # print(target_month)
                # print(start_date)
                # print(end_date)
                #
                # print(start_date_str)
                # print(end_date_str)


                target_month_start = start_date.replace(month=target_month, day=1)

                # Ensure that the start date is within the target month
                start_date_in_target_month = max(start_date, target_month_start)
                # print(start_date_in_target_month)

                # Get the end date of the target month
                if start_date_in_target_month.month == target_month:
                    # print("if")
                    # If the start date is in the target month, use the end of the month
                    # print("end_date")
                    # print(end_date)

                    target_month_end = min(start_date.replace(month=target_month + 1, day=1) - datetime.resolution, end_date)
                else:
                    # print("else")
                    # If the start date is not in the target month, use the end of the start month
                    target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                # print(target_month_end)
                # Calculate the total days in the target month between the start and end dates
                if target_month_end.month==start_date_in_target_month.month:
                    total_days_between = (target_month_end - start_date_in_target_month).days+1
                else:
                    total_days_between = (target_month_end - start_date_in_target_month).days


                # # Print the total number of days in the specified month between the start and end dates
                # print(f"Total days between {start_date_str} and {end_date_str} in the target month: {total_days_between}")

                date_difference=total_days_between

                days_in_month = calendar.monthrange(date.year, date.month)[1]
                # print(days_in_month)

                # print(days_in_month)

                if date_difference==days_in_month:
                    weeks=4.3
                else:
                    weeks = date_difference / 7

                total_hours1 = float(first_record.total_working_hours) * weeks
                if 'total_time_hours' in client_details:
                    client_details['total_time_hours'] += total_hours1
                else:
                    client_details['total_time_hours'] = total_hours1

                print("rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr")
                print(total_hours1)

                # Convert total hours to total seconds
                total_seconds1 = int(client_details['total_time_hours'] * 3600)

                # Extracting hours, minutes, and seconds
                hoursss1, remainder1 = divmod(total_seconds1, 3600)
                minutes1, seconds1 = divmod(remainder1, 60)

                # Formatting the time
                formatted_time2 = f"{hoursss1:02d}:{minutes1:02d}:{seconds1:02d}"

                import calendar
                from datetime import datetime
                # Calculate the difference between end_date and start_date

                target_month_start = start_date.replace(month=target_month, day=1)

                # Ensure that the start date is within the target month
                start_date_in_target_month = max(start_date, target_month_start)
                # print(start_date_in_target_month)

                # Get the end date of the target month
                if start_date_in_target_month.month == target_month:
                    # print("if")
                    # If the start date is in the target month, use the end of the month
                    # print("end_date")
                    # print(end_date)

                    target_month_end = min(start_date.replace(month=target_month + 1, day=1) - datetime.resolution, end_date)
                else:
                    # print("else")
                    # If the start date is not in the target month, use the end of the start month
                    target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                # print(target_month_end)
                # Calculate the total days in the target month between the start and end dates
                print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
                print(start_date_in_target_month)
                print(target_month_end)
                if target_month_end.month==start_date_in_target_month.month:
                    print("if")
                    total_days_between = (target_month_end - start_date_in_target_month).days+1
                else:
                    print("else")
                    total_days_between = (target_month_end - start_date_in_target_month).days


                # # Print the total number of days in the specified month between the start and end dates
                # print(f"Total days between {start_date_str} and {end_date_str} in the target month: {total_days_between}")

                date_difference=total_days_between

                days_in_month = calendar.monthrange(date.year, date.month)[1]

                # print(days_in_month)
                print("differneceeeeeee11")
                print(date_difference)


                if date_difference==days_in_month:
                    weeks=4.3
                    weeks=round(weeks,2)
                    cost_new=first_record.rate

                    print("if--------------------------------------------")
                    print("costtttttttttttttt")
                else:
                    weeks = date_difference / 7
                    weeks=round(weeks,2)
                    c=round((first_record.rate * weeks) , 2)
                    cost_new = round((c) / 4.3, 2)

                if 'cost' in client_details:

                    print(cost_new)
                    client_details['cost'] += cost_new
                    client_details['total_working_hours'] = formatted_time2
                else:

                    client_details['cost'] = cost_new
                    client_details['total_working_hours'] = formatted_time2
                    client_details['total_time_hours']=total_hours1

                client_details['cost']=round(client_details['cost'],2)
                # Print the employee details
                for employee_id, details in employee_details.items():
                    print(f"Employee ID: {employee_id}, Employee Name: {details['name']}, Image URL: {details['image_url']}")
            else:
                print("No records found for the specified client and month.")
        else:
            print("No contracted hours found for the specified client.")

        print(employee_details)
        print(client_details)


        # for work category below boxes
        project_list = project.objects.filter(toggl_client_id=toggl_client)
        print("project_list1")
        print(project_list)
        print("datessssssssssssssssssssssssssss")
        print(start_date)
        print(end_date)
        # Iterate through the project_list and get toggl_project_id for each project
        toggl_project_ids = [project.toggl_project_id for project in project_list]
        filtered_records = toggl_user_detail.objects.filter(
        project_id__in=toggl_project_ids,
        time_entries_start_date__range=(start_date, end_date)
        )
        print(filtered_records)
        unique_project_ids = filtered_records.values('project_id').distinct()
        print(unique_project_ids)

        # Query the Project table to get names of unique project IDs
        project_names = project.objects.filter(toggl_project_id__in=unique_project_ids)
        print("lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll")
        # Now you can display project names on the UI
        print(project_names)

        #working time on toggl

        # Create a dictionary to store the total time spent per client and project
        total_time_spent = {}
        project_rate = {}

        for record in filtered_records:
            # Fetch project details from toggl_project_detail
            project_id_1 = record.project_id

            # project_id_2 = project.objects.filter(toggl_project_id=project_id_1).first()
            # project_id = project_id_2.id
            time_seconds = record.time_entries_seconds

            if project_id_1:
                client_project_key = int(project_id_1)
                if client_project_key in total_time_spent:
                    total_time_spent[client_project_key] += time_seconds
                else:
                    # If the key doesn't exist, create it
                    total_time_spent[client_project_key] = time_seconds
        # Now, total_time_spent dictionary contains the total time spent per client and project
        # You can iterate through it to display the results
        print("client revenue")
        print(total_time_spent)
        print(project_rate)

        total_time_spent_formatted = {}
        for key, seconds in total_time_spent.items():
            hours, remainder = divmod(seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            total_time_spent_formatted[key] = f"{hours:02d}:{minutes:02d}:{seconds:02d}"

        # Now, total_time_spent_formatted dictionary contains the total time spent per client and project in HH:MM:SS format
        # You can iterate through it to display the results
        # print(total_time_spent_formatted)
        for key, formatted_time in total_time_spent_formatted.items():
            print(f"Project {key}: {formatted_time}")


        #project member images on toggl

        project_user_dict_1 = {}

        # Iterate through each project_id
        for project_id in toggl_project_ids:
            # Get unique user_id values for the specified project_id
            user_ids = toggl_user_detail.objects.filter(
                project_id=project_id,
                time_entries_start_date__range=(start_date, end_date)
            ).values_list('user_id', flat=True).distinct()

            # Assign the user_ids to the dictionary with project_id as the key
            project_user_dict_1[project_id] = list(user_ids)

        print("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5")
        print(project_user_dict_1)

        project_user_dict={}

        for project_id, user_ids in project_user_dict_1.items():
            # Initialize a dictionary to store total time spent by each employee on the current project
            total_time_spent_per_project = {}

            for user_id in user_ids:
                # Calculate total time spent by the current user on the current project
                total_time_spent_per_project[user_id] = toggl_user_detail.objects.filter(
                    user_id=user_id,
                    project_id=project_id,
                    time_entries_start_date__range=(start_date, end_date)
                ).aggregate(total_time_spent=Sum('time_entries_seconds'))['total_time_spent'] or 0

            # Fetch employee data for the current project
            employees_data = employee.objects.filter(toggl_user_id__in=user_ids).values('id', 'first_name',
                                                                                        'last_name', 'salary',
                                                                                        'image_url', 'user_name','toggl_user_id').distinct()

            # Update project_user_dict with image_urls, full names, and total time spent for each project_id
            project_user_dict[project_id] = [
                {
                    'id': data['id'],
                    'salary': float(data['salary']),
                    'image_url': data['image_url'],
                    'full_name': f"{data['first_name']} {data['last_name']}",
                    'user_name': data['user_name'],
                    'toggl_user_id': data['toggl_user_id'],
                    'total_time_spent_per_project': total_time_spent_per_project.get(data['toggl_user_id'], 0)
                    # Retrieve total time spent for each employee on the current project
                }
                for data in employees_data]

        print(project_user_dict)


        employee_rate_per_hour = {}

        for project_id, employee_data in project_user_dict.items():
            total_project_cost = 0
            for employee_info in employee_data:
                # Calculate employee's hourly rate
                working_days_per_month = 22
                hours_per_day = 8
                hourly_rate = employee_info['salary'] / (working_days_per_month * hours_per_day)  # Assuming 22 working days and 8 working hours per day
                # Calculate total cost for the employee on the project
                employee_cost = hourly_rate * (employee_info['total_time_spent_per_project'] / 3600)  # Convert seconds to hours
                total_project_cost += employee_cost

            # Store total project cost in the dictionary
            total_project_cost = "{:.2f}".format(total_project_cost)
            employee_rate_per_hour[project_id] = total_project_cost
        print("new cost")
        print(employee_rate_per_hour)

        # Initialize a variable to store the sum of rates
        sum_of_rates_employee = 0.0

        # Iterate through the "Project Rate per Hour" dictionary and add up the rates
        for project_id, rate in employee_rate_per_hour.items():
            sum_of_rates_employee += float(rate)

        # Format total_rate to have 2 decimal places
        sum_of_rates_employee = "{:.2f}".format(sum_of_rates_employee)
        # Print the sum of rates
        print("Sum of Rates Employee:", sum_of_rates_employee)



        #client revenue
        client_detail = client.objects.get(pk=client_id)
        toggl_client = client_detail.toggl_client_id
             # Filter contracted hours for the project and current month
        # if contracted_hours.objects.filter(client_id=toggl_client,month__month=current_month,month__year=current_year).exists():
        #     contracted_hours_for_month = contracted_hours.objects.filter(client_id= toggl_client,month__month=current_month,month__year=current_year
        #         )
        #     first_contracted_hour = contracted_hours_for_month.first()
        #
        #        # Access the rate attribute if the instance exists, otherwise set project_salary to 100
        #         # Set project_salary based on conditions
        #
        #     one_project_rate = first_contracted_hour.rate
        # else:
        #     one_project_rate=0
        #
        #
        # print("Sum of Rates Client revenue:", one_project_rate)

        if contracted_hours.objects.filter(client_id=toggl_client,month__month__range=[start_month, end_month],month__year=current_year).exists():
        # Filter contracted hours for the project and current month
            contracted_hours_for_month = contracted_hours.objects.filter(client_id= toggl_client,month__month__range=[start_month, end_month],month__year=current_year
                )

            print("88888888888888888888888888888888888888888888888")
            print(contracted_hours_for_month)
            # first_contracted_hour = contracted_hours_for_month.first()
            one_project_rate=0
            for entry in contracted_hours_for_month:

                date1=entry
                # print(date)

                date=date1.month

                target_month=date.month
                # print(target_month)

                print(target_month)

                import calendar
                from datetime import datetime
                # Calculate the difference between end_date and start_date
                target_month_start = start_date.replace(month=target_month, day=1)

                # Ensure that the start date is within the target month
                start_date_in_target_month = max(start_date, target_month_start)
                # print(start_date_in_target_month)

                # Get the end date of the target month
                if start_date_in_target_month.month == target_month:
                    # print("if")
                    # # If the start date is in the target month, use the end of the month
                    # print("end_date")
                    # print(end_date)

                    target_month_end = min(start_date.replace(month=target_month + 1, day=1) - datetime.resolution, end_date)
                else:
                    print("else")
                    # If the start date is not in the target month, use the end of the start month
                    target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                print(target_month_end)
                # Calculate the total days in the target month between the start and end dates
                if target_month_end.month==start_date_in_target_month.month:
                    total_days_between = (target_month_end - start_date_in_target_month).days+1
                else:
                    total_days_between = (target_month_end - start_date_in_target_month).days


                # Print the total number of days in the specified month between the start and end dates
                print(f"Total days between {start_date_str} and {end_date_str} in the target month: {total_days_between}")

                date_difference=total_days_between

                # Get the number of days in that month
                days_in_month = calendar.monthrange(date.year, date.month)[1]

                # print(days_in_month)
                if one_project_rate:
                    if date_difference==days_in_month:
                        weeks=4.3
                        weeks=round(weeks,2)
                        print(entry.rate)
                        one_project_rate+=entry.rate
                        print("if")
                    else:
                        weeks = date_difference / 7
                        weeks=round(weeks,2)
                        one_project_rate +=round((entry.rate * weeks) / 4.3, 2)
                        print("else")
                else:
                    if date_difference==days_in_month:
                        weeks=4.3
                        weeks=round(weeks,2)
                        print(entry.rate)
                        one_project_rate=entry.rate
                        print("ifff2")
                    else:
                        weeks = date_difference / 7
                        weeks=round(weeks,2)
                        one_project_rate = round((entry.rate * weeks) / 4.3, 2)
                        print("else222")


            # one_project_rate = first_contracted_hour.cost
        else:
            one_project_rate=0


        one_project_rate=round(one_project_rate,2)
        print("kajal")
        print("Sum of Rates Client revenue:", one_project_rate)
        #new contracted
        employee_salary_dict={}
        if contracted_hours.objects.filter(client_id=toggl_client,month__month__range=[start_month, end_month],month__year=current_year).exists():
            contracted_client1 = contracted_hours.objects.filter(client_id=toggl_client,month__year=current_year,month__month__range=[start_month, end_month])
            # contracted_client = contracted_hours.objects.get(client_id=client_id1,month=current_month)

            for contracted_client in contracted_client1:
                date1=contracted_client
                # print(date)

                date=date1.month

                target_month=date.month
                # print(target_month)

                print(target_month)
                import ast
                from decimal import Decimal
                import calendar
                from datetime import datetime
                target_month_start = start_date.replace(month=target_month, day=1)

                # Ensure that the start date is within the target month
                start_date_in_target_month = max(start_date, target_month_start)
                # print(start_date_in_target_month)

                # Get the end date of the target month
                if start_date_in_target_month.month == target_month:
                    # print("if")
                    # # If the start date is in the target month, use the end of the month
                    # print("end_date")
                    # print(end_date)

                    target_month_end = min(start_date.replace(month=target_month + 1, day=1) - datetime.resolution, end_date)
                else:
                    print("else")
                    # If the start date is not in the target month, use the end of the start month
                    target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                print(target_month_end)
                # Calculate the total days in the target month between the start and end dates
                if target_month_end.month==start_date_in_target_month.month:
                    total_days_between = (target_month_end - start_date_in_target_month).days+1
                else:
                    total_days_between = (target_month_end - start_date_in_target_month).days


                # Print the total number of days in the specified month between the start and end dates
                print(f"Total days between {start_date_str} and {end_date_str} in the target month: {total_days_between}")

                date_difference=total_days_between

                # Get the number of days in that month
                days_in_month = calendar.monthrange(date.year, date.month)[1]

                print(days_in_month)

                if date_difference==days_in_month:
                    weeks=4.3
                else:
                    weeks = date_difference / 7
                print(date_difference)
                print("###########################")
                print(weeks)

                contracted_working_hours_1 = contracted_client.working_input
                print(contracted_working_hours_1)
                contracted_hours_for_project=contracted_client.total_working_hours
                print("contracted")
                print(contracted_hours_for_project)
                    # Convert the JSON string to a dictionary
                contracted_working_hours_1_dict1 = json.loads(contracted_working_hours_1)
                print('muksn')
                print(contracted_working_hours_1_dict1)
                contracted_working_hours_1_dict = {key.strip(): value for key, value in contracted_working_hours_1_dict1.items()}
                # Fetch the hourly rate for the user from the Employee table
                employee_ids = list(contracted_working_hours_1_dict.keys())
                print(employee_ids)
                # Fetch hourly rate for each employee
                hourly_rates = {}
                hourly_rate=0
                for emp_id in employee_ids:
                    try:
                        employee1 = employee.objects.get(toggl_user_id=emp_id)
                        hourly_rates[emp_id] = employee1.salary
                        print("salary")
                        print(hourly_rates[emp_id])

                    except employee.DoesNotExist:
                        print(f"Employee with ID {emp_id} not found.")

                # Calculate total salary
                total_salary = sum(hourly_rates[emp_id] for emp_id in employee_ids)
                print(total_salary)



                if contracted_hours_for_project != 0:
                    print("calculation")
                    print(total_salary)
                    print(contracted_hours_for_project)
                    hourly_rate1 = float(total_salary) / (22*8)
                    print(hourly_rate1)
                    hourly_rate=hourly_rate1 * contracted_hours_for_project * weeks
                    print(hourly_rate)

                else:
                    contracted_hours_for_project = 0
                    total_salary=0
                    hourly_rate = 0

                if int(emp_id) in employee_salary_dict:
                        print("ifff")
                        # If it exists, add the new salary to the existing one
                        employee_salary_dict[int(employee_id)] += hourly_rate
                        employee_salary_dict[int(employee_id)] = round(employee_salary_dict[int(employee_id)], 2)

                else:
                    print("else")
                    # If it doesn't exist, create a new entry
                    employee_salary_dict[int(emp_id)] = hourly_rate
                    employee_salary_dict[int(emp_id)] = round(employee_salary_dict[int(employee_id)], 2)


        contracted_sum_of_rates_employee=0.0
        # Convert all values in employee_salary_dict to float
        employee_salary_dict = {k: float(v) for k, v in employee_salary_dict.items()}

        # Sum the values in employee_salary_dict
        contracted_sum_of_rates_employee = sum(employee_salary_dict.values())
        contracted_sum_of_rates_employee = "{:.2f}".format(contracted_sum_of_rates_employee)
        print("Total contracted sum of rates for employees:", contracted_sum_of_rates_employee)


        client_category_list={}
        employee_info_dict={}
        category_time_dict={}
        category_cost_dict={}

        category_time_dict_client={}
        employee_data={}
        employee_salary_dict={}


    else:
        employee_details = {}
        client_details={}
        ui_client_data=[]
        #contracted employee images
        if Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month]).exists():
                # Use the contracted_hours model to query the database
            all = Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month])
            print("lllllllllllllllllllllllllllllllll")
            print(all)

            # Check if any records were found
            # Iterate over each record in the queryset
            for record in all:
                print("ppppppppppppppppppppppppppppppppppppppppppppp")
                # Access the current record in the queryset
                first_record = record
                print(first_record)

                ui_final_cost=first_record.cost
                print(ui_final_cost)

                date1=first_record
                print(date)

                date=date1.date

                target_month=date.month
                print(target_month)

                # Access the 'working_input' attribute
                work_json_str = first_record.working_input

                # Parse the JSON string
                work_dict = json.loads(work_json_str)

                # Access the 'working_role' attribute
                role_json_str = first_record.working_role

                # Parse the JSON string for role information
                role_dict = json.loads(role_json_str)

                # Fetch employee details including image URL based on employee IDs

                for employee_id, hours in work_dict.items():
                    try:
                        # Assuming Employee model has fields 'employee_id', 'first_name', 'last_name', 'user_name', and 'image_url'
                        employee1 = employee.objects.get(id=int(employee_id))

                        # Check if first name and last name are present, otherwise use username
                        if employee1.first_name and employee1.last_name:
                            employee_name = f"{employee1.first_name} {employee1.last_name}"
                        else:
                            employee_name = employee1.user_name

                        # Get the image URL
                        image_url = employee1.image_url if hasattr(employee1, 'image_url') else "/static/assets/img/client/default-profile-pic.jpg"

                        id=employee1.id
                        salary = get_salary_for_date(employee1, date)
                        # Store employee details
                        # Get the role
                        role = role_dict.get(employee_id, "Unknown")
                        #employee time
                        # print(hours)


                        import calendar
                        from datetime import datetime
                        # # Calculate the difference between end_date and start_date
                        # date_difference = (end_date - start_date).days
                        # # Add 1 to the difference in day
                        # date_difference += 1

                        print(target_month)
                        print(start_date)
                        print(end_date)

                        print(start_date_str)
                        print(end_date_str)


                        target_month_start = start_date.replace(month=target_month, day=1)

                        # Ensure that the start date is within the target month
                        start_date_in_target_month = max(start_date, target_month_start)
                        print(start_date_in_target_month)

                        # Get the end date of the target month
                        if start_date_in_target_month.month == target_month:
                            print("if")
                            # If the start date is in the target month, use the end of the month
                            
                            if target_month == 12:
                                next_month_date = start_date.replace(year=start_date.year + 1, month=1, day=1)
                            else:
                                next_month_date = start_date.replace(month=target_month + 1, day=1)

                            # Calculate target month end
                            target_month_end = min(next_month_date - timedelta(days=1), end_date)                            
                        else:
                            print("else")
                            # If the start date is not in the target month, use the end of the start month
                            target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                        print('Vinod December target_month_end')
                        print(start_date_in_target_month.month)
                        print(target_month)
                        # Calculate the total days in the target month between the start and end dates
                        if target_month_end.month==start_date_in_target_month.month:
                            total_days_between = (target_month_end - start_date_in_target_month).days+1
                        else:
                            total_days_between = (target_month_end - start_date_in_target_month).days


                        # Print the total number of days in the specified month between the start and end dates
                        print(f"Total days between {start_date_str} and {end_date_str} in the target month: {total_days_between}")

                        date_difference=total_days_between
                        # Get the number of days in that month
                        days_in_month = calendar.monthrange(date.year, date.month)[1]

                        # print(days_in_month)

                        if date_difference==days_in_month:
                            # weeks=4.3
                            weeks = round(days_in_month / 7, 2)
                        else:
                            weeks = date_difference / 7



                        # Convert hours to an integer
                        hours = float(hours)


                        if int(employee_id) in employee_details:

                            print("777777777777777777777777777777777777")
                            print(hours)

                            employee_details[int(employee_id)]['total_hours'] += hours
                            total_hours = float(employee_details[int(employee_id)]['total_hours'])  * weeks
                        else:
                            total_hours = float(hours)  * weeks



                        # print("rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr")
                        # print("muskannnnnnnnnnnnnnnnnnnnnnnnnn")
                        # print(total_hours)

                        # Convert total hours to total seconds
                        total_seconds = int(total_hours * 3600)

                        # Extracting hours, minutes, and seconds
                        hoursss, remainder = divmod(total_seconds, 3600)
                        minutes, seconds = divmod(remainder, 60)

                        # Formatting the time
                        formatted_time = f"{hoursss:02d}:{minutes:02d}:{seconds:02d}"

                        # if int(employee_id) in employee_details:
                        #
                        #     new_role = role_dict.get(employee_id)
                        #     if new_role not in employee_details[int(employee_id)]['role']:
                        #         employee_details[int(employee_id)]['role'].append(new_role)
                        if int(employee_id) in employee_details:
                            new_role = role_dict.get(employee_id)
                            # Use set to avoid duplicates
                            current_roles = set(employee_details[int(employee_id)]['role'])
                            if new_role not in current_roles:
                                # Convert back to list after ensuring it's not already a list
                                employee_details[int(employee_id)]['role'] = list(current_roles | {new_role})

                            # Add hours worked to existing hours
                            employee_details[int(employee_id)]['hours_worked'] = formatted_time
                        else:
                            employee_details[int(employee_id)] = {'name': employee_name, 'image_url': image_url,'id':id,'salary':salary,'role': role,'hours_worked':formatted_time,'total_hours':hours}
                    except employee.DoesNotExist:
                        employee_details[int(employee_id)] = {'name': f"Employee {employee_id} not found", 'image_url': "/static/assets/img/client/default-profile-pic.jpg"}
                #client total time contract
                if first_record.total_working_hours:

                    import calendar
                    from datetime import datetime
                    # Get the number of days in that month

                    # print(target_month)
                    # print(start_date)
                    # print(end_date)
                    #
                    # print(start_date_str)
                    # print(end_date_str)


                    target_month_start = start_date.replace(month=target_month, day=1)

                    # Ensure that the start date is within the target month
                    start_date_in_target_month = max(start_date, target_month_start)
                    # print(start_date_in_target_month)

                    # Get the end date of the target month
                    if start_date_in_target_month.month == target_month:
                        # print("if")
                        # If the start date is in the target month, use the end of the month
                        # print("end_date")
                        # print(end_date)
                        if target_month == 12:
                            next_month_date = start_date.replace(year=start_date.year + 1, month=1, day=1)
                        else:
                            next_month_date = start_date.replace(month=target_month + 1, day=1)

                        # Calculate target month end
                        target_month_end = min(next_month_date - timedelta(days=1), end_date)
                    else:
                        # print("else")
                        # If the start date is not in the target month, use the end of the start month
                        target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                    # print(target_month_end)
                    # Calculate the total days in the target month between the start and end dates
                    if target_month_end.month==start_date_in_target_month.month:
                        total_days_between = (target_month_end - start_date_in_target_month).days+1
                    else:
                        total_days_between = (target_month_end - start_date_in_target_month).days


                    # # Print the total number of days in the specified month between the start and end dates
                    # print(f"Total days between {start_date_str} and {end_date_str} in the target month: {total_days_between}")

                    date_difference=total_days_between

                    days_in_month = calendar.monthrange(date.year, date.month)[1]
                    # print(days_in_month)

                    # print(days_in_month)

                    if date_difference==days_in_month:
                        # weeks=4.3
                        weeks = round(days_in_month / 7, 2)
                    else:
                        weeks = date_difference / 7
                    total_hours1 = float(first_record.total_working_hours) * weeks
                    ui_total_hours=first_record.total_working_hours
                else:
                    total_hours1 = 0
                    ui_total_hours=0

                print("rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr/////////////////////////////////")

                if 'total_time_hours' in client_details:
                    client_details['total_time_hours'] += total_hours1
                else:
                    client_details['total_time_hours'] = total_hours1


                # Convert total hours to total seconds
                total_seconds1 = int(client_details['total_time_hours'] * 3600)

                # Extracting hours, minutes, and seconds
                hoursss1, remainder1 = divmod(total_seconds1, 3600)
                minutes1, seconds1 = divmod(remainder1, 60)

                # print("qqqqqqqqqqqqqqqqqqqqqqqqq")
                # print(hoursss1)
                # print(minutes1)
                # print(seconds1)

                import calendar
                from datetime import datetime
                # Calculate the difference between end_date and start_date

                target_month_start = start_date.replace(month=target_month, day=1)

                # Ensure that the start date is within the target month
                start_date_in_target_month = max(start_date, target_month_start)
                # print(start_date_in_target_month)

                # Get the end date of the target month
                if start_date_in_target_month.month == target_month:
                    # print("if")
                    # If the start date is in the target month, use the end of the month
                    # print("end_date")
                    # print(end_date)
                    if target_month == 12:
                        next_month_date = start_date.replace(year=start_date.year + 1, month=1, day=1)
                    else:
                        next_month_date = start_date.replace(month=target_month + 1, day=1)

                    # Calculate target month end
                    target_month_end = min(next_month_date - timedelta(days=1), end_date)
                else:
                    # print("else")
                    # If the start date is not in the target month, use the end of the start month
                    target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                # print(target_month_end)
                # Calculate the total days in the target month between the start and end dates
                print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
                print(start_date_in_target_month)
                print(target_month_end)
                if target_month_end.month==start_date_in_target_month.month:
                    print("if")
                    total_days_between = (target_month_end - start_date_in_target_month).days+1
                else:
                    print("else")
                    total_days_between = (target_month_end - start_date_in_target_month).days


                # # Print the total number of days in the specified month between the start and end dates
                # print(f"Total days between {start_date_str} and {end_date_str} in the target month: {total_days_between}")

                date_difference=total_days_between

                days_in_month = calendar.monthrange(date.year, date.month)[1]

                # print(days_in_month)
                print("differneceeeeeee11")
                print(date_difference)


                if date_difference==days_in_month:
                    # weeks=4.3
                    weeks = round(days_in_month / 7, 2)
                    cost_new=first_record.cost

                    print("if--------------------------------------------")
                    print("costtttttttttttttt")
                else:
                    weeks = date_difference / 7
                    weeks=round(weeks,2)
                    c=round((first_record.cost * weeks) , 2)
                    cost_new = round((c) / weeks, 2)

                # Formatting the time
                formatted_time2 = f"{hoursss1:02d}:{minutes1:02d}:{seconds1:02d}"
                ui_formatted_time2=formatted_time2
                print("time================================")
                print(formatted_time2)
                print(cost_new)

                if 'cost' in client_details:
                    client_details['cost'] += cost_new
                    client_details['total_working_hours'] = formatted_time2
                else:
                    client_details['cost'] = cost_new
                    client_details['total_working_hours'] = formatted_time2
                    client_details['total_time_hours']=total_hours1

                client_details['cost']=round(client_details['cost'],2)
                ui_client_data1 = {

                        'ui_cost': first_record.cost,
                        'ui_weeks': weeks,
                        'ui_date_difference':date_difference
                    }

                    # Append this dictionary to the list
                ui_client_data.append(ui_client_data1)
                # client_details = {'cost': cost_new,'total_working_hours':formatted_time2}
                # Print the employee details
                for employee_id, details in employee_details.items():
                    print(f"Employee ID: {employee_id}, Employee Name: {details['name']}, Image URL: {details['image_url']}")
        else:
            print("No contracted hours found for the specified client.")
        print("ghhhhh")

        print(client_details)

        #new clients tab on client



        #end of clients tab

        # for work category below boxes
        # Assuming your models are imported and project_list is obtained as in your code

        # Get unique category IDs for a specific client
        unique_category_ids = timeSheet.objects.filter(client_id=client_id,time_entries_start_date__range=(start_date, end_date)).values('category_id').distinct()

        # Prepare a list to store client and category information
        client_category_list = []

        # Iterate over unique category IDs and fetch corresponding category names
        for unique_category_id in unique_category_ids:

            category_id = unique_category_id['category_id']

            # Fetch the corresponding category name from the WorkCategory table
            try:


                category_1 = Work_Category.objects.get(id=category_id)
                category_name = category_1.category

                # Append client and category information to the list
                client_category_list.append({'id': category_id, 'category_name': category_name})

            except Work_Category.DoesNotExist:
                print(f"Category with ID {category_id} does not exist in the WorkCategory table.")

        # Now client_category_list contains client IDs and corresponding category names
        # You can use this list to pass information to your UI or perform further processing
        print("client_category_list")
        print(client_category_list)

       # project member of timer
        # Get unique timeSheet entries for a specific client
        unique_timesheet_entries = timeSheet.objects.filter(client_id=client_id,time_entries_start_date__range=(start_date, end_date)).values('category_id', 'employee_id').distinct()

        # Prepare a dictionary to store employee information
        employee_info_dict = {}

        # Iterate over unique timeSheet entries
        for timesheet_entry in unique_timesheet_entries:
            category_id = timesheet_entry['category_id']
            employee_id = timesheet_entry['employee_id']

            # Fetch the employee from the Employee table
            try:
                employee1 = employee.objects.get(id=employee_id)
                employee_name = f"{employee1.first_name} {employee1.last_name}"
                employee_image_url = employee1.image_url
                employee_salary = get_salary_for_date(employee1, start_date)

                # Check if the category exists in the dictionary, if not, create an entry
                if category_id not in employee_info_dict:
                    employee_info_dict[category_id] = []

                # Append employee information to the dictionary
                employee_info_dict[category_id].append({
                    'id': employee_id,
                    'name': employee_name,
                    'image_url': employee_image_url,
                    'salary':employee_salary
                })

            except employee.DoesNotExist:
                print(f"Employee with ID {employee_id} does not exist in the Employee table.")

        # Now employee_info_dict contains information about employees in each category
        # You can use this dictionary to look up employees based on the category
        print("kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk")
        print(employee_info_dict)

        #working time for timer
        # Calculate total time spent for all distinct category_id values for the given client_id
        # total_time_spent_by_category = timeSheet.objects.filter(client_id=client_id) \
        #                                                .values('category_id') \
        #                                                .annotate(total_time=Sum('time_entries_seconds'))

        total_time_spent_by_category = timeSheet.objects.filter(client_id=client_id,
                                                        time_entries_start_date__gte=start_date,
                                                        time_entries_stop_date__lte=end_date) \
                                                 .values('category_id') \
                                                 .annotate(total_time=Sum('time_entries_seconds'))

        # Create a dictionary to store category_id and total time spent
        category_time_dict = {}

        # Loop through the results to populate the dictionary
        for entry in total_time_spent_by_category:
            category_id = entry['category_id']
            total_time_spent_seconds = entry['total_time']

            # Convert total_time_spent_seconds to a more readable format
            total_time_spent_hours, remainder = divmod(total_time_spent_seconds, 3600)
            total_time_spent_minutes, total_time_spent_seconds = divmod(remainder, 60)

            # Store the values in the dictionary
            category_time_dict[category_id] = {
                'formatted_time': f"{total_time_spent_hours:02d}:{total_time_spent_minutes:02d}:{total_time_spent_seconds:02d}",
                'total_time_seconds':entry['total_time'],
                'hours': total_time_spent_hours,
                'minutes': total_time_spent_minutes,
                'seconds': total_time_spent_seconds
            }

        # Print or use the category_time_dict as needed
        print(category_time_dict)

        print("kiki")
        total_time_spent_by_client = timeSheet.objects.filter(
        client_id=client_id,
        time_entries_start_date__gte=start_date,  # Filter based on start date
        time_entries_stop_date__lte=end_date     # Filter based on end date
        ).values('client_id', 'employee_id').annotate(total_time=Sum('time_entries_seconds'))
        print(total_time_spent_by_client)
        # Create a dictionary to store category_id and total time spent
        category_time_dict_client = {}

        # Loop through the results to populate the dictionary
        for entry in total_time_spent_by_client:
            employee_id = entry['employee_id']
            client_id = entry['client_id']
            total_time_spent_seconds = entry['total_time']

            # Convert total_time_spent_seconds to a more readable format
            total_time_spent_hours, remainder = divmod(total_time_spent_seconds, 3600)
            total_time_spent_minutes, total_time_spent_seconds = divmod(remainder, 60)

            # Store the values in the dictionary
            category_time_dict_client[employee_id] = {
                'formatted_time': f"{total_time_spent_hours:02d}:{total_time_spent_minutes:02d}:{total_time_spent_seconds:02d}",
                'total_time_seconds':entry['total_time'],
                'client_id':entry['client_id'],
                'hours': total_time_spent_hours,
                'minutes': total_time_spent_minutes,
                'seconds': total_time_spent_seconds
            }
        print(category_time_dict_client)

        if Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month]).exists():
                # Use the contracted_hours model to query the database
            all = Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month])
            print("lllllllllllllllllllllllllllllllll")
            print(all)

            # Check if any records were found
            # Iterate over each record in the queryset
            for record in all:
                print("ppppppppppppppppppppppppppppppppppppppppppppp")
                # Access the current record in the queryset
                first_record = record
                print(first_record)

                # Access the 'working_input' attribute
                work_json_str = first_record.working_input

                # Parse the JSON string
                work_dict = json.loads(work_json_str)

                print("jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj")
                print(work_dict)
                for employee_id in work_dict.keys():
                    if int(employee_id) not in category_time_dict_client:
                        category_time_dict_client[int(employee_id)] = {
                            'formatted_time': '00:00:00',
                            'total_time_seconds': 0,
                            'client_id': '',  # You may set this to appropriate default value
                            'hours': 0,
                            'minutes': 0,
                            'seconds': 0
                        }

        # Print or use the category_time_dict as needed
        print("birth")
        print(category_time_dict_client)
        print(category_time_dict)

        #employee cost in task tab

        print("employeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee")
        print(employee_info_dict)
        # Create a dictionary to store category_id and total cost
        category_cost_dict = {}

        # Iterate over the categories in employee_info_dict
        for category_id, employees in employee_info_dict.items():
            total_salary = 0

            # Calculate total salary for employees in the category
            for employee_info in employees:
                if employee_info['salary']:
                    total_salary += float(employee_info['salary'])  # Convert Decimal to float

            # Calculate cost per hour
            cost_per_hour = total_salary / (working_days * 8)
            print("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")
            print(cost_per_hour)

            # Fetch total time spent for the category from category_time_dict
            total_time_seconds = category_time_dict.get(category_id, {}).get('total_time_seconds', 0)

            # Convert Decimal to float for total_cost calculation and round to 2 decimal places
            # total_cost = round(float((total_time_seconds / 3600) * cost_per_hour), 2)
            yoo=float(total_time_seconds / 3600)
            print(yoo)

            total_cost=round(cost_per_hour*yoo,2)

            # Store the values in the category_cost_dict
            category_cost_dict[category_id] = {
                'total_cost': total_cost,
                # 'cost_per_hour': cost_per_hour,
                # 'total_time_seconds': total_time_seconds
            }

        # Print or use the category_cost_dict as needed
        print("ppppppppppppppppppppppppppppppppppppppppppppppp")
        print(category_cost_dict)

        #employee cost in client tab   $$$$$$$$$$$$$$$$$$$$$$$$$$
        # Get unique timeSheet entries for a specific client
        timesheets = timeSheet.objects.filter(client_id=client_id,time_entries_start_date__range=(start_date, end_date))

        # Dictionary to store employee IDs and their total time worked
        employee_data = {}
        ui={}
        from decimal import Decimal
        # Calculate total time worked by each employee for the client
        for timesheet1 in timesheets:
            employee_id = timesheet1.employee_id
            time_worked_seconds = timesheet1.time_entries_seconds

            # Update total time worked for the employee
            if employee_id in employee_data:
                employee_data[employee_id]['time_worked'] += time_worked_seconds
            else:
                employee_data[employee_id] = {'time_worked': time_worked_seconds, 'salary': 0}

        if Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month]).exists():
                # Use the contracted_hours model to query the database
            all = Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month])
            print("lllllllllllllllllllllllllllllllll")
            print(all)

            # Check if any records were found
            # Iterate over each record in the queryset
            for record in all:
                # print("ppppppppppppppppppppppppppppppppppppppppppppp")
                # Access the current record in the queryset
                first_record = record
                # print(first_record)

                # Access the 'working_input' attribute
                work_json_str = first_record.working_input

                # Parse the JSON string
                work_dict = json.loads(work_json_str)
                for employee_id in work_dict.keys():
                    if int(employee_id) not in employee_data:
                        employee_data[int(employee_id)] = {'time_worked': 0, 'salary': 0}

        for employee_id in employee_data.keys():
            employee1 = employee.objects.get(id=employee_id)
            employee_salary = get_salary_for_date(employee1, start_date)
            print('Vinod Dec Eveing')
            print(employee_salary)

            if employee_salary:
                employee_data[employee_id]['salary'] = employee_salary
                adjusted_salary = float(employee_salary) / (working_days * 8)
                salary=employee_salary
            else:
                employee_data[employee_id]['salary']=0
                adjusted_salary = 0
                salary=0

            time_worked_hours = employee_data[employee_id]['time_worked'] / 3600

            if employee1.first_name and employee1.last_name:
                name=employee1.first_name + ' ' + employee1.last_name
            else:
                name=employee1.user_name


            ui[str(employee_id)] = {
                        'ui_employee_name':name,
                        'ui_employee_salary': salary,
                        'ui_working_hours': time_worked_hours
                    }
            print("new@@@@@@@@@@@")
            print(adjusted_salary)
            print(time_worked_hours)
            # Multiply adjusted salary and time worked
            total_payment = adjusted_salary * time_worked_hours
            total_payment = round(total_payment,2)
            # Update employee_data with total_payment
            employee_data[employee_id]['total_payment'] = total_payment
        print("qqqqqqqqqqqqqqqqqq")
        print(employee_data)

        print(ui)
        # end employee cost in client tab $$$$$$$$$$$$$$$$$$
        print("vedansh")
        print(category_cost_dict)


        # Initialize a variable to store the sum of rates
        sum_of_rates_employee = 0.0  # Initialize the variable to store the sum of all costs

        # Iterate over the categories in category_cost_dict
        # for category_id, category_cost_info in category_cost_dict.items():
        #     # Add the total_cost for the current category to the sum
        #     sum_of_rates_employee += category_cost_info['total_cost']

        sum_of_rates_employee = sum(employee['total_payment'] for employee in employee_data.values())
        print("Total payment sum:",  sum_of_rates_employee)

        # Format the sum_of_rates_employee as a string with two decimal places when printing
        sum_of_rates_employee= "{:.2f}".format(sum_of_rates_employee)

        # Print or use the sum_of_rates_employee_str as needed
        print("Sum of all costs:", sum_of_rates_employee)




        #client revenue
        client_detail = client.objects.get(pk=client_id)
        client_id= client_detail.id
        print(start_month)
        print(end_month)
        if Client_contract_work.objects.filter(client_id=client_id,date__month__range=[start_month, end_month],date__year=current_year).exists():
        # Filter contracted hours for the project and current month
            contracted_hours_for_month = Client_contract_work.objects.filter(client_id= client_id,date__month__range=[start_month, end_month],date__year=current_year
                )

            print("88888888888888888888888888888888888888888888888")
            print(contracted_hours_for_month)
            # first_contracted_hour = contracted_hours_for_month.first()
            one_project_rate=0
            for entry in contracted_hours_for_month:

                date1=entry
                # print(date)

                date=date1.date

                target_month=date.month
                # print(target_month)

                print(target_month)

                import calendar
                from datetime import datetime
                # Calculate the difference between end_date and start_date
                target_month_start = start_date.replace(month=target_month, day=1)

                # Ensure that the start date is within the target month
                start_date_in_target_month = max(start_date, target_month_start)
                # print(start_date_in_target_month)

                # Get the end date of the target month
                if start_date_in_target_month.month == target_month:
                    # print("if")
                    # # If the start date is in the target month, use the end of the month
                    # print("end_date")
                    # print(end_date)
                    if target_month == 12:
                        next_month_date = start_date.replace(year=start_date.year + 1, month=1, day=1)
                    else:
                        next_month_date = start_date.replace(month=target_month + 1, day=1)

                    # Calculate target month end
                    target_month_end = min(next_month_date - timedelta(days=1), end_date)
                else:
                    print("else")
                    # If the start date is not in the target month, use the end of the start month
                    target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                print(target_month_end)
                # Calculate the total days in the target month between the start and end dates
                if target_month_end.month==start_date_in_target_month.month:
                    total_days_between = (target_month_end - start_date_in_target_month).days+1
                else:
                    total_days_between = (target_month_end - start_date_in_target_month).days


                # Print the total number of days in the specified month between the start and end dates
                print(f"Total days between {start_date_str} and {end_date_str} in the target month: {total_days_between}")

                date_difference=total_days_between

                # Get the number of days in that month
                days_in_month = calendar.monthrange(date.year, date.month)[1]

                # print(days_in_month)
                if one_project_rate:
                    if date_difference==days_in_month:
                        # weeks=4.3
                        # weeks=round(weeks,2)
                        weeks = round(days_in_month / 7, 2)
                        print(entry.cost)
                        one_project_rate+=entry.cost
                        print("if")
                    else:
                        weeks = date_difference / 7
                        weeks=round(weeks,2)
                        one_project_rate +=round((entry.cost * weeks) / weeks, 2)
                        print("else")
                else:
                    if date_difference==days_in_month:
                        # weeks=4.3
                        # weeks=round(weeks,2)
                        weeks = round(days_in_month / 7, 2)
                        print(entry.cost)
                        one_project_rate=entry.cost
                        print("ifff2")
                    else:
                        weeks = date_difference / 7
                        weeks=round(weeks,2)
                        one_project_rate = round((entry.cost * weeks) / weeks, 2)
                        print("else222")


            # one_project_rate = first_contracted_hour.cost
        else:
            one_project_rate=0


        one_project_rate=round(one_project_rate,2)
        print("kajal")
        print("Sum of Rates Client revenue:", one_project_rate)

        #contracted employee cost
        employee_salary_dict = {}
        ui_data=[]

        if Client_contract_work.objects.filter(client_id=client_id,date__month__range=[start_month, end_month],date__year=current_year).exists():
            contracted_client1 = Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month])
            # contracted_client = contracted_hours.objects.get(client_id=client_id1,month=current_month)

            for contracted_client in contracted_client1:

                date1=contracted_client
                # print(date)

                date=date1.date

                target_month=date.month
                # print(target_month)

                print(target_month)
                import ast
                from decimal import Decimal
                import calendar
                from datetime import datetime
                target_month_start = start_date.replace(month=target_month, day=1)

                # Ensure that the start date is within the target month
                start_date_in_target_month = max(start_date, target_month_start)
                # print(start_date_in_target_month)

                # Get the end date of the target month
                if start_date_in_target_month.month == target_month:
                    # print("if")
                    # # If the start date is in the target month, use the end of the month
                    # print("end_date")
                    # print(end_date)
                    if target_month == 12:
                        next_month_date = start_date.replace(year=start_date.year + 1, month=1, day=1)
                    else:
                        next_month_date = start_date.replace(month=target_month + 1, day=1)

                    # Calculate target month end
                    target_month_end = min(next_month_date - timedelta(days=1), end_date)
                else:
                    print("else")
                    # If the start date is not in the target month, use the end of the start month
                    target_month_end = min(start_date.replace(month=target_month, day=1) - datetime.resolution, end_date)
                print(target_month_end)
                # Calculate the total days in the target month between the start and end dates
                if target_month_end.month==start_date_in_target_month.month:
                    total_days_between = (target_month_end - start_date_in_target_month).days+1
                else:
                    total_days_between = (target_month_end - start_date_in_target_month).days


                # Print the total number of days in the specified month between the start and end dates
                print(f"Total days between {start_date_str} and {end_date_str} in the target month: {total_days_between}")

                date_difference=total_days_between

                # Get the number of days in that month
                days_in_month = calendar.monthrange(date.year, date.month)[1]

                print(days_in_month)

                if date_difference==days_in_month:
                    # weeks=4.3
                    weeks = round(days_in_month / 7, 2)
                else:
                    weeks = date_difference / 7
                print(date_difference)
                print("###########################")
                print(weeks)

                contracted_working_hours_1_str = contracted_client.working_input
                contracted_working_hours_1 = ast.literal_eval(contracted_working_hours_1_str)
                print(contracted_working_hours_1)


                    # Assuming 'working_input' is a dictionary with employee_id as keys
                for employee_id, working_hours in contracted_working_hours_1.items():
                    # Fetch the employee from the Employee table
                    employee3 = employee.objects.get(id=employee_id)
                    # Calculate salary per hour
                    # ui_employee_salary=float(employee3.salary)
                    ui_employee_salary = get_salary_for_date(employee3, date)
                    salary_per_hour = float(ui_employee_salary) / (working_days * 8)
                    salary_per_hour=round(salary_per_hour,2)
                    # Convert working hours to float
                    working_hours = float(working_hours)
                    ui_working_hours=working_hours
                    # Calculate total salary for the given working hours



                    if employee3.first_name and employee3.last_name:
                        name=employee3.first_name + ' ' + employee3.last_name
                    else:
                        name=employee3.user_name

                    weeks=round(weeks,2)
                    ui_employee_data = {
                        'ui_employee_name': name,
                        'ui_employee_salary': ui_employee_salary,
                        'ui_working_hours': working_hours,
                        'ui_weeks': weeks
                    }

                    # Append this dictionary to the list
                    ui_data.append(ui_employee_data)

                    mul=round(working_hours *weeks,2)

                    total_salary = round(salary_per_hour * mul,2)
                    print("22222222222222222222222222222")
                    print(salary_per_hour)
                    print(working_hours)
                    print(total_salary)
                    # total_salary  = "{:.2f}".format(total_salary)

                    total_salary = round(total_salary, 2)
                    # Store the total salary in the dictionary
                    print(type(employee_id))
                    employee_id=int(employee_id)
                    print(type(employee_id))
                    if int(employee_id) in employee_salary_dict:
                        print("ifff")
                        # If it exists, add the new salary to the existing one
                        employee_salary_dict[int(employee_id)] += total_salary
                        employee_salary_dict[int(employee_id)] = round(employee_salary_dict[int(employee_id)], 2)

                    else:
                        print("else")
                        # If it doesn't exist, create a new entry
                        employee_salary_dict[int(employee_id)] = total_salary
                        employee_salary_dict[int(employee_id)] = round(employee_salary_dict[int(employee_id)], 2)


                    print(employee_salary_dict)


            print("llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll")
            print(employee_salary_dict)



        contracted_sum_of_rates_employee=0.0
        # Convert all values in employee_salary_dict to float
        employee_salary_dict = {k: float(v) for k, v in employee_salary_dict.items()}

        # Sum the values in employee_salary_dict
        contracted_sum_of_rates_employee = sum(employee_salary_dict.values())
        contracted_sum_of_rates_employee = "{:.2f}".format(contracted_sum_of_rates_employee)
        print("Total contracted sum of rates for employees:", contracted_sum_of_rates_employee)



        total_time_spent_formatted={}
        project_names={}
        project_user_dict={}
        employee_rate_per_hour={}



    print("finallllll")

    print(ui_data)
    # print(ui)
    # print(weeks)
    print(ui_client_data)


    context = {
        # 'employee_list':employee_list,
        'client': client_detail,
        'projects': project_names,
        'team_member_images': project_user_dict,
        # 'project_rate':project_rate,
        'sum_of_rates':one_project_rate,
        'employee_rate_per_hour':employee_rate_per_hour,
        'sum_of_rates_employee':sum_of_rates_employee,
        'contracted_sum_of_rates_employee':contracted_sum_of_rates_employee,
        'employee_details': employee_details,
        'current_month': current_month,
        'current_year': current_year,
        'allowed_months': [9, 10, 11, 12],
        'client_category_list':client_category_list,
        'employee_info_dict':employee_info_dict,
        'category_time_dict':category_time_dict,
        'total_time_spent_formatted':total_time_spent_formatted,
        'category_cost_dict':category_cost_dict,
        "client_details":client_details,
        "category_time_dict_client":category_time_dict_client,
        "employee_data":employee_data,
        "employee_salary_dict":employee_salary_dict,
        'start_date': start_date_str,
        'end_date': end_date_str,
        'weeks': weeks,
        'total_cost_client':ui_final_cost,
        'ui_total_hours':ui_total_hours,
        'ui_formatted_time2':ui_formatted_time2,
        'ui_data':ui_data,
        'ui':ui,
        'ui_client_data':ui_client_data
    }

    print("contextttttttttttt")
    print(context)
    return context


@csrf_exempt
@login_required(login_url='/')
def export_to_excel(request, client_id):

    print("exporttttttttttttttttttttttt")
    # Fetch client data based on the client_id
    client1 = client.objects.get(id=client_id)


    context = client_profile_export(request, client_id)
    print("exportttttttttttt")
    print(context)

    # Extract the required values from the context
    sum_of_rates = context.get('sum_of_rates')
    sum_of_rates_employee = context.get('sum_of_rates_employee')
    contracted_sum_of_rates_employee = context.get('contracted_sum_of_rates_employee')
    total_working_hours = context.get('client_details', {}).get('total_working_hours')
    employee_details = context.get('employee_details', {})
    category_time_dict_client = context.get('category_time_dict_client', {})
    employee_salary_dict = context.get('employee_salary_dict', {})
    employee_data = context.get('employee_data', {})


    print(sum_of_rates)
    print(sum_of_rates_employee)

    # Create a new Excel workbook and worksheet
    workbook = openpyxl.Workbook()
    worksheet = workbook.active

    # Populate Excel worksheet with client data
    worksheet['A1'] = 'Client Name'
    worksheet['B1'] = 'Company Name'
    worksheet['A2'] = client1.client_name
    worksheet['B2'] = client1.company_name

    # Add the required data to the worksheet
    worksheet['C1'] = 'Client Revenue'
    worksheet['D1'] = 'Actual Employee Cost'
    worksheet['E1'] = 'Contracted Employee Cost'
    worksheet['F1'] = 'Total Contracted Working Time'
    worksheet['C2'] = sum_of_rates
    worksheet['D2'] = sum_of_rates_employee
    worksheet['E2'] = contracted_sum_of_rates_employee
    worksheet['F2'] = total_working_hours

    worksheet['A4'] = 'Employee Name'
    worksheet['B4'] = 'Contracted Working Time'
    worksheet['C4'] = 'Actual Working Time'
    worksheet['D4'] = 'Contracted Employee Cost'
    worksheet['E4'] = 'Actual Employee Cost'
    worksheet['F4'] = 'Role'

    # Start populating employee details from row 5
    row_num = 5


    for emp_id, details in employee_details.items():
        worksheet.cell(row=row_num, column=1, value=details.get('name'))
        worksheet.cell(row=row_num, column=2, value=details.get('hours_worked'))
        worksheet.cell(row=row_num, column=6, value=details.get('role'))

        # Add the formatted time from category_time_dict_client
        formatted_time = category_time_dict_client.get(emp_id, {}).get('formatted_time')
        if formatted_time is not None:
            worksheet.cell(row=row_num, column=3, value=formatted_time)

        # Add the employee salary from employee_salary_dict
        employee_salary = employee_salary_dict.get(emp_id)
        if employee_salary is not None:
            worksheet.cell(row=row_num, column=4, value=employee_salary)

        # Add the total payment from employee_data
        total_payment = employee_data.get(emp_id, {}).get('total_payment')
        if total_payment is not None:
            worksheet.cell(row=row_num, column=5, value=total_payment)

        row_num += 1


    # Save the Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = 'attachment; filename=client_data.xlsx'
    workbook.save(response)

    return response

@csrf_exempt
@login_required(login_url='/')
def export_all_to_excel(request):
    selected_month = request.session.get('month')
    import calendar
    from datetime import date

    if selected_month:
        current_month = int(selected_month)
    else:
        current_month = 2

    if current_month == 1:
        last_month = 12
    else:
        last_month = current_month - 1

    selected_year = request.session.get('year')
    if selected_year:
        current_year = int(selected_year)
    else:
        current_year = 2026

    if current_month == 1:
        last_year = current_year - 1
    else:
        last_year = current_year

    start_date = date(current_year, current_month, 1)
    end_date = date(current_year, current_month, calendar.monthrange(current_year, current_month)[1])

    all_clients = []

    if request.user.groups.exists():
        group = request.user.groups.all()
        print("exist group")
        print(group)

        if group[0].name == 'admin' or group[0].name == 'super_admin' or group[0].name == 'super_user':


            print("super admin")
            if current_year == 2023 and 9 <= current_month <= 12:
                client_contract_work = contracted_hours.objects.filter(month__gte=start_date, month__lte=end_date)

                # Fetch client information for each client contract work
                client_contract_work_with_client_info = []
                for work in client_contract_work:
                    client_info = client.objects.get(toggl_client_id=work.client_id)
                    client_contract_work_with_client_info.append((work, client_info))

                # Extract client objects from the list
                all_clients = [client_info for _, client_info in client_contract_work_with_client_info]

            else:
                client_contract_work = Client_contract_work.objects.filter(date__gte=start_date, date__lte=end_date)

                # Fetch client information for each client contract work
                client_contract_work_with_client_info = []
                for work in client_contract_work:
                    client_info = client.objects.get(id=work.client_id)
                    client_contract_work_with_client_info.append((work, client_info))

                # Extract client objects from the list
                all_clients = [client_info for _, client_info in client_contract_work_with_client_info]

    # Create a new Excel workbook and worksheet
    workbook = openpyxl.Workbook()
    worksheet = workbook.active
    worksheet.title = 'All Clients Data'

    # Define the headers for the client summary
    headers = [
        'Client Name', 'Company Name', 'Client Revenue', 'Actual Employee Cost',
        'Contracted Employee Cost', 'Total Contracted Working Time'
    ]

    # Add headers to the worksheet
    for col_num, header in enumerate(headers, 1):
        worksheet.cell(row=1, column=col_num, value=header)

    # Sta/rt populating client summary from row 2
    row_num = 2
    for client1 in all_clients:
        context = client_profile_export(request, client1.id)

        sum_of_rates = context.get('sum_of_rates')
        sum_of_rates_employee = context.get('sum_of_rates_employee')
        contracted_sum_of_rates_employee = context.get('contracted_sum_of_rates_employee')
        total_working_hours = context.get('client_details', {}).get('total_working_hours')

        worksheet.cell(row=row_num, column=1, value=client1.client_name)
        worksheet.cell(row=row_num, column=2, value=client1.company_name)
        worksheet.cell(row=row_num, column=3, value=sum_of_rates)
        worksheet.cell(row=row_num, column=4, value=sum_of_rates_employee)
        worksheet.cell(row=row_num, column=5, value=contracted_sum_of_rates_employee)
        worksheet.cell(row=row_num, column=6, value=total_working_hours)

        row_num += 1

    # Save the summary worksheet
    summary_sheet = workbook.active

    # For each client, add a detailed sheet
    for client1 in all_clients:
        context = client_profile_export(request, client1.id)

        # Extract the required values from the context
        sum_of_rates = context.get('sum_of_rates')
        sum_of_rates_employee = context.get('sum_of_rates_employee')
        contracted_sum_of_rates_employee = context.get('contracted_sum_of_rates_employee')
        total_working_hours = context.get('client_details', {}).get('total_working_hours')
        employee_details = context.get('employee_details', {})
        category_time_dict_client = context.get('category_time_dict_client', {})
        employee_salary_dict = context.get('employee_salary_dict', {})
        employee_data = context.get('employee_data', {})

        # Create a new worksheet for each client
        client_sheet = workbook.create_sheet(title=client1.client_name[:31])  # Sheet title max length is 31

        # Populate the client-specific worksheet with data
        client_sheet['A1'] = 'Client Name'
        client_sheet['B1'] = 'Company Name'
        client_sheet['A2'] = client1.client_name
        client_sheet['B2'] = client1.company_name

        # Add the required data to the worksheet
        client_sheet['C1'] = 'Client Revenue'
        client_sheet['D1'] = 'Actual Employee Cost'
        client_sheet['E1'] = 'Contracted Employee Cost'
        client_sheet['F1'] = 'Total Contracted Working Time'
        client_sheet['C2'] = sum_of_rates
        client_sheet['D2'] = sum_of_rates_employee
        client_sheet['E2'] = contracted_sum_of_rates_employee
        client_sheet['F2'] = total_working_hours

        client_sheet['A4'] = 'Employee Name'
        client_sheet['B4'] = 'Contracted Working Time'
        client_sheet['C4'] = 'Actual Working Time'
        client_sheet['D4'] = 'Contracted Employee Cost'
        client_sheet['E4'] = 'Actual Employee Cost'
        client_sheet['F4'] = 'Role'

        # Start populating employee details from row 5
        row_num = 5

        for emp_id, details in employee_details.items():
            client_sheet.cell(row=row_num, column=1, value=details.get('name'))
            client_sheet.cell(row=row_num, column=2, value=details.get('hours_worked'))
            client_sheet.cell(row=row_num, column=6, value=details.get('role'))

            # Add the formatted time from category_time_dict_client
            formatted_time = category_time_dict_client.get(emp_id, {}).get('formatted_time')
            if formatted_time is not None:
                client_sheet.cell(row=row_num, column=3, value=formatted_time)

            # Add the employee salary from employee_salary_dict
            employee_salary = employee_salary_dict.get(emp_id)
            if employee_salary is not None:
                client_sheet.cell(row=row_num, column=4, value=employee_salary)

            # Add the total payment from employee_data
            total_payment = employee_data.get(emp_id, {}).get('total_payment')
            if total_payment is not None:
                client_sheet.cell(row=row_num, column=5, value=total_payment)

            row_num += 1

    # Save the Excel file
    response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    response['Content-Disposition'] = 'attachment; filename=all_clients_data.xlsx'
    workbook.save(response)

    return response


# Set up the OAuth 2.0 flow
flow = Flow.from_client_secrets_file(
    'client_secret2.json',
    scopes=['https://www.googleapis.com/auth/spreadsheets','https://www.googleapis.com/auth/userinfo.email','https://www.googleapis.com/auth/userinfo.profile','openid']
)
flow.redirect_uri = f'{LIVE_URL}oauth2callback/'

@csrf_exempt
@login_required(login_url='/')
def generate_and_open_in_sheets(request):
    if request.method == 'POST':
        employee_id = request.POST.get('employee_id', None)
        from_to_date = request.POST.get('from_to_date', None)
        submit_type = request.POST.get('submit_type', None)
        request.session['employee_id'] = employee_id
        request.session['from_to_date'] = from_to_date
        request.session['submit_type'] = submit_type

    # Check if we have valid credentials
    if 'credentials' not in request.session:
        authorization_url, _ = flow.authorization_url(prompt='consent')
        return redirect(authorization_url)

    credentials = Credentials.from_authorized_user_info(request.session['credentials'])

    service = build('oauth2', 'v2', credentials=credentials)
    userinfo = service.userinfo().get().execute()

    # Get the email of the Google authenticated user
    google_email = userinfo.get('email')
    

    submit_type = request.session.get('submit_type')
    employee_id = request.session.get('employee_id')
    from_to_date = request.session.get('from_to_date')
    from_date_str, to_date_str = from_to_date.split(" - ")

    from_date = datetime.strptime(from_date_str, "%m/%d/%Y").date()
    to_date = datetime.strptime(to_date_str, "%m/%d/%Y").date()

    from_date_str = from_date.strftime('%Y-%m-%d')
    to_date_str = to_date.strftime('%Y-%m-%d')

    start_date = datetime.strptime(from_date_str, '%Y-%m-%d')
    end_date = datetime.strptime(to_date_str, '%Y-%m-%d')

    current_month = start_date.month
    current_year = start_date.year
    working_days = count_working_days_in_month(current_month, current_year)

    start_date_str = start_date.strftime('%Y-%m-%d')
    end_date_str = end_date.strftime('%Y-%m-%d')

    start_month = start_date.month
    end_month = end_date.month

    from datetime import datetime
    import calendar
    import json

    merged_ui_employee = {}
    merged_ui_employee_list = []
    merged_ui_employee3 = {}
    merged_ui_employee4 = []

    # Extract start and end year and month
    start_year, start_month = from_date.year, from_date.month
    end_year, end_month = to_date.year, to_date.month

    if start_year == end_year:
        all_hours = Client_contract_work.objects.filter(
            date__year=start_year,
            date__month__range=[start_month, end_month],
        )
    else:
        all_hours = Client_contract_work.objects.filter(
            date__year=start_year,
            date__month__gte=start_month,
        ) | Client_contract_work.objects.filter(
            date__year=end_year,
            date__month__lte=end_month,
        )

    for hours in all_hours:
        try:
            working_input_dict = json.loads(hours.working_input)
            role_dict = json.loads(hours.working_role)
            total_contracted_hours = hours.total_working_hours
            cost = hours.cost
            date = hours.date
            target_month = date.month

            employee1 = employee.objects.get(id=employee_id)
            employee_salary = get_salary_for_date(employee1, date)
            employee_name = employee1.first_name + " " + employee1.last_name

            employee_id1 = employee_id


            working_input_dict = {key.strip(): value for key, value in working_input_dict.items()}
            role_dict = {key.strip(): value for key, value in role_dict.items()}

            if str(employee_id1) in working_input_dict:
                # target_month_start = start_date.replace(month=target_month, day=1)
                # start_date_in_target_month = max(start_date, target_month_start)
                if target_month < start_date.month:  # If target_month is earlier in the year
                    target_year = start_date.year + 1  # Next year
                else:
                    target_year = start_date.year  # Same year

                # Calculate target_month_start
                target_month_start = start_date.replace(year=target_year, month=target_month, day=1)

                # Determine the start_date_in_target_month
                start_date_in_target_month = max(start_date, target_month_start)

                # Ensure target_month is in the correct year
                if start_date_in_target_month.month == target_month:
                    if target_month == 12:
                        next_month_date = start_date_in_target_month.replace(year=start_date_in_target_month.year + 1, month=1, day=1)
                    else:
                        next_month_date = start_date_in_target_month.replace(month=target_month + 1, day=1)

                    target_month_end = min(next_month_date - timedelta(days=1), end_date)
                else:
                    if target_month < start_date_in_target_month.month:
                        target_year = start_date_in_target_month.year + 1
                    else:
                        target_year = start_date_in_target_month.year

                    target_month_start = datetime(target_year, target_month, 1)
                    target_month_end = min(target_month_start - datetime.resolution, end_date)

                if target_month_end.month == start_date_in_target_month.month:
                    total_days_between = (target_month_end - start_date_in_target_month).days + 1
                else:
                    total_days_between = (target_month_end - start_date_in_target_month).days

                # return HttpResponse(total_days_between)
                date_difference = total_days_between
                days_in_month = calendar.monthrange(date.year, date.month)[1]
                ui_total_weeks = round(days_in_month / 7, 2)

                if date_difference == days_in_month:
                    # weeks = 4.3
                    weeks = round(days_in_month / 7, 2)
                else:
                    weeks = round(date_difference / 7, 2)
                hours_for_employee = float(working_input_dict[str(employee_id1)])
                role_of_employee = role_dict[str(employee_id1)]

                client1 = client.objects.get(id=hours.client_id)

                # formatted_date = date.strftime('%m-%Y')
                formatted_date = date.strftime("%B, %Y")
                selected_month = date.month
                selected_year = date.year

                working_day = count_working_days_in_month(selected_month, selected_year)
                new_entry1 = {
                    'ui_employee_name': employee_name,
                    'ui_client_name': client1.toggl_client_name,
                    'ui_total_contracted_hours': total_contracted_hours,
                    'ui_contracted_hours': hours_for_employee,
                    'ui_cost': cost,
                    'ui_weeks': weeks,
                    'ui_total_weeks': ui_total_weeks,
                    'date': formatted_date,
                    'working_day': working_day,
                    'role_of_employee': role_of_employee
                }

                if str(hours.client_id) in merged_ui_employee:
                    if 'entries' in merged_ui_employee[str(hours.client_id)]:
                        merged_ui_employee[str(hours.client_id)]['entries'].append(new_entry1)
                    else:
                        merged_ui_employee[str(hours.client_id)]['entries'] = [new_entry1]
                else:
                    merged_ui_employee[str(hours.client_id)] = {'entries': [new_entry1]}
                merged_ui_employee_list.append(new_entry1)
                new_entry = {
                    'ui_employee_name': employee_name,
                    'ui_client_name': client1.toggl_client_name,
                    'ui_employee_salary': employee_salary,
                    'ui_contracted_hours': hours_for_employee,
                    'ui_weeks': weeks,
                    'date': formatted_date,
                    'working_day': working_day,
                    'role_of_employee': role_of_employee
                }

                if str(hours.client_id) in merged_ui_employee3:
                    if 'entries' in merged_ui_employee3[str(hours.client_id)]:
                        merged_ui_employee3[str(hours.client_id)]['entries'].append(new_entry)
                    else:
                        merged_ui_employee3[str(hours.client_id)]['entries'] = [new_entry]
                else:
                    merged_ui_employee3[str(hours.client_id)] = {'entries': [new_entry]}
                merged_ui_employee4.append(new_entry)
                # print('merged_ui_employee3')
                # print(merged_ui_employee3)
        except (json.JSONDecodeError, ValueError):
            pass

    from decimal import Decimal
    count_days = count_working_days(start_date_str, end_date_str)
    if submit_type == 'client revenue':
        sumof_total_working_hours =0
        data = []
        data.append([''] * 13)
        for  entry in merged_ui_employee_list:
            ui_total_contracted_hours = float(entry['ui_total_contracted_hours'])
            ui_contracted_hours = float(entry['ui_contracted_hours'])
            ui_total_weeks = float(entry['ui_total_weeks'])
            weeks = float(entry['ui_weeks'])
            ui_cost = float(entry['ui_cost'])
            # working_time = round((ui_contracted_hours / ui_total_contracted_hours) * ui_cost, 2)
            if ui_total_contracted_hours != 0:
                working_time = round((ui_contracted_hours / ui_total_contracted_hours) * ui_cost, 2)
            else:
                working_time = 0
            
            total_working_hours = (working_time / ui_total_weeks) * weeks
            total_working_hours1 = round(total_working_hours, 2)
            sumof_total_working_hours +=total_working_hours1

            data.append([
                entry['ui_client_name'],
                entry['ui_employee_name'],
                str(entry['date']),
                entry['role_of_employee'],
                entry['working_day'],
                ui_contracted_hours,
                weeks,
                '',
                ui_total_contracted_hours,
                ui_total_weeks,
                '',
                ui_cost,
                total_working_hours1
            ])   

        data.append([''] * 13)

        # headers = [
        #     ['Client Name','Employee Name','Month','Weekly Hours Contracted', 'Total weekly hours contracted', 'Monthly working days','Monthly client revenue','Client Revenue in one month','Role','Total no of weeks from Start date and end dat','Total no of weeks in selected month','Client Cost']
        # ]
        headers = [
            ['Client Name','Employee Name','Month','Role','Monthly working days','Weekly Hours Contracted','Total no of weeks from Start date and end date','Monthly Hours Contracted', 'Total weekly hours contracted','Total no of weeks in selected month','Total Monthly Working Hours Contracted','Monthly client revenue','Client Revenue']
        ]
        data_with_headers = headers + data
        sheet_name = {'client revenue': 'Client Revenue', 'employee cost': 'Actual Employee Cost'}.get(submit_type, 'Contracted Employee Cost')

        # Check if a record exists for this user and sheet name
        spreadsheet_record = SheetRecord.objects.filter(employee_id=employee_id, sheet_name=sheet_name,record_type = 'employee',google_email=google_email).first()
        if not spreadsheet_record:
            # Create a new spreadsheet if not found
            today_date = timezone.now().strftime('%Y-%m-%d')
            service = build('sheets', 'v4', credentials=credentials)
            spreadsheet = service.spreadsheets().create(body={
                'properties': {'title': sheet_name},
                'sheets': [
                    {
                        'properties': {
                            'title': today_date  # Create the first sheet with today's date
                        }
                    }
                ]}).execute()
            spreadsheet_id = spreadsheet['spreadsheetId']
            
            if spreadsheet_id:
                spreadsheet_url = f"https://docs.google.com/spreadsheets/d/{spreadsheet_id}"
                spreadsheet_record = SheetRecord.objects.create(
                    employee_id=employee_id,
                    google_email=google_email,
                    spreadsheet_id=spreadsheet_id,
                    sheet_name=sheet_name,
                    record_type = 'employee'
                )
            else:
                return HttpResponse("Failed to create a new spreadsheet.", status=500)

        spreadsheet_id = spreadsheet_record.spreadsheet_id
        today_date = timezone.now().strftime('%Y-%m-%d')
        service = build('sheets', 'v4', credentials=credentials)

        existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
        # Find the sheet with the title matching today's date (tab name)
        sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

        # # If the sheet does not exist, create it
        if not sheet:
            add_sheet_request = {
                "requests": [{
                    "addSheet": {
                        "properties": {
                            "title": today_date
                        }
                    }
                }]
            }
            service.spreadsheets().batchUpdate(spreadsheetId=spreadsheet_id, body=add_sheet_request).execute()

            existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
            sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

        sheet_id = sheet['properties']['sheetId']
        # Clear the existing data in the sheet (from A1 onwards)
        clear_range = f'{today_date}!A1:Z1000'  # Adjust the range as needed
        service.spreadsheets().values().clear(spreadsheetId=spreadsheet_record.spreadsheet_id, range=clear_range).execute()

        range_name = f'{today_date}!A1'
        body = {'values': data_with_headers}

        # Write the data to the newly created sheet
        service.spreadsheets().values().update(
            spreadsheetId=spreadsheet_id,
            range=range_name,
            valueInputOption='RAW',
            body=body
        ).execute()

        # Prepare formulas for batch update
        last_row = len(data) + 1
        batch_update_body = {
            'requests': [
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 1,
                            'endRowIndex': last_row - 1,  # Exclude the last row
                            'startColumnIndex': 7,
                            'endColumnIndex': 8
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND(((F{i})*G{i}), 2)'}}]} for i in range(2, last_row)],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 1,
                            'endRowIndex': last_row - 1,  # Exclude the last row
                            'startColumnIndex': 10,
                            'endColumnIndex': 11
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND(((I{i})*J{i}), 2)'}}]} for i in range(2, last_row)],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 1,
                            'endRowIndex': last_row - 1,  # Exclude the last row
                            'startColumnIndex': 12,
                            'endColumnIndex': 13
                        },
                        'rows': [{
                            'values': [{
                                'userEnteredValue': {
                                    'formulaValue': f'=IF(K{i}=0, 0, ROUND((L{i}*H{i})/K{i}, 2))'
                                }
                            }]
                        } for i in range(2, last_row)],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': last_row - 1,
                            'endRowIndex': last_row,
                            'startColumnIndex': 12,
                            'endColumnIndex': 13
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=SUM(M2:M{last_row - 1})'}}]}],
                        'fields': 'userEnteredValue'
                    }
                }
            ]
        }

        # Execute batch update
        service.spreadsheets().batchUpdate(spreadsheetId=spreadsheet_id, body=batch_update_body).execute()

        # Merge cells and set titles for row 1
        merge_cells_request = {
            "requests": [
                # Merge columns E1 to H1 for "Monthly Hours Contracted"
                {
                    "mergeCells": {
                        "range": {
                            "sheetId": sheet_id,
                            "startRowIndex": 0,
                            "endRowIndex": 1,  # Row 1
                            "startColumnIndex": 5,  # Column F
                            "endColumnIndex": 8  # Column H (Exclusive)
                        },
                        "mergeType": "MERGE_ALL"
                    }
                },
                # Merge columns I1 to L1 for "Total Monthly Hours To be Contracted"
                {
                    "mergeCells": {
                        "range": {
                            "sheetId": sheet_id,
                            "startRowIndex": 0,
                            "endRowIndex": 1,  # Row 1
                            "startColumnIndex": 8,  # Column I
                            "endColumnIndex": 11  # Column L (Exclusive)
                        },
                        "mergeType": "MERGE_ALL"
                    }
                },
                {
                    "updateCells": {
                        "range": {
                            "sheetId": sheet_id,
                            "startRowIndex": 0,
                            "endRowIndex": 1,  # Row 1
                            "startColumnIndex": 0,  # Start clearing at Column A
                            "endColumnIndex": 5  # Clear up to Column E
                        },
                        # "rows": [{"values": [{"userEnteredValue": None}]} for _ in range(5)],
                        "rows": [{
                            "values": [{
                                "userEnteredValue": {"stringValue": None},
                            }]
                        }],
                        "fields": "userEnteredValue"
                    }
                },
                {
                    "updateCells": {
                        "range": {
                            "sheetId": sheet_id,
                            "startRowIndex": 0,
                            "endRowIndex": 1,  # Row 1
                            "startColumnIndex": 11,  # Start clearing at Column A
                            "endColumnIndex": 15  # Clear up to Column E
                        },
                        # "rows": [{"values": [{"userEnteredValue": None}]} for _ in range(5)],
                        "rows": [{
                            "values": [{
                                "userEnteredValue": {"stringValue": None},
                            }]
                        }],
                        "fields": "userEnteredValue"
                    }
                },
                # Set text alignment and bold formatting for merged cells in row 1
                {
                    "updateCells": {
                        "range": {
                            "sheetId": sheet_id,
                            "startRowIndex": 0,
                            "endRowIndex": 1,
                            "startColumnIndex": 5,
                            "endColumnIndex": 8
                        },
                        "rows": [{
                            "values": [{
                                "userEnteredValue": {"stringValue": "Monthly Hours Contracted"},
                                "userEnteredFormat": {
                                    "horizontalAlignment": "CENTER",
                                    "textFormat": {"bold": True}
                                }
                            }]
                        }],
                        "fields": "userEnteredValue,userEnteredFormat"
                    }
                },
                {
                    "updateCells": {
                        "range": {
                            "sheetId": sheet_id,
                            "startRowIndex": 0,
                            "endRowIndex": 1,
                            "startColumnIndex": 8,
                            "endColumnIndex": 11
                        },
                        "rows": [{
                            "values": [{
                                "userEnteredValue": {"stringValue": "Total Monthly Hours To Be Contracted"},
                                "userEnteredFormat": {
                                    "textFormat": {"bold": True}
                                }
                            }]
                        }],
                        "fields": "userEnteredValue,userEnteredFormat"
                    }
                }
            ]
        }

        # Add headers in row 2
        # Define the columns to make bold (indices start at 0)
        bold_columns = [7, 10, 11, 12]  # Example: Columns A, B, E, H, and K

        headers_request = {
            "requests": [
                {
                    "updateCells": {
                        "range": {
                            "sheetId": sheet_id,
                            "startRowIndex": 1,  # Row 2
                            "endRowIndex": 2,
                            "startColumnIndex": 0,
                            "endColumnIndex": len(headers[0])  # Total number of columns
                        },
                        "rows": [{
                            "values": [
                                {
                                    "userEnteredValue": {"stringValue": header},
                                    "userEnteredFormat": {
                                        "textFormat": {"bold": True}  # Apply bold only for specific columns
                                    } if col_idx in bold_columns else {
                                        "textFormat": {"bold": False}  # Non-bold formatting
                                    }
                                }
                                for col_idx, header in enumerate(headers[0])
                            ]
                        }],
                        "fields": "userEnteredValue,userEnteredFormat.textFormat.bold"
                    }
                }
            ]
        }


        # Execute the merge cells and headers requests
        service.spreadsheets().batchUpdate(
            spreadsheetId=spreadsheet_id,
            body={"requests": merge_cells_request["requests"] + headers_request["requests"]}
        ).execute()


    elif submit_type == 'employee cost':
        from collections import defaultdict
        from datetime import datetime

        # Assuming necessary imports and initializations are already done

        # Fetching the timesheets for the given employee and date range
        timesheets = timeSheet.objects.filter(employee_id=employee_id, time_entries_start_date__range=(start_date, end_date))

        # Initializing a defaultdict to store time spent month-wise
        monthly_time_spent = defaultdict(lambda: defaultdict(int))

        for data in timesheets:
            client_id = data.client_id
            time_spent = data.time_entries_seconds
            entry_date = data.time_entries_start_date
            
            # Extracting year and month from the entry date
            year_month = (entry_date.year, entry_date.month)
            
            # Storing time spent for each client, grouped by year and month
            monthly_time_spent[year_month][client_id] += time_spent

        # Initialize dictionaries to store formatted time and employee costs
        monthly_client_total_time_spent_formatted = defaultdict(lambda: defaultdict(str))
        monthly_client_tab_employee_cost = defaultdict(lambda: defaultdict(str))

        for year_month, client_times in monthly_time_spent.items():
            year, month = year_month
            # Calculate employee salary for each month
            employee1 = employee.objects.get(id=employee_id)
            employee_salary = get_salary_for_date(employee1, datetime(year, month, 1))
            working_days = count_working_days_in_month(month, year)
            
            for client_id, seconds1 in client_times.items():
                hours, remainder = divmod(seconds1, 3600)
                minutes, seconds2 = divmod(remainder, 60)
                monthly_client_total_time_spent_formatted[year_month][client_id] = f"{hours:02d}:{minutes:02d}:{seconds2:02d}"                
                
                hourly_working = employee_salary / (working_days * 8)
                employee_cost = (seconds1 / 3600) * float(hourly_working)
                monthly_client_tab_employee_cost[year_month][client_id] = "{:.2f}".format(employee_cost)


        # Continue with the rest of your existing code, grouping by month and processing accordingly
        result = (
            timeSheet.objects
            .filter(employee_id=employee_id, time_entries_start_date__range=(start_date, end_date))
            .values('time_entries_start_date', 'client_id', 'category_id', 'description')
            .annotate(total_time=Sum('time_entries_seconds'))
        )

        # Create a dictionary to store the results grouped by client ID and category ID month-wise
        monthly_client_category_info = defaultdict(lambda: defaultdict(lambda: {'client_name': '', 'category_name': '', 'dates': [], 'total_time': 0}))
        variable_counter = 1

        for entry in result:
            entry_date = entry['time_entries_start_date']
            year_month = (entry_date.year, entry_date.month)
            date_str = entry_date.strftime("%A %d %b")
            client_id = entry['client_id']
            category_id = entry['category_id']
            client_name = client.objects.get(id=client_id).toggl_client_name
            
            if category_id == 23:
                category_name = entry['description']  # Using description as category name if available
                key = (client_id, variable_counter)
                variable_counter += 1  # Increment variable counter
            else:
                category_name = Work_Category.objects.get(id=category_id).category
                key = (client_id, category_id)

            monthly_client_category_info[year_month][key]['client_id'] = client_id
            monthly_client_category_info[year_month][key]['client_name'] = client_name
            monthly_client_category_info[year_month][key]['category_name'] = category_name
            monthly_client_category_info[year_month][key]['dates'].append(date_str)
            monthly_client_category_info[year_month][key]['total_time'] += entry['total_time']

        # Process dates to be joined as strings
        for month_info in monthly_client_category_info.values():
            for info in month_info.values():
                info['dates'] = ", ".join(info['dates'])

        # Print the results month-wise
        client_category_dict = defaultdict(dict)
        ui_employee1 = defaultdict(dict)

        for year_month, client_category_info in monthly_client_category_info.items():
            year, month = year_month
            employee1 = employee.objects.get(id=employee_id)
            employee_salary = get_salary_for_date(employee1, datetime(year, month, 1))
            employee_name = employee1.first_name + " " + employee1.last_name
            working_days = count_working_days_in_month(month, year)
            for key, info in client_category_info.items():
                client_id, category_id = key
                client_name = info['client_name']
                client_id = info['client_id']
                category_name = info['category_name']
                dates = info['dates']
                total_time = info['total_time']

                # Fetch contract work entries
                contract_work_entries = Client_contract_work.objects.filter(
                    date__year=year,
                    date__month__range=[month, month],
                    client_id=client_id
                ).order_by('date')

                # Extract and print the employee role
                for work in contract_work_entries:
                    role_dict = json.loads(work.working_role)  # Deserialize the JSON string to a dictionary
                    role_of_employee = role_dict.get(employee_id)
                
                # Convert total_time to hours, minutes, and seconds
                hours, remainder = divmod(total_time, 3600)
                minutes, seconds = divmod(remainder, 60)
                formatted_time = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
                
                hourly_working = round(employee_salary / (working_days * 8), 2)
                employee_cost = round((total_time / 3600) * float(hourly_working), 2)
                
                client_category_dict[year_month][(client_id, category_id)] = {
                    'client_name': client_name,
                    'category_name': category_name,
                    'dates': dates,
                    'total_time': formatted_time,
                    'employee_cost': employee_cost,
                    'working_days': working_days,
                    'role_of_employee': role_of_employee
                }

                ui_employee1[year_month][str(client_id)] = {
                    'ui_employee_name': employee_name,
                    'ui_client_name': client_name,
                    'ui_employee_salary': employee_salary,
                    'ui_total_time': total_time,
                    'dates': dates,
                    'working_days': working_days,
                    'role_of_employee': role_of_employee
                }

        total_cost = 0
        data =[]
        for year_month, employee_data in ui_employee1.items():
            year, month = year_month
            month_str = datetime(year, month, 1).strftime("%B, %Y")
            
            for entry_id, entry_data in employee_data.items():
                client_name = entry_data['ui_client_name']
                employee_name = entry_data['ui_employee_name']
                monthly_salary = float(entry_data['ui_employee_salary'])
                ui_total_time = float(entry_data['ui_total_time'])
                ui_total_time_hours = round(ui_total_time / 3600, 2)
                working_time = round(monthly_salary / (working_days * 8), 2)
                total = round((working_time * ui_total_time_hours), 2)
                total_cost += total

                data.append([
                    employee_name,
                    client_name,
                    month_str,
                    entry_data['role_of_employee'],
                    monthly_salary,
                    entry_data['working_days'],
                    working_time,
                    ui_total_time_hours,
                    total
                ])

        data.append([''] * 9)

        headers = [
            ['Employee Name', 'Client Name', 'Month', 'Role', 'Monthly Salary', 'Monthly working days', 'Hourly Employee cost', 'Time spent from Start date and end date(in hours from timer)', 'Actual Employee Cost']
        ]
        data_with_headers = headers + data
        sheet_name = {'client revenue': 'Client Revenue', 'employee cost': 'Actual Employee Cost'}.get(submit_type, 'Contracted Employee Cost')

        # # Create a new Google Sheet
        # service = build('sheets', 'v4', credentials=credentials)
        # spreadsheet = service.spreadsheets().create(body={'properties': {'title': sheet_name}}).execute()
        # sheet_id = spreadsheet['spreadsheetId']

        # # Write data to the sheet
        # range_name = 'Sheet1!A1'
        # body = {'values': data_with_headers}
        # service.spreadsheets().values().update(
        #     spreadsheetId=sheet_id, range=range_name,
        #     valueInputOption='RAW', body=body).execute()
        # Check if a record exists for this user and sheet name
        spreadsheet_record = SheetRecord.objects.filter(employee_id=employee_id, sheet_name=sheet_name,record_type = 'employee',google_email=google_email).first()
        if not spreadsheet_record:
            # Create a new spreadsheet if not found
            today_date = timezone.now().strftime('%Y-%m-%d')
            service = build('sheets', 'v4', credentials=credentials)
            spreadsheet = service.spreadsheets().create(body={
                'properties': {'title': sheet_name},
                'sheets': [
                    {
                        'properties': {
                            'title': today_date  # Create the first sheet with today's date
                        }
                    }
                ]}).execute()
            spreadsheet_id = spreadsheet['spreadsheetId']
            
            if spreadsheet_id:
                spreadsheet_url = f"https://docs.google.com/spreadsheets/d/{spreadsheet_id}"
                spreadsheet_record = SheetRecord.objects.create(
                    employee_id=employee_id,
                    google_email=google_email,
                    spreadsheet_id=spreadsheet_id,
                    sheet_name=sheet_name,
                    record_type = 'employee'
                )
            else:
                return HttpResponse("Failed to create a new spreadsheet.", status=500)

        spreadsheet_id = spreadsheet_record.spreadsheet_id
        today_date = timezone.now().strftime('%Y-%m-%d')
        service = build('sheets', 'v4', credentials=credentials)

        existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
        # Find the sheet with the title matching today's date (tab name)
        sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

        # # If the sheet does not exist, create it
        if not sheet:
            add_sheet_request = {
                "requests": [{
                    "addSheet": {
                        "properties": {
                            "title": today_date
                        }
                    }
                }]
            }
            service.spreadsheets().batchUpdate(spreadsheetId=spreadsheet_id, body=add_sheet_request).execute()

            existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
            sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

        sheet_id = sheet['properties']['sheetId']
        # Clear the existing data in the sheet (from A1 onwards)
        clear_range = f'{today_date}!A1:Z1000'  # Adjust the range as needed
        service.spreadsheets().values().clear(spreadsheetId=spreadsheet_record.spreadsheet_id, range=clear_range).execute()

        range_name = f'{today_date}!A1'
        body = {'values': data_with_headers}

        # Write the data to the newly created sheet
        service.spreadsheets().values().update(
            spreadsheetId=spreadsheet_id,
            range=range_name,
            valueInputOption='RAW',
            body=body
        ).execute()

        # Prepare formulas for batch update
        last_row = len(data) + 1
        batch_update_body = {
            'requests': [
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 1,
                            'endRowIndex': last_row - 1,  # Exclude the last row
                            'startColumnIndex': 6,
                            'endColumnIndex': 7
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND(E{i}/(F{i}*8), 2)'}}]} for i in range(2, last_row)],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 1,
                            'endRowIndex': last_row - 1,  # Exclude the last row
                            'startColumnIndex': 8,
                            'endColumnIndex': 9
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND(G{i}*H{i}, 2)'}}]} for i in range(2, last_row)],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': last_row - 1,
                            'endRowIndex': last_row,
                            'startColumnIndex': 8,
                            'endColumnIndex': 9
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=SUM(I2:I{last_row - 1})'}}]}],
                        'fields': 'userEnteredValue'
                    }
                }
            ]
        }

        # Execute batch update
        service.spreadsheets().batchUpdate(spreadsheetId=spreadsheet_id, body=batch_update_body).execute()

        bold_request_body = {
            'requests': [
                {
                    'repeatCell': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 0,  # Header row
                            'endRowIndex': 1,
                            'startColumnIndex': 6,  # Column F: "Hourly Employee cost"
                            'endColumnIndex': 9
                        },
                        'cell': {
                            'userEnteredFormat': {
                                'textFormat': {'bold': True}
                            }
                        },
                        'fields': 'userEnteredFormat.textFormat.bold'
                    }
                }
            ]
        }

        # Execute the batch update for bold formatting
        service.spreadsheets().batchUpdate(
            spreadsheetId=spreadsheet_id,
            body=bold_request_body
        ).execute()
    else:
        total_contracted_cost = 0
        data = []
        for entry in merged_ui_employee4:
            monthly_salary = float(entry['ui_employee_salary'])
            weekly_hours = float(entry['ui_contracted_hours'])
            weeks = float(entry['ui_weeks'])
            working_days = float(entry['working_day'])
            
            data.append([
                entry['ui_employee_name'],
                entry['ui_client_name'],
                str(entry['date']),
                entry['role_of_employee'],
                monthly_salary,
                entry['working_day'],
                '',  # Placeholder for Hourly Employee cost
                weekly_hours,
                weeks,
                ''  # Placeholder for Contracted Employee Cost
            ])

        data.append([''] * 10)

        headers = [['Employee Name', 'Client Name', 'Month', 'Role', 'Monthly Salary', 'Monthly working days', 'Hourly Employee cost', 'Weekly hourly contracted', 'Total no of weeks from Start date and end date', 'Contracted Employee Cost']]
        data_with_headers = headers + data

        sheet_name = {'client revenue': 'Client Revenue', 'employee cost': 'Actual Employee Cost'}.get(submit_type, 'Contracted Employee Cost')

        spreadsheet_record = SheetRecord.objects.filter(employee_id=employee_id, sheet_name=sheet_name,record_type = 'employee',google_email=google_email).first()
        if not spreadsheet_record:
            # Create a new spreadsheet if not found
            today_date = timezone.now().strftime('%Y-%m-%d')
            service = build('sheets', 'v4', credentials=credentials)
            spreadsheet = service.spreadsheets().create(body={
                'properties': {'title': sheet_name},
                'sheets': [
                    {
                        'properties': {
                            'title': today_date  # Create the first sheet with today's date
                        }
                    }
                ]}).execute()
            spreadsheet_id = spreadsheet['spreadsheetId']
            
            if spreadsheet_id:
                spreadsheet_url = f"https://docs.google.com/spreadsheets/d/{spreadsheet_id}"
                spreadsheet_record = SheetRecord.objects.create(
                    employee_id=employee_id,
                    google_email=google_email,
                    spreadsheet_id=spreadsheet_id,
                    sheet_name=sheet_name,
                    record_type = 'employee'
                )
            else:
                return HttpResponse("Failed to create a new spreadsheet.", status=500)

        spreadsheet_id = spreadsheet_record.spreadsheet_id
        today_date = timezone.now().strftime('%Y-%m-%d')
        service = build('sheets', 'v4', credentials=credentials)

        existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
        # Find the sheet with the title matching today's date (tab name)
        sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

        # # If the sheet does not exist, create it
        if not sheet:
            add_sheet_request = {
                "requests": [{
                    "addSheet": {
                        "properties": {
                            "title": today_date
                        }
                    }
                }]
            }
            service.spreadsheets().batchUpdate(spreadsheetId=spreadsheet_id, body=add_sheet_request).execute()

            existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
            sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

        sheet_id = sheet['properties']['sheetId']
        # Clear the existing data in the sheet (from A1 onwards)
        clear_range = f'{today_date}!A1:Z1000'  # Adjust the range as needed
        service.spreadsheets().values().clear(spreadsheetId=spreadsheet_record.spreadsheet_id, range=clear_range).execute()

        range_name = f'{today_date}!A1'
        body = {'values': data_with_headers}

        # Write the data to the newly created sheet
        service.spreadsheets().values().update(
            spreadsheetId=spreadsheet_id,
            range=range_name,
            valueInputOption='RAW',
            body=body
        ).execute()

        # Prepare formulas for batch update
        last_row = len(data) + 1
        batch_update_body = {
            'requests': [
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 1,
                            'endRowIndex': last_row - 1,  # Exclude the last row
                            'startColumnIndex': 6,
                            'endColumnIndex': 7
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND(E{i}/(F{i}*8), 2)'}}]} for i in range(2, last_row)],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 1,
                            'endRowIndex': last_row - 1,  # Exclude the last row
                            'startColumnIndex': 9,
                            'endColumnIndex': 10
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND(G{i}*H{i}*I{i}, 2)'}}]} for i in range(2, last_row)],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': last_row - 1,
                            'endRowIndex': last_row,
                            'startColumnIndex': 9,
                            'endColumnIndex': 10
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=SUM(J2:J{last_row - 1})'}}]}],
                        'fields': 'userEnteredValue'
                    }
                }
            ]
        }

        # Execute batch update
        service.spreadsheets().batchUpdate(spreadsheetId=spreadsheet_id, body=batch_update_body).execute()

        bold_request_body = {
            'requests': [
                {
                    'repeatCell': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 0,  # Header row
                            'endRowIndex': 1,
                            'startColumnIndex': 6,  # Column F: "Hourly Employee cost"
                            'endColumnIndex': 10
                        },
                        'cell': {
                            'userEnteredFormat': {
                                'textFormat': {'bold': True}
                            }
                        },
                        'fields': 'userEnteredFormat.textFormat.bold'
                    }
                }
            ]
        }

        # Execute the batch update for bold formatting
        service.spreadsheets().batchUpdate(
            spreadsheetId=spreadsheet_id,
            body=bold_request_body
        ).execute()
    # Redirect to the newly created Google Sheet
    # return redirect(f'https://docs.google.com/spreadsheets/d/{sheet_id}')
    return redirect(f'https://docs.google.com/spreadsheets/d/{spreadsheet_id}/edit#gid={sheet_id}')


def oauth2callback(request):
    flow.fetch_token(code=request.GET.get('code'))
    credentials = flow.credentials
    request.session['credentials'] = credentials_to_dict(credentials)
    employee_id = request.session.get('employee_id')
    redirect_method = request.session.get('redirect_method')
    
    # Redirect back to generate_and_open_in_sheets with the employee_id
    if redirect_method == 'generate_client_sheet':
        return redirect('generate_client_sheet')
    else:
        return redirect('generate_and_open_in_sheets')
    
    

def credentials_to_dict(credentials):
    return {
        'token': credentials.token,
        'refresh_token': credentials.refresh_token,
        'token_uri': credentials.token_uri,
        'client_id': credentials.client_id,
        'client_secret': credentials.client_secret,
        'scopes': credentials.scopes
    }



def count_working_days(start_date, end_date):
    # Convert strings to datetime objects
    start_date = datetime.strptime(start_date, '%Y-%m-%d')
    end_date = datetime.strptime(end_date, '%Y-%m-%d')
    
    # Initialize the count of working days
    working_days_count = 0
    
    # Iterate over the date range
    current_date = start_date
    while current_date <= end_date:
        if current_date.weekday() in (0, 1, 2, 3):  # Monday is 0, Sunday is 6
            working_days_count += 1
        current_date += timedelta(days=1)
    
    return working_days_count


def count_working_days_in_month(month, year):
    # Calculate the first and last day of the month
    start_date = datetime(year, month, 1)
    if month == 12:
        end_date = datetime(year + 1, 1, 1) - timedelta(days=1)
    else:
        end_date = datetime(year, month + 1, 1) - timedelta(days=1)
    
    # Initialize the count of working days
    working_days_count = 0
    
    # Define the cutoff date for the change in working days
    cutoff_date = datetime(2024, 7, 1)
    
    # Iterate over the date range
    current_date = start_date
    while current_date <= end_date:
        if current_date < cutoff_date:  # Before July 2024
            if current_date.weekday() < 5:  # Monday is 0, Friday is 4
                working_days_count += 1
        else:  # July 2024 and later
            if current_date.weekday() < 4:  # Monday is 0, Thursday is 3
                working_days_count += 1
        current_date += timedelta(days=1)
    
    return working_days_count

def count_weeks_in_month(year, month):
    # Create a calendar object
    cal = calendar.Calendar()

    # Get all the days in the month
    month_days = cal.itermonthdays(year, month)

    # Count the number of distinct weeks
    weeks = set()
    for day in month_days:
        if day != 0:  # skip padding days
            weeks.add((year, month, day // 7))

    return len(weeks)

def get_salary_for_date(employee, target_date):
    salary_history = SalaryHistory.objects.filter(employee_id=employee.id, effective_date__lte=target_date).order_by('-effective_date').first()
    if salary_history:
        return salary_history.salary
    return employee.salary


@csrf_exempt
@login_required(login_url='/')
def generate_client_sheet(request):
    if request.method == 'POST':
        client_id = request.POST.get('client_id', None)
        date_range = request.POST.get('date_range', None)
        request_type = request.POST.get('request_type', None)
        request.session['client_id'] = client_id
        request.session['date_range'] = date_range
        request.session['request_type'] = request_type
        request.session['redirect_method'] = 'generate_client_sheet'

    # Check if we have valid credentials
    if 'credentials' not in request.session:
        authorization_url, _ = flow.authorization_url(prompt='consent')
        return redirect(authorization_url)

    credentials = Credentials.from_authorized_user_info(request.session['credentials'])
    service = build('oauth2', 'v2', credentials=credentials)
    userinfo = service.userinfo().get().execute()
    google_email = userinfo.get('email')

    import calendar
    from datetime import date, datetime, timedelta

    request_type = request.session.get('request_type')
    client_id = request.session.get('client_id')
    date_range = request.session.get('date_range')
    from_date_str, to_date_str = date_range.split(" - ")

    from_date = datetime.strptime(from_date_str, "%m/%d/%Y").date()
    to_date = datetime.strptime(to_date_str, "%m/%d/%Y").date()

    # Print the formatted dates
    print("From date:", from_date)
    print("To date:", to_date)


    from datetime import datetime

    # Convert from_date and to_date to strings
    from_date_str = from_date.strftime('%Y-%m-%d')
    to_date_str = to_date.strftime('%Y-%m-%d')

    # Convert start_date_str and end_date_str to datetime objects
    start_date = datetime.strptime(from_date_str, '%Y-%m-%d')
    end_date = datetime.strptime(to_date_str, '%Y-%m-%d')

    # Extract the year from the datetime objects
    current_month = start_date.month
    current_year = start_date.year
    working_days = count_working_days_in_month(current_month, current_year)

    start_date_str = start_date.strftime('%Y-%m-%d')
    end_date_str = end_date.strftime('%Y-%m-%d')
    
    if start_date and end_date:
        start_date=start_date.date()
        end_date=end_date.date()

    # Get the start and end months
    start_month = start_date.month
    end_month = end_date.month
    print(start_month)
    print(end_month)

    weeks=0
    ui_final_cost={}
    ui_total_hours={}
    ui_formatted_time2={}
    ui_data={}
    ui={}

    client_detail = client.objects.get(pk=client_id)
    toggl_client = client_detail.toggl_client_id
    
    employee_details = {}
    client_details={}
    ui_client_data=[]
    
    # Extract start and end year and month
    start_year, start_month = from_date.year, from_date.month
    end_year, end_month = to_date.year, to_date.month

    # Check if the date range spans multiple years
    if start_year == end_year:
        # Query for the same year
        query = Q(date__year=start_year, date__month__range=[start_month, end_month])
    else:
        # Query for the range spanning multiple years
        query = (
            Q(date__year=start_year, date__month__gte=start_month) |
            Q(date__year=end_year, date__month__lte=end_month)
        )

    # if Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month]).exists():
    #     # Use the contracted_hours model to query the database
    #     all = Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month])
    
    if Client_contract_work.objects.filter(client_id=client_id).filter(query).exists():
        all = Client_contract_work.objects.filter(client_id=client_id).filter(query)
        # Iterate over each record in the queryset
        for record in all:
            first_record = record
            ui_final_cost=first_record.cost
            date1=first_record
            date=date1.date
            target_month=date.month
            work_json_str = first_record.working_input

            # Parse the JSON string
            work_dict = json.loads(work_json_str)

            import calendar
            from datetime import datetime
            # Calculate the difference between end_date and start_date

            # target_month_start = start_date.replace(month=target_month, day=1)
            
            if target_month < start_date.month:  # If target_month is earlier in the year
                target_year = start_date.year + 1  # Next year
            else:
                target_year = start_date.year  # Same year

            # Calculate target_month_start
            target_month_start = start_date.replace(year=target_year, month=target_month, day=1)
            start_date_in_target_month = max(start_date, target_month_start)

            if start_date_in_target_month.month == target_month:
                if target_month == 12:
                    next_month_date = start_date_in_target_month.replace(year=start_date_in_target_month.year + 1, month=1, day=1)
                else:
                    next_month_date = start_date_in_target_month.replace(month=target_month + 1, day=1)
                target_month_end = min(next_month_date - timedelta(days=1), end_date)
            else:
                if target_month < start_date_in_target_month.month:
                    target_year = start_date_in_target_month.year + 1
                else:
                    target_year = start_date_in_target_month.year

                target_month_start = datetime(target_year, target_month, 1)
                target_month_end = min(target_month_start - datetime.resolution, end_date)


            if target_month_end.month==start_date_in_target_month.month:
                print("if")
                total_days_between = (target_month_end - start_date_in_target_month).days+1
            else:
                print("else")
                total_days_between = (target_month_end - start_date_in_target_month).days

            date_difference=total_days_between

            days_in_month = calendar.monthrange(date.year, date.month)[1]
            ui_total_weeks = round(days_in_month / 7, 2)

            if date_difference==days_in_month:
                # weeks=4.3
                weeks = round(days_in_month / 7, 2)
                weeks=round(weeks,2)
                cost_new=first_record.cost
            else:
                weeks = date_difference / 7
                weeks=round(weeks,2)
                c=round((first_record.cost * weeks) , 2)
                cost_new = round((c) / ui_total_weeks, 2)


            formatted_date = date.strftime("%B, %Y")
            working_days = count_working_days_in_month(date.month, date.year)
            # Formatting the time
            ui_client_data1 = {

                    'ui_cost': first_record.cost,
                    'ui_weeks': weeks,
                    'ui_total_weeks': ui_total_weeks,
                    'ui_date_difference':date_difference,
                    'working_days': working_days,
                    'date': formatted_date
                }

                # Append this dictionary to the list
            ui_client_data.append(ui_client_data1)
    else:
        print("No contracted hours found for the specified client.")

    # vinod test end

    # Filtering timesheets based on client_id and date range
    timesheets = timeSheet.objects.filter(client_id=client_id, time_entries_start_date__range=(start_date, end_date))

    # Dictionary to store employee IDs and their total time worked
    employee_data = {}
    ui = {}

    # Calculate total time worked by each employee for the client
    for timesheet1 in timesheets:
        employee_id = timesheet1.employee_id
        time_worked_seconds = timesheet1.time_entries_seconds
        entry_date = timesheet1.time_entries_start_date

        # Extracting year and month from the entry date
        year_month = (entry_date.year, entry_date.month)

        # Ensure year_month is in employee_data
        if year_month not in employee_data:
            employee_data[year_month] = {}

        # Ensure employee_id is in employee_data[year_month]
        if employee_id not in employee_data[year_month]:
            employee_data[year_month][employee_id] = {'time_worked': 0, 'salary': 0, 'date': entry_date}

        # Update total time worked for the employee
        employee_data[year_month][employee_id]['time_worked'] += time_worked_seconds

    # Check if there are any Client_contract_work records for the client within the given date range
    # if Client_contract_work.objects.filter(client_id=client_id, date__year=current_year, date__month__range=[start_month, end_month]).exists():
    #     all_contracts = Client_contract_work.objects.filter(client_id=client_id, date__year=current_year, date__month__range=[start_month, end_month])

    if Client_contract_work.objects.filter(client_id=client_id).filter(query).exists():
        all_contracts = Client_contract_work.objects.filter(client_id=client_id).filter(query)
        # Iterate over each record in the queryset
        for record in all_contracts:
            first_record = record

            # Access the 'working_input' attribute
            work_json_str = first_record.working_input

            # Parse the JSON string into a dictionary
            work_dict = json.loads(work_json_str)

            # Update employee_data with any missing employee IDs
            for employee_id in work_dict.keys():
                employee_id_int = int(employee_id)
                if employee_id_int not in employee_data:
                    employee_data[employee_id_int] = {'time_worked': 0, 'salary': 0, 'date': first_record.date}

    # Process employee data for UI output
    for key, value in employee_data.items():
        # Check if the key is a tuple (year, month), indicating nested employee data
        if isinstance(key, tuple):
            year_month, employees = key, value
            year, month = year_month

            for employee_id, employee_info in employees.items():
                # Generate a unique key combining year, month, and employee_id
                unique_key = f"{year}_{month}_{employee_id}"

                employee1 = employee.objects.get(id=employee_id)
                entry_date = employee_info['date']

                # Calculate salary if the employee has one
                if employee1.salary:
                    emp_salary = get_salary_for_date(employee1, entry_date)
                    employee_info['salary'] = emp_salary
                    salary = emp_salary
                else:
                    employee_info['salary'] = 0
                    salary = 0

                # Convert time worked from seconds to hours
                time_worked_hours = employee_info['time_worked'] / 3600

                # Construct employee's full name
                if employee1.first_name and employee1.last_name:
                    name = employee1.first_name + ' ' + employee1.last_name
                else:
                    name = employee1.user_name

                # Format the date for UI display
                formatted_date = entry_date.strftime("%B, %Y")
                working_days = count_working_days_in_month(month, year)

                days_in_month = calendar.monthrange(current_year, month)[1]
                ui_total_weeks = round(days_in_month / 7, 2)

                # Store the data for the UI
                ui[unique_key] = {
                    'ui_employee_name': name,
                    'ui_employee_salary': salary,
                    'ui_working_hours': time_worked_hours,
                    'working_days': working_days,
                    'ui_total_weeks': ui_total_weeks,
                    'date': formatted_date
                }

        # Handle the case where the employee ID is at the top level
        elif isinstance(key, int):
            employee_id = key
            employee_info = value
            entry_date = employee_info['date']

            # Generate a unique key combining year, month, and employee_id
            year, month = entry_date.year, entry_date.month
            unique_key = f"{year}_{month}_{employee_id}"

            employee1 = employee.objects.get(id=employee_id)

            # Calculate salary if the employee has one
            if employee1.salary:
                emp_salary = get_salary_for_date(employee1, entry_date)
                employee_info['salary'] = emp_salary
                salary = emp_salary
            else:
                employee_info['salary'] = 0
                salary = 0

            # Convert time worked from seconds to hours
            time_worked_hours = employee_info['time_worked'] / 3600

            # Construct employee's full name
            if employee1.first_name and employee1.last_name:
                name = employee1.first_name + ' ' + employee1.last_name
            else:
                name = employee1.user_name

            # Format the date for UI display
            formatted_date = entry_date.strftime("%B, %Y")
            working_days = count_working_days_in_month(month, year)
            days_in_month = calendar.monthrange(current_year, month)[1]
            ui_total_weeks = round(days_in_month / 7, 2)
            # Store the data for the UI
            ui[unique_key] = {
                'ui_employee_name': name,
                'ui_employee_salary': salary,
                'ui_working_hours': time_worked_hours,
                'working_days': working_days,
                'ui_total_weeks': ui_total_weeks,
                'date': formatted_date
            }
    
    employee_salary_dict = {}
    ui_data=[]

    # if Client_contract_work.objects.filter(client_id=client_id,date__month__range=[start_month, end_month],date__year=current_year).exists():
    #     contracted_client1 = Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month])

    if Client_contract_work.objects.filter(client_id=client_id).filter(query).exists():
        contracted_client1 = Client_contract_work.objects.filter(client_id=client_id).filter(query)
        
        for contracted_client in contracted_client1:
            date1=contracted_client
            date=date1.date
            target_month=date.month
            import ast
            from decimal import Decimal
            import calendar
            from datetime import datetime


            if target_month < start_date.month:  # If target_month is earlier in the year
                target_year = start_date.year + 1  # Next year
            else:
                target_year = start_date.year  # Same year

            # Calculate target_month_start
            target_month_start = start_date.replace(year=target_year, month=target_month, day=1)

            # Determine the start_date_in_target_month
            start_date_in_target_month = max(start_date, target_month_start)

            # Ensure target_month is in the correct year
            if start_date_in_target_month.month == target_month:
                if target_month == 12:
                    next_month_date = start_date_in_target_month.replace(year=start_date_in_target_month.year + 1, month=1, day=1)
                else:
                    next_month_date = start_date_in_target_month.replace(month=target_month + 1, day=1)

                target_month_end = min(next_month_date - timedelta(days=1), end_date)
            else:
                if target_month < start_date_in_target_month.month:
                    target_year = start_date_in_target_month.year + 1
                else:
                    target_year = start_date_in_target_month.year

                target_month_start = datetime(target_year, target_month, 1)
                target_month_end = min(target_month_start - datetime.resolution, end_date)

            if target_month_end.month == start_date_in_target_month.month:
                total_days_between = (target_month_end - start_date_in_target_month).days + 1
            else:
                total_days_between = (target_month_end - start_date_in_target_month).days

            date_difference=total_days_between

            # Get the number of days in that month
            days_in_month = calendar.monthrange(date.year, date.month)[1]

            if date_difference==days_in_month:
                weeks= round(days_in_month / 7, 2)
            else:
                weeks = date_difference / 7

            ui_total_weeks = round(days_in_month / 7, 2)

            contracted_working_hours_1_str = contracted_client.working_input
            contracted_working_hours_1 = ast.literal_eval(contracted_working_hours_1_str)

            for employee_id, working_hours in contracted_working_hours_1.items():
                # Fetch the employee from the Employee table
                employee3 = employee.objects.get(id=employee_id)
                # Calculate salary per hour
                emp3_salary = get_salary_for_date(employee3, date)
                ui_employee_salary=float(emp3_salary)
                salary_per_hour = float(emp3_salary) / (working_days * 8)
                salary_per_hour=round(salary_per_hour,2)
                # Convert working hours to float
                working_hours = float(working_hours)
                ui_working_hours=working_hours

                if employee3.first_name and employee3.last_name:
                    name=employee3.first_name + ' ' + employee3.last_name
                else:
                    name=employee3.user_name

                weeks=round(weeks,2)
                formatted_date = date.strftime("%B, %Y")
                selected_month = date.month
                selected_year = date.year
                working_days = count_working_days_in_month(selected_month, selected_year)
                ui_employee_data = {
                    'ui_employee_name': name,
                    'ui_employee_salary': emp3_salary,
                    'ui_working_hours': working_hours,
                    'ui_weeks': weeks,
                    'ui_total_weeks': ui_total_weeks,
                    'working_days': working_days,
                    'date': formatted_date
                }

                ui_data.append(ui_employee_data)

    total_time_spent_formatted={}
    project_names={}
    project_user_dict={}
    employee_rate_per_hour={}


    count_days = count_working_days(start_date_str, end_date_str)
    if request_type == 'client revenue':
        data = []
        total_revenue =0
        for entry_data in ui_client_data:
            cost = float(entry_data['ui_cost'])
            weeks = float(entry_data['ui_weeks'])
            ui_total_weeks = float(entry_data['ui_total_weeks'])
            days = float(entry_data['ui_date_difference'])            
            working_days = float(entry_data['working_days'])            
            cal = round((cost * weeks), 2)
            total = round((cal / ui_total_weeks), 2)
            total_revenue +=total

            data.append([
                client_detail.client_name,
                str(entry_data['date']),
                cost,
                days,
                weeks,
                ui_total_weeks,
                total,
            ])

        data.append([''] * 7)

        headers = [
            ['Client Name','Month','Monthly client revenue', 'No. of days from start date to end date', 'Total no of weeks from Start date and end date','Total no of week in 1 month','Contracted client revenue']
        ]
        data_with_headers = headers + data
        sheet_name = 'Client Revenue'

        # Check if a record exists for this user and sheet name
        spreadsheet_record = SheetRecord.objects.filter(client_id=client_id, sheet_name=sheet_name,record_type='client',google_email=google_email).first()
        if not spreadsheet_record:
            # Create a new spreadsheet if not found
            today_date = timezone.now().strftime('%Y-%m-%d')
            service = build('sheets', 'v4', credentials=credentials)
            spreadsheet = service.spreadsheets().create(body={
                'properties': {'title': sheet_name},
                'sheets': [
                    {
                        'properties': {
                            'title': today_date  # Create the first sheet with today's date
                        }
                    }
                ]}).execute()
            spreadsheet_id = spreadsheet['spreadsheetId']
            
            if spreadsheet_id:
                spreadsheet_url = f"https://docs.google.com/spreadsheets/d/{spreadsheet_id}"
                spreadsheet_record = SheetRecord.objects.create(
                    client_id=client_id,
                    google_email=google_email,
                    spreadsheet_id=spreadsheet_id,
                    sheet_name=sheet_name,
                    record_type = 'client'
                )
            else:
                return HttpResponse("Failed to create a new spreadsheet.", status=500)

        spreadsheet_id = spreadsheet_record.spreadsheet_id
        today_date = timezone.now().strftime('%Y-%m-%d')
        service = build('sheets', 'v4', credentials=credentials)

        existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
        # Find the sheet with the title matching today's date (tab name)
        sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

        # # If the sheet does not exist, create it
        if not sheet:
            add_sheet_request = {
                "requests": [{
                    "addSheet": {
                        "properties": {
                            "title": today_date
                        }
                    }
                }]
            }
            service.spreadsheets().batchUpdate(spreadsheetId=spreadsheet_id, body=add_sheet_request).execute()

            existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
            sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

        sheet_id = sheet['properties']['sheetId']
        # Clear the existing data in the sheet (from A1 onwards)
        clear_range = f'{today_date}!A1:Z1000'  # Adjust the range as needed
        service.spreadsheets().values().clear(spreadsheetId=spreadsheet_record.spreadsheet_id, range=clear_range).execute()

        range_name = f'{today_date}!A1'
        body = {'values': data_with_headers}

        # Write the data to the newly created sheet
        service.spreadsheets().values().update(
            spreadsheetId=spreadsheet_id,
            range=range_name,
            valueInputOption='RAW',
            body=body
        ).execute()

        # Prepare formulas for batch update
        last_row = len(data) + 1
        batch_update_body = {
            'requests': [
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 1,
                            'endRowIndex': last_row - 1,  # Exclude the last row
                            'startColumnIndex': 6,
                            'endColumnIndex': 7
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND((C{i}*(E{i})/F{i}), 2)'}}]} for i in range(2, last_row)],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': last_row - 1,
                            'endRowIndex': last_row,
                            'startColumnIndex': 6,
                            'endColumnIndex': 7
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=SUM(G2:G{last_row - 1})'}}]}],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'repeatCell': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 0,  # Header row
                            'endRowIndex': 1,
                            'startColumnIndex': 2,  # Column F: "Hourly Employee cost"
                            'endColumnIndex': 3
                        },
                        'cell': {
                            'userEnteredFormat': {
                                'textFormat': {'bold': True}
                            }
                        },
                        'fields': 'userEnteredFormat.textFormat.bold'
                    }
                },
                {
                    'repeatCell': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 0,  # Header row
                            'endRowIndex': 1,
                            'startColumnIndex': 4,  # Column F: "Hourly Employee cost"
                            'endColumnIndex': 7
                        },
                        'cell': {
                            'userEnteredFormat': {
                                'textFormat': {'bold': True}
                            }
                        },
                        'fields': 'userEnteredFormat.textFormat.bold'
                    }
                }
            ]
        }    
    elif request_type == 'employee cost':
        data = []
        total_cost = 0
        for data1 in ui.values():
            employee_name = data1['ui_employee_name']
            employee_salary = float(data1['ui_employee_salary'])
            working_hours = float(data1['ui_working_hours'])
            working_days = float(data1['working_days'])
            
            working_time = round((employee_salary / (working_days * 8)), 2)
            total = round((working_time * working_hours), 2)
            total_cost += total

            data.append([
                employee_name,
                client_detail.client_name,
                str(data1['date']),
                employee_salary,
                working_days,
                working_time,
                working_hours,
                total
            ])
        
        data.append([''] * 8)

        headers = [
            ['Employee Name','Client Name','Month','Monthly Salary', 'Total no of working days', 'Hourly Employee cost','Time spent from Start date and end date(in hours from timer)','Actual Employee Cost']    
        ]
        data_with_headers = headers + data
        sheet_name = 'Actual Employee Cost'

        # Check if a record exists for this user and sheet name
        spreadsheet_record = SheetRecord.objects.filter(client_id=client_id, sheet_name=sheet_name,record_type='client',google_email=google_email).first()
        if not spreadsheet_record:
            # Create a new spreadsheet if not found
            today_date = timezone.now().strftime('%Y-%m-%d')
            service = build('sheets', 'v4', credentials=credentials)
            spreadsheet = service.spreadsheets().create(body={
                'properties': {'title': sheet_name},
                'sheets': [
                    {
                        'properties': {
                            'title': today_date  # Create the first sheet with today's date
                        }
                    }
                ]}).execute()
            spreadsheet_id = spreadsheet['spreadsheetId']
            
            if spreadsheet_id:
                spreadsheet_url = f"https://docs.google.com/spreadsheets/d/{spreadsheet_id}"
                spreadsheet_record = SheetRecord.objects.create(
                    client_id=client_id,
                    google_email=google_email,
                    spreadsheet_id=spreadsheet_id,
                    sheet_name=sheet_name,
                    record_type = 'client'
                )
            else:
                return HttpResponse("Failed to create a new spreadsheet.", status=500)

        spreadsheet_id = spreadsheet_record.spreadsheet_id
        today_date = timezone.now().strftime('%Y-%m-%d')
        service = build('sheets', 'v4', credentials=credentials)

        existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
        # Find the sheet with the title matching today's date (tab name)
        sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

        # # If the sheet does not exist, create it
        if not sheet:
            add_sheet_request = {
                "requests": [{
                    "addSheet": {
                        "properties": {
                            "title": today_date
                        }
                    }
                }]
            }
            service.spreadsheets().batchUpdate(spreadsheetId=spreadsheet_id, body=add_sheet_request).execute()

            existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
            sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

        sheet_id = sheet['properties']['sheetId']
        # Clear the existing data in the sheet (from A1 onwards)
        clear_range = f'{today_date}!A1:Z1000'  # Adjust the range as needed
        service.spreadsheets().values().clear(spreadsheetId=spreadsheet_record.spreadsheet_id, range=clear_range).execute()

        range_name = f'{today_date}!A1'
        body = {'values': data_with_headers}

        # Write the data to the newly created sheet
        service.spreadsheets().values().update(
            spreadsheetId=spreadsheet_id,
            range=range_name,
            valueInputOption='RAW',
            body=body
        ).execute()

        # Prepare formulas for batch update
        last_row = len(data) + 1
        batch_update_body = {
            'requests': [
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 1,
                            'endRowIndex': last_row - 1,  # Exclude the last row
                            'startColumnIndex': 5,
                            'endColumnIndex': 6
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND((D{i}/((E{i})*8)), 2)'}}]} for i in range(2, last_row)],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 1,
                            'endRowIndex': last_row - 1,  # Exclude the last row
                            'startColumnIndex': 7,
                            'endColumnIndex': 8
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND((F{i}*(G{i})), 2)'}}]} for i in range(2, last_row)],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': last_row - 1,
                            'endRowIndex': last_row,
                            'startColumnIndex': 7,
                            'endColumnIndex': 8
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=SUM(H2:H{last_row - 1})'}}]}],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'repeatCell': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 0,  # Header row
                            'endRowIndex': 1,
                            'startColumnIndex': 5,  # Column F: "Hourly Employee cost"
                            'endColumnIndex': 8
                        },
                        'cell': {
                            'userEnteredFormat': {
                                'textFormat': {'bold': True}
                            }
                        },
                        'fields': 'userEnteredFormat.textFormat.bold'
                    }
                }
            ]
        }        
    else:
        data = []

        total_contracted_cost = 0
        for entry_data in ui_data:
            employee_name = entry_data['ui_employee_name']
            employee_salary = float(entry_data['ui_employee_salary'])
            working_hours = float(entry_data['ui_working_hours'])
            weeks = float(entry_data['ui_weeks'])
            working_days = float(entry_data['working_days'])
            
            totalWorkingHours = round(weeks * working_hours, 2)
            working_time = round(employee_salary / (working_days * 8), 2)
            total = round(totalWorkingHours * working_time, 2)
            total_contracted_cost +=total

            data.append([
                employee_name,
                client_detail.client_name,
                str(entry_data['date']),
                employee_salary,
                working_days,
                working_time,
                working_hours,
                weeks,
                totalWorkingHours,
                total
            ])

        data.append([''] * 10)

        headers = [
            ['Employee Name','Client Name','Month','Monthly Salary', 'Total no of working days', 'Hourly Employee cost','Contracted weekly working hours for employee','Total no of weeks from Start date and end date','Total weekly hours contracted','Contracted Employee Cost']    
        ]
        data_with_headers = headers + data
        sheet_name = 'Contracted Employee Cost'

        # Check if a record exists for this user and sheet name
        spreadsheet_record = SheetRecord.objects.filter(client_id=client_id, sheet_name=sheet_name,record_type='client',google_email=google_email).first()
        if not spreadsheet_record:
            # Create a new spreadsheet if not found
            today_date = timezone.now().strftime('%Y-%m-%d')
            service = build('sheets', 'v4', credentials=credentials)
            spreadsheet = service.spreadsheets().create(body={
                'properties': {'title': sheet_name},
                'sheets': [
                    {
                        'properties': {
                            'title': today_date  # Create the first sheet with today's date
                        }
                    }
                ]}).execute()
            spreadsheet_id = spreadsheet['spreadsheetId']
            
            if spreadsheet_id:
                spreadsheet_url = f"https://docs.google.com/spreadsheets/d/{spreadsheet_id}"
                spreadsheet_record = SheetRecord.objects.create(
                    client_id=client_id,
                    google_email=google_email,
                    spreadsheet_id=spreadsheet_id,
                    sheet_name=sheet_name,
                    record_type = 'client'
                )
            else:
                return HttpResponse("Failed to create a new spreadsheet.", status=500)

        spreadsheet_id = spreadsheet_record.spreadsheet_id
        today_date = timezone.now().strftime('%Y-%m-%d')
        service = build('sheets', 'v4', credentials=credentials)

        existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
        # Find the sheet with the title matching today's date (tab name)
        sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

        # # If the sheet does not exist, create it
        if not sheet:
            add_sheet_request = {
                "requests": [{
                    "addSheet": {
                        "properties": {
                            "title": today_date
                        }
                    }
                }]
            }
            service.spreadsheets().batchUpdate(spreadsheetId=spreadsheet_id, body=add_sheet_request).execute()

            existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
            sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

        sheet_id = sheet['properties']['sheetId']
        # Clear the existing data in the sheet (from A1 onwards)
        clear_range = f'{today_date}!A1:Z1000'  # Adjust the range as needed
        service.spreadsheets().values().clear(spreadsheetId=spreadsheet_record.spreadsheet_id, range=clear_range).execute()

        range_name = f'{today_date}!A1'
        body = {'values': data_with_headers}

        # Write the data to the newly created sheet
        service.spreadsheets().values().update(
            spreadsheetId=spreadsheet_id,
            range=range_name,
            valueInputOption='RAW',
            body=body
        ).execute()

        # Prepare formulas for batch update
        last_row = len(data) + 1
        batch_update_body = {
            'requests': [
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 1,
                            'endRowIndex': last_row - 1,  # Exclude the last row
                            'startColumnIndex': 5,
                            'endColumnIndex': 6
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND((D{i}/((E{i})*8)), 2)'}}]} for i in range(2, last_row)],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 1,
                            'endRowIndex': last_row - 1,  # Exclude the last row
                            'startColumnIndex': 9,
                            'endColumnIndex': 10
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND((F{i}*(I{i})), 2)'}}]} for i in range(2, last_row)],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 1,
                            'endRowIndex': last_row - 1,  # Exclude the last row
                            'startColumnIndex': 8,
                            'endColumnIndex': 9
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND((G{i}*(H{i})), 2)'}}]} for i in range(2, last_row)],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'updateCells': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': last_row - 1,
                            'endRowIndex': last_row,
                            'startColumnIndex': 9,
                            'endColumnIndex': 10
                        },
                        'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=SUM(J2:J{last_row - 1})'}}]}],
                        'fields': 'userEnteredValue'
                    }
                },
                {
                    'repeatCell': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 0,  # Header row
                            'endRowIndex': 1,
                            'startColumnIndex': 5,  # Column F: "Hourly Employee cost"
                            'endColumnIndex': 6
                        },
                        'cell': {
                            'userEnteredFormat': {
                                'textFormat': {'bold': True}
                            }
                        },
                        'fields': 'userEnteredFormat.textFormat.bold'
                    }
                },
                {
                    'repeatCell': {
                        'range': {
                            'sheetId': sheet_id,
                            'startRowIndex': 0,  # Header row
                            'endRowIndex': 1,
                            'startColumnIndex': 8,  # Column F: "Hourly Employee cost"
                            'endColumnIndex': 10
                        },
                        'cell': {
                            'userEnteredFormat': {
                                'textFormat': {'bold': True}
                            }
                        },
                        'fields': 'userEnteredFormat.textFormat.bold'
                    }
                }
            ]
        }

    # Execute batch update
    service.spreadsheets().batchUpdate(spreadsheetId=spreadsheet_id, body=batch_update_body).execute()
    return redirect(f'https://docs.google.com/spreadsheets/d/{spreadsheet_id}/edit#gid={sheet_id}')

@csrf_exempt
@login_required(login_url='/')
def change_password(request):
    if request.method == 'POST':
        from django.contrib.auth.hashers import check_password, make_password
        current_password = request.POST.get('current_password')
        new_password = request.POST.get('new_password')
        confirm_password = request.POST.get('confirm_password')

        # Check if the new password and confirm password match
        if new_password != confirm_password:
            return JsonResponse({'error': 1, 'msg': "Passwords do not match."})

        # Get the current logged-in user
        user = request.user

        # Check if the current password is correct
        if not check_password(current_password, user.password):
            return JsonResponse({'error': 1, 'msg': "The current password you entered is incorrect."})

        # Update the user's password
        user.password = make_password(new_password)
        user.save()
        return JsonResponse({'error': 0, 'msg': "Password changed successfully."})

@csrf_exempt
@login_required(login_url='/')
def export_employee_data(request):
    if request.method == 'POST':
        employee_id = request.POST.get('employee_id', None)
        from_to_date = request.POST.get('from_to_date', None)
        submit_type = request.POST.get('submit_type', None)
        request.session['employee_id'] = employee_id
        request.session['from_to_date'] = from_to_date
        request.session['submit_type'] = submit_type
        request.session['redirect_method'] = 'export_employee_data'

    # Check if we have valid credentials
    if 'credentials' not in request.session:
        authorization_url, _ = flow.authorization_url(prompt='consent')
        return redirect(authorization_url)

    credentials = Credentials.from_authorized_user_info(request.session['credentials'])

    service = build('oauth2', 'v2', credentials=credentials)
    userinfo = service.userinfo().get().execute()
    google_email = userinfo.get('email')

    import calendar
    from datetime import date, datetime, timedelta

    submit_type = request.session.get('submit_type')
    employee_id = request.session.get('employee_id')
    from_to_date = request.session.get('from_to_date')
    from_date_str, to_date_str = from_to_date.split(" - ")

    from_date = datetime.strptime(from_date_str, "%m/%d/%Y").date()
    to_date = datetime.strptime(to_date_str, "%m/%d/%Y").date()

    from_date_str = from_date.strftime('%Y-%m-%d')
    to_date_str = to_date.strftime('%Y-%m-%d')

    start_date = datetime.strptime(from_date_str, '%Y-%m-%d')
    end_date = datetime.strptime(to_date_str, '%Y-%m-%d')

    current_month = start_date.month
    current_year = start_date.year
    working_days = count_working_days_in_month(current_month, current_year)

    start_date_str = start_date.strftime('%Y-%m-%d')
    end_date_str = end_date.strftime('%Y-%m-%d')

    start_month = start_date.month
    end_month = end_date.month



    merged_ui_employee = {}
    merged_ui_employee_list = []
    merged_ui_employee3 = {}
    merged_ui_employee4 = []

    # data = [
    #         ['Employee Name','Client Name','Month','Monthly Salary','Monthly working days','Hourly Employee cost','Role','Weekly Hours Contracted', 'Total weekly hours contracted', 'Monthly client revenue','Client Revenue in one month','Total no of weeks from Start date and end dat','Actual Cost']
    #     ]

    data = [
            ['Employee Name','Client Name','Month','Role','Monthly Salary','Monthly working days','Hourly Employee cost','Weekly Hours Contracted', 'Total no of weeks in selected month','Monthly Hours Contracted','Total weekly hours contracted', 'Total no of weeks in selected month','Total Monthly Working Hours Contracted','Monthly client revenue','Total Working Hours','Client Revenue','Contracted Employee Cost','Actual Employee Cost']
        ]

    start_year, start_month = from_date.year, from_date.month
    end_year, end_month = to_date.year, to_date.month

    if start_year == end_year:
        all_hours = Client_contract_work.objects.filter(
            date__year=start_year,
            date__month__range=[start_month, end_month],
        )
    else:
        all_hours = Client_contract_work.objects.filter(
            date__year=start_year,
            date__month__gte=start_month,
        ) | Client_contract_work.objects.filter(
            date__year=end_year,
            date__month__lte=end_month,
        )
    for hours in all_hours:
        try:
            working_input_dict = json.loads(hours.working_input)
            role_dict = json.loads(hours.working_role)
            total_contracted_hours = hours.total_working_hours
            cost = hours.cost
            date = hours.date
            target_month = date.month

            employee1 = employee.objects.get(id=employee_id)
            employee_salary = get_salary_for_date(employee1, date)
            employee_name = employee1.first_name + " " + employee1.last_name

            employee_id1 = employee_id


            working_input_dict = {key.strip(): value for key, value in working_input_dict.items()}
            role_dict = {key.strip(): value for key, value in role_dict.items()}

            if str(employee_id1) in working_input_dict:
                if target_month < start_date.month:  # If target_month is earlier in the year
                    target_year = start_date.year + 1  # Next year
                else:
                    target_year = start_date.year  # Same year

                # Calculate target_month_start
                target_month_start = start_date.replace(year=target_year, month=target_month, day=1)

                # Determine the start_date_in_target_month
                start_date_in_target_month = max(start_date, target_month_start)

                # Ensure target_month is in the correct year
                if start_date_in_target_month.month == target_month:
                    if target_month == 12:
                        next_month_date = start_date_in_target_month.replace(year=start_date_in_target_month.year + 1, month=1, day=1)
                    else:
                        next_month_date = start_date_in_target_month.replace(month=target_month + 1, day=1)

                    target_month_end = min(next_month_date - timedelta(days=1), end_date)
                else:
                    if target_month < start_date_in_target_month.month:
                        target_year = start_date_in_target_month.year + 1
                    else:
                        target_year = start_date_in_target_month.year

                    target_month_start = datetime(target_year, target_month, 1)
                    target_month_end = min(target_month_start - datetime.resolution, end_date)

                if target_month_end.month == start_date_in_target_month.month:
                    total_days_between = (target_month_end - start_date_in_target_month).days + 1
                else:
                    total_days_between = (target_month_end - start_date_in_target_month).days

                date_difference = total_days_between
                days_in_month = calendar.monthrange(date.year, date.month)[1]
                ui_total_weeks = round(days_in_month / 7, 2)

                if date_difference == days_in_month:
                    # weeks = 4.3
                    weeks = round(days_in_month / 7, 2)
                else:
                    weeks = round(date_difference / 7, 2)
                hours_for_employee = float(working_input_dict[str(employee_id1)])
                role_of_employee = role_dict[str(employee_id1)]
                print('Test Working Hours')
                print(hours_for_employee)
                print(working_input_dict)
                print(role_of_employee)

                client1 = client.objects.get(id=hours.client_id)

                # formatted_date = date.strftime('%m-%Y')
                formatted_date = date.strftime("%B, %Y")
                selected_month = date.month
                selected_year = date.year
                working_day = count_working_days_in_month(selected_month, selected_year)
                new_entry1 = {
                    'ui_employee_name': employee_name,
                    'ui_client_name': client1.toggl_client_name,
                    'ui_employee_salary': employee_salary,
                    'ui_total_contracted_hours': total_contracted_hours,
                    'ui_contracted_hours': hours_for_employee,
                    'ui_cost': cost,
                    'ui_weeks': weeks,
                    'ui_total_weeks': ui_total_weeks,
                    'date': formatted_date,
                    'working_day': working_day,
                    'role_of_employee': role_of_employee
                }

                if str(hours.client_id) in merged_ui_employee:
                    if 'entries' in merged_ui_employee[str(hours.client_id)]:
                        merged_ui_employee[str(hours.client_id)]['entries'].append(new_entry1)
                    else:
                        merged_ui_employee[str(hours.client_id)]['entries'] = [new_entry1]
                else:
                    merged_ui_employee[str(hours.client_id)] = {'entries': [new_entry1]}
                merged_ui_employee_list.append(new_entry1)

                new_entry = {
                    'client_id': hours.client_id,
                    'ui_employee_name': employee_name,
                    'ui_client_name': client1.toggl_client_name,
                    'ui_employee_salary': employee_salary,
                    'ui_contracted_hours': hours_for_employee,
                    'ui_total_contracted_hours': total_contracted_hours,
                    'ui_weeks': weeks,
                    'ui_total_weeks': ui_total_weeks,
                    'date': formatted_date,
                    'ui_cost': cost,
                    'working_day': working_day,
                    'role_of_employee': role_of_employee
                }

                if str(hours.client_id) in merged_ui_employee3:
                    if 'entries' in merged_ui_employee3[str(hours.client_id)]:
                        merged_ui_employee3[str(hours.client_id)]['entries'].append(new_entry)
                    else:
                        merged_ui_employee3[str(hours.client_id)]['entries'] = [new_entry]
                else:
                    merged_ui_employee3[str(hours.client_id)] = {'entries': [new_entry]}
                merged_ui_employee4.append(new_entry)
                # print('merged_ui_employee3')
                # print(merged_ui_employee3)
        except (json.JSONDecodeError, ValueError):
            pass


    count_days = count_working_days(start_date_str, end_date_str)


    # Assuming necessary imports and initializations are already done

    # Fetching the timesheets for the given employee and date range
    timesheets = timeSheet.objects.filter(employee_id=employee_id, time_entries_start_date__range=(start_date, end_date))

    # Initializing a defaultdict to store time spent month-wise
    monthly_time_spent = defaultdict(lambda: defaultdict(int))

    for data in timesheets:
        client_id = data.client_id
        time_spent = data.time_entries_seconds
        entry_date = data.time_entries_start_date
        
        # Extracting year and month from the entry date
        year_month = (entry_date.year, entry_date.month)
        
        # Storing time spent for each client, grouped by year and month
        monthly_time_spent[year_month][client_id] += time_spent

    # Initialize dictionaries to store formatted time and employee costs
    monthly_client_total_time_spent_formatted = defaultdict(lambda: defaultdict(str))
    monthly_client_tab_employee_cost = defaultdict(lambda: defaultdict(str))

    for year_month, client_times in monthly_time_spent.items():
        year, month = year_month
        # Calculate employee salary for each month
        employee1 = employee.objects.get(id=employee_id)
        employee_salary = get_salary_for_date(employee1, datetime(year, month, 1))
        working_days = count_working_days_in_month(month, year)
        
        for client_id, seconds1 in client_times.items():
            hours, remainder = divmod(seconds1, 3600)
            minutes, seconds2 = divmod(remainder, 60)
            monthly_client_total_time_spent_formatted[year_month][client_id] = f"{hours:02d}:{minutes:02d}:{seconds2:02d}"                
            
            hourly_working = employee_salary / (working_days * 8)
            employee_cost = (seconds1 / 3600) * float(hourly_working)
            monthly_client_tab_employee_cost[year_month][client_id] = "{:.2f}".format(employee_cost)


    # Continue with the rest of your existing code, grouping by month and processing accordingly
    result = (
        timeSheet.objects
        .filter(employee_id=employee_id, time_entries_start_date__range=(start_date, end_date))
        .values('time_entries_start_date', 'client_id', 'category_id', 'description')
        .annotate(total_time=Sum('time_entries_seconds'))
    )

    # Create a dictionary to store the results grouped by client ID and category ID month-wise
    monthly_client_category_info = defaultdict(lambda: defaultdict(lambda: {'client_name': '', 'category_name': '', 'dates': [], 'total_time': 0}))
    variable_counter = 1

    for entry in result:
        entry_date = entry['time_entries_start_date']
        year_month = (entry_date.year, entry_date.month)
        date_str = entry_date.strftime("%A %d %b")
        client_id = entry['client_id']
        category_id = entry['category_id']
        client_name = client.objects.get(id=client_id).toggl_client_name
        
        if category_id == 23:
            category_name = entry['description']  # Using description as category name if available
            key = (client_id, variable_counter)
            variable_counter += 1  # Increment variable counter
        else:
            category_name = Work_Category.objects.get(id=category_id).category
            key = (client_id, category_id)

        monthly_client_category_info[year_month][key]['client_id'] = client_id
        monthly_client_category_info[year_month][key]['client_name'] = client_name
        monthly_client_category_info[year_month][key]['category_name'] = category_name
        monthly_client_category_info[year_month][key]['dates'].append(date_str)
        monthly_client_category_info[year_month][key]['total_time'] += entry['total_time']

    # Process dates to be joined as strings
    for month_info in monthly_client_category_info.values():
        for info in month_info.values():
            info['dates'] = ", ".join(info['dates'])

    # Print the results month-wise
    client_category_dict = defaultdict(dict)
    ui_employee1 = defaultdict(dict)

    for year_month, client_category_info in monthly_client_category_info.items():
        year, month = year_month
        employee1 = employee.objects.get(id=employee_id)
        employee_salary = get_salary_for_date(employee1, datetime(year, month, 1))
        employee_name = employee1.first_name + " " + employee1.last_name
        working_days = count_working_days_in_month(month, year)
        # import datetime
        date = datetime(year, month, 1)
        days_in_month = calendar.monthrange(year, month)[1]
        ui_total_weeks = round(days_in_month / 7, 2)
        # Format the date to get "June 2024"
        formatted_date = date.strftime("%B %Y")
        for key, info in client_category_info.items():
            client_id, category_id = key
            client_name = info['client_name']
            client_id = info['client_id']
            category_name = info['category_name']
            dates = info['dates']
            total_time = info['total_time']

            # Fetch contract work entries
            contract_work_entries = Client_contract_work.objects.filter(
                date__year=year,
                date__month__range=[month, month],
                client_id=client_id
            ).order_by('date')

            # Extract and print the employee role
            for work in contract_work_entries:
                role_dict = json.loads(work.working_role)  # Deserialize the JSON string to a dictionary
                role_of_employee = role_dict.get(employee_id)
            
            # Convert total_time to hours, minutes, and seconds
            hours, remainder = divmod(total_time, 3600)
            minutes, seconds = divmod(remainder, 60)
            formatted_time = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
            
            hourly_working = round(employee_salary / (working_days * 8), 2)
            employee_cost = round((total_time / 3600) * float(hourly_working), 2)
            
            client_category_dict[year_month][(client_id, category_id)] = {
                'client_name': client_name,
                'category_name': category_name,
                'dates': dates,
                'formatted_date': formatted_date,
                'total_time': formatted_time,
                'employee_cost': employee_cost,
                'working_days': working_days,
                'ui_total_weeks': ui_total_weeks,
                'role_of_employee': role_of_employee
            }

            ui_employee1[year_month][str(client_id)] = {
                'ui_employee_name': employee_name,
                'ui_client_name': client_name,
                'ui_employee_salary': employee_salary,
                'ui_total_time': total_time,
                'dates': dates,
                'formatted_date': formatted_date,
                'working_day': working_days,
                'ui_total_weeks': ui_total_weeks,
                'role_of_employee': role_of_employee
            }

    total_contracted_cost = 0
    sumof_total_working_hours = 0
    total_cost = 0
    processed_client_ids = set()
    data = []
    data.append([''] * 18)
    for entry in merged_ui_employee4:
        monthly_salary = float(entry['ui_employee_salary'])
        weekly_hours = float(entry['ui_contracted_hours'])
        ui_total_contracted_hours = float(entry['ui_total_contracted_hours'])
        weeks = float(entry['ui_weeks'])
        ui_total_weeks = float(entry['ui_total_weeks'])
        client_id = str(entry['client_id'])
        month_name, year = entry['date'].split(", ")
        # month = datetime.datetime.strptime(month_name, "%B").month
        month = datetime.strptime(month_name, "%B").month
        year = int(year)
        # year, month = 2024, 8
        processed_client_ids.add(client_id)

        total_working_day = f"{entry['working_day']}*8"
        hourly_employee_cost = round(monthly_salary / (entry['working_day'] * 8), 2)

        contracted_employee_cost = round(hourly_employee_cost * weekly_hours * weeks, 2)

        total_contracted_cost += contracted_employee_cost
        ui_cost = float(entry['ui_cost'])

        if ui_total_contracted_hours != 0:
            working_time = round((weekly_hours / ui_total_contracted_hours) * ui_cost, 2)
        else:
            working_time = 0
        total_working_hours = (working_time / 4.3) * weeks
        total_working_hours1 = round(total_working_hours, 2)
        sumof_total_working_hours += total_working_hours1

        related_client_data = ui_employee1[(year, month)].get(client_id, {})
        ui_total_time = float(related_client_data.get('ui_total_time', 0))
        working_days = float(entry['working_day'])

        if working_days > 0:
            ui_total_time_hours = round(ui_total_time / 3600, 2)
            working_time = round(monthly_salary / (working_days * 8), 2)
            total = round((working_time * ui_total_time_hours), 2)
            total_cost += total
        else:
            total = 0

        data.append([
            entry['ui_employee_name'],
            entry['ui_client_name'],
            str(entry['date']),
            entry['role_of_employee'],
            monthly_salary,
            entry['working_day'],
            hourly_employee_cost,
            weekly_hours,
            weeks,
            '',
            ui_total_contracted_hours,
            ui_total_weeks,
            '',
            ui_cost,
            ui_total_time_hours,
            '',
            '',
            ''
        ])

    for (year, month), clients_data in ui_employee1.items():
        # month_name = calendar.month_abbr[month] if isinstance(month, int) else month
        # formatted_date = f"{month_name}, {year}"

        for client_id, client_data in clients_data.items():
            if client_id not in processed_client_ids:
                monthly_salary = float(client_data.get('ui_employee_salary', 0))
                ui_total_time = float(client_data.get('ui_total_time', 0))
                formatted_date = client_data.get('formatted_date')
                ui_total_time_hours = round(ui_total_time / 3600, 2)
                working_days = client_data.get('working_day', 0)
                if working_days > 0:
                    working_time = round(monthly_salary / (working_days * 8), 2)
                    hourly_employee_cost = round(monthly_salary / (working_days * 8), 2)
                else:
                    working_time = 0
                    hourly_employee_cost = 0
                # working_time = round(monthly_salary / (working_days * 8), 2)
                total = round((working_time * ui_total_time_hours), 2)
                total_cost += total

                data.append([
                    client_data.get('ui_employee_name', ''),
                    client_data.get('ui_client_name', ''),
                    formatted_date,
                    '',
                    monthly_salary,
                    working_days,
                    hourly_employee_cost,
                    0,
                    weeks,
                    '',
                    0,
                    client_data.get('ui_total_weeks', ''),
                    '',
                    '',
                    ui_total_time_hours,
                    '',
                    '',
                    ''
                ])
    
    sheet_name = 'Total Employee Data'
    data.append([''] * 18)
    # headers = [
    #     ['Employee Name','Client Name','Month','Monthly Salary','Monthly working days','Hourly Employee cost','Weekly Hourly Contracted','Role','Total weekly hours contracted', 'Monthly client revenue','Client Revenue in one month','Total no of weeks from Start date and end date','Total Working Hours','Total no of weeks in selected month','Client Revenue','Contracted Employee Cost','Actual Employee Cost']
    # ]

    headers = [
        ['Employee Name','Client Name','Month','Role','Monthly Salary','Monthly working days','Hourly Employee cost','Weekly Hours Contracted', 'Total no of weeks from Start date and end date','Monthly Hours Contracted','Total weekly hours contracted', 'Total no of weeks in selected month','Total Monthly Working Hours Contracted','Monthly client revenue','Total Working Hours from timer','Client Revenue','Contracted Employee Cost','Actual Employee Cost']
    ]
    data_with_headers = headers + data

    # Check if a record exists for this user and sheet name
    spreadsheet_record = SheetRecord.objects.filter(employee_id=employee_id, sheet_name=sheet_name,record_type = 'employee',google_email=google_email).first()
    if not spreadsheet_record:
        # Create a new spreadsheet if not found
        today_date = timezone.now().strftime('%Y-%m-%d')
        service = build('sheets', 'v4', credentials=credentials)
        spreadsheet = service.spreadsheets().create(body={
            'properties': {'title': sheet_name},
            'sheets': [
                {
                    'properties': {
                        'title': today_date  # Create the first sheet with today's date
                    }
                }
            ]}).execute()
        spreadsheet_id = spreadsheet['spreadsheetId']
        
        if spreadsheet_id:
            spreadsheet_url = f"https://docs.google.com/spreadsheets/d/{spreadsheet_id}"
            spreadsheet_record = SheetRecord.objects.create(
                employee_id=employee_id,
                google_email=google_email,
                spreadsheet_id=spreadsheet_id,
                sheet_name=sheet_name,
                record_type = 'employee'
            )
        else:
            return HttpResponse("Failed to create a new spreadsheet.", status=500)

    today_date = timezone.now().strftime('%Y-%m-%d')
    service = build('sheets', 'v4', credentials=credentials)

    existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_record.spreadsheet_id).execute()
    # Find the sheet with the title matching today's date (tab name)
    sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

    # # If the sheet does not exist, create it
    if not sheet:
        print('Test Sheet Record111')
        print(spreadsheet_record.spreadsheet_id)
        add_sheet_request = {
            "requests": [{
                "addSheet": {
                    "properties": {
                        "title": today_date
                    }
                }
            }]
        }
        service.spreadsheets().batchUpdate(spreadsheetId=spreadsheet_record.spreadsheet_id, body=add_sheet_request).execute()

        existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_record.spreadsheet_id).execute()
        sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

    sheet_id = sheet['properties']['sheetId']
    # Clear the existing data in the sheet (from A1 onwards)
    clear_range = f'{today_date}!A1:Z1000'  # Adjust the range as needed
    service.spreadsheets().values().clear(spreadsheetId=spreadsheet_record.spreadsheet_id, range=clear_range).execute()


    range_name = f'{today_date}!A1'
    body = {'values': data_with_headers}

    # Write the data to the newly created sheet
    service.spreadsheets().values().update(
        spreadsheetId=spreadsheet_record.spreadsheet_id,
        range=range_name,
        valueInputOption='RAW',
        body=body
    ).execute()

    # Prepare formulas for batch update
    last_row = len(data) + 1
    
    batch_update_body = {
        'requests': [
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': 1,
                        'endRowIndex': last_row - 1,  # Exclude the last row
                        'startColumnIndex': 6,
                        'endColumnIndex': 7
                    },
                    'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND(E{i}/(F{i}*8), 2)'}}]} for i in range(2, last_row)],
                    'fields': 'userEnteredValue'
                }
            },
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': 1,
                        'endRowIndex': last_row - 1,  # Exclude the last row
                        'startColumnIndex': 9,
                        'endColumnIndex': 10
                    },
                    'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=IF(I{i}=0, 0, ROUND(H{i}*I{i}, 2))'}}]} for i in range(2, last_row)],
                    'fields': 'userEnteredValue'
                }
            },
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': 1,
                        'endRowIndex': last_row - 1,  # Exclude the last row
                        'startColumnIndex': 12,
                        'endColumnIndex': 13
                    },
                    'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=IF(K{i}=0, 0, ROUND(K{i}*L{i}, 2))'}}]} for i in range(2, last_row)],
                    'fields': 'userEnteredValue'
                }
            },
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': 1,
                        'endRowIndex': last_row - 1,  # Exclude the last row
                        'startColumnIndex': 15,
                        'endColumnIndex': 16
                    },
                    # 'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND((N{i}*J{i})/M{i}, 2)'}}]} for i in range(2, last_row)],
                    # 'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=IF(OR(ISBLANK(K{i}), ISBLANK(N{i}), ISBLANK(L{i}), N{i}=0), 0, IF(N{i}=0, 0, ROUND(K{i}/N{i}*L{i}, 2)))'}}]} for i in range(2, last_row)],
                    'rows': [{'values': [{'userEnteredValue': {
                        'formulaValue': f'=IF(M{i}=0, 0, ROUND((N{i}*J{i})/M{i}, 2))'
                    }}]} for i in range(2, last_row)],
                    'fields': 'userEnteredValue'
                }
            },
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': 1,
                        'endRowIndex': last_row - 1,  # Exclude the last row
                        'startColumnIndex': 16,
                        'endColumnIndex': 17
                    },
                    'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND(G{i}*H{i}*I{i}, 2)'}}]} for i in range(2, last_row)],
                    'fields': 'userEnteredValue'
                }
            },
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': 1,
                        'endRowIndex': last_row - 1,  # Exclude the last row
                        'startColumnIndex': 17,
                        'endColumnIndex': 18
                    },
                    'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND(G{i}*O{i}, 2)'}}]} for i in range(2, last_row)],
                    'fields': 'userEnteredValue'
                }
            },
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': last_row - 1,
                        'endRowIndex': last_row,
                        'startColumnIndex': 15,
                        'endColumnIndex': 16
                    },
                    'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=SUM(P2:P{last_row - 1})'}}]}],
                    'fields': 'userEnteredValue'
                }
            },
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': last_row - 1,
                        'endRowIndex': last_row,
                        'startColumnIndex': 16,
                        'endColumnIndex': 17
                    },
                    'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=SUM(Q2:Q{last_row - 1})'}}]}],
                    'fields': 'userEnteredValue'
                }
            },
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': last_row - 1,
                        'endRowIndex': last_row,
                        'startColumnIndex': 17,
                        'endColumnIndex': 18
                    },
                    'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=SUM(R2:R{last_row - 1})'}}]}],
                    'fields': 'userEnteredValue'
                }
            }
            
        ]
    }

    # Execute batch update
    print('Test Sheet Record')
    print(spreadsheet_record.spreadsheet_id)
    # clear_range = f'{sheet_id}!A:Z' 
    # service.spreadsheets().values().clear(
    #     spreadsheetId=spreadsheet_record.spreadsheet_id,
    #     range=clear_range
    # ).execute()
    service.spreadsheets().batchUpdate(spreadsheetId=spreadsheet_record.spreadsheet_id, body=batch_update_body).execute()

    # Merge cells and set titles for row 1
    merge_cells_request = {
        "requests": [
            # Merge columns E1 to H1 for "Monthly Hours Contracted"
            {
                "mergeCells": {
                    "range": {
                        "sheetId": sheet_id,
                        "startRowIndex": 0,
                        "endRowIndex": 1,  # Row 1
                        "startColumnIndex": 7,  # Column F
                        "endColumnIndex": 10  # Column H (Exclusive)
                    },
                    "mergeType": "MERGE_ALL"
                }
            },
            # Merge columns I1 to L1 for "Total Monthly Hours To be Contracted"
            {
                "mergeCells": {
                    "range": {
                        "sheetId": sheet_id,
                        "startRowIndex": 0,
                        "endRowIndex": 1,  # Row 1
                        "startColumnIndex": 10,  # Column I
                        "endColumnIndex": 13  # Column L (Exclusive)
                    },
                    "mergeType": "MERGE_ALL"
                }
            },
            {
                "updateCells": {
                    "range": {
                        "sheetId": sheet_id,
                        "startRowIndex": 0,
                        "endRowIndex": 1,  # Row 1
                        "startColumnIndex": 0,  # Start clearing at Column A
                        "endColumnIndex": 7  # Clear up to Column E
                    },
                    # "rows": [{"values": [{"userEnteredValue": None}]} for _ in range(5)],
                    "rows": [{
                        "values": [{
                            "userEnteredValue": {"stringValue": None},
                        }]
                    }],
                    "fields": "userEnteredValue"
                }
            },
            {
                "updateCells": {
                    "range": {
                        "sheetId": sheet_id,
                        "startRowIndex": 0,
                        "endRowIndex": 1,  # Row 1
                        "startColumnIndex": 13,  # Start clearing at Column A
                        "endColumnIndex": 19  # Clear up to Column E
                    },
                    # "rows": [{"values": [{"userEnteredValue": None}]} for _ in range(5)],
                    "rows": [{
                        "values": [{
                            "userEnteredValue": {"stringValue": None},
                        }]
                    }],
                    "fields": "userEnteredValue"
                }
            },
            {
                "updateCells": {
                    "range": {
                        "sheetId": sheet_id,
                        "startRowIndex": 0,
                        "endRowIndex": 1,  # Row 1
                        "startColumnIndex": 13,  # Start clearing at Column A
                        "endColumnIndex": 19  # Clear up to Column E
                    },
                    # "rows": [{"values": [{"userEnteredValue": None}]} for _ in range(5)],
                    "rows": [{
                        "values": [{
                            "userEnteredValue": {"stringValue": None},
                        }]
                    }],
                    "fields": "userEnteredValue"
                }
            },
            # Set text alignment and bold formatting for merged cells in row 1
            {
                "updateCells": {
                    "range": {
                        "sheetId": sheet_id,
                        "startRowIndex": 0,
                        "endRowIndex": 1,
                        "startColumnIndex": 7,
                        "endColumnIndex": 10
                    },
                    "rows": [{
                        "values": [{
                            "userEnteredValue": {"stringValue": "Monthly Hours Contracted"},
                            "userEnteredFormat": {
                                "horizontalAlignment": "CENTER",
                                "textFormat": {"bold": True}
                            }
                        }]
                    }],
                    "fields": "userEnteredValue,userEnteredFormat"
                }
            },
            {
                "updateCells": {
                    "range": {
                        "sheetId": sheet_id,
                        "startRowIndex": 0,
                        "endRowIndex": 1,
                        "startColumnIndex": 10,
                        "endColumnIndex": 13
                    },
                    "rows": [{
                        "values": [{
                            "userEnteredValue": {"stringValue": "Total Monthly Hours To Be Contracted"},
                            "userEnteredFormat": {
                                "textFormat": {"bold": True}
                            }
                        }]
                    }],
                    "fields": "userEnteredValue,userEnteredFormat"
                }
            }
        ]
    }

    # Add headers in row 2
    # Define the columns to make bold (indices start at 0)
    bold_columns = [9, 12, 14,15,16,17]  # Example: Columns A, B, E, H, and K

    headers_request = {
        "requests": [
            {
                "updateCells": {
                    "range": {
                        "sheetId": sheet_id,
                        "startRowIndex": 1,  # Row 2
                        "endRowIndex": 2,
                        "startColumnIndex": 0,
                        "endColumnIndex": len(headers[0])  # Total number of columns
                    },
                    "rows": [{
                        "values": [
                            {
                                "userEnteredValue": {"stringValue": header},
                                "userEnteredFormat": {
                                    "textFormat": {"bold": True}  # Apply bold only for specific columns
                                } if col_idx in bold_columns else {
                                    "textFormat": {"bold": False}  # Non-bold formatting
                                }
                            }
                            for col_idx, header in enumerate(headers[0])
                        ]
                    }],
                    "fields": "userEnteredValue,userEnteredFormat.textFormat.bold"
                }
            }
        ]
    }


    # Execute the merge cells and headers requests
    service.spreadsheets().batchUpdate(
        spreadsheetId=spreadsheet_record.spreadsheet_id,
        body={"requests": merge_cells_request["requests"] + headers_request["requests"]}
    ).execute()
    # Redirect to the newly created Google Sheet
    return redirect(f'https://docs.google.com/spreadsheets/d/{spreadsheet_record.spreadsheet_id}/edit#gid={sheet_id}')


@csrf_exempt
@login_required(login_url='/')
def export_client_data(request):
    if request.method == 'POST':
        client_id = request.POST.get('client_id', None)
        date_range = request.POST.get('date_range', None)
        request.session['client_id'] = client_id
        request.session['date_range'] = date_range
        request.session['redirect_method'] = 'export_client_data'

    # Check if we have valid credentials
    if 'credentials' not in request.session:
        authorization_url, _ = flow.authorization_url(prompt='consent')
        return redirect(authorization_url)

    credentials = Credentials.from_authorized_user_info(request.session['credentials'])
    service = build('oauth2', 'v2', credentials=credentials)
    userinfo = service.userinfo().get().execute()
    google_email = userinfo.get('email')

    import calendar
    from datetime import date, datetime, timedelta

    client_id = request.session.get('client_id')
    date_range = request.session.get('date_range')
    request_type = ''
    from_date_str, to_date_str = date_range.split(" - ")

    from_date = datetime.strptime(from_date_str, "%m/%d/%Y").date()
    to_date = datetime.strptime(to_date_str, "%m/%d/%Y").date()

    from datetime import datetime

    # Convert from_date and to_date to strings
    from_date_str = from_date.strftime('%Y-%m-%d')
    to_date_str = to_date.strftime('%Y-%m-%d')

    # Convert start_date_str and end_date_str to datetime objects
    start_date = datetime.strptime(from_date_str, '%Y-%m-%d')
    end_date = datetime.strptime(to_date_str, '%Y-%m-%d')
    # Extract the year from the datetime objects
    current_month = start_date.month
    current_year = start_date.year
    working_days = count_working_days_in_month(current_month, current_year)

    start_date_str = start_date.strftime('%Y-%m-%d')
    end_date_str = end_date.strftime('%Y-%m-%d')
    
    if start_date and end_date:
        start_date=start_date.date()
        end_date=end_date.date()
    # Get the start and end months
    start_month = start_date.month
    end_month = end_date.month

    weeks=0
    ui={}

    client_detail = client.objects.get(pk=client_id)
    toggl_client = client_detail.toggl_client_id
    
    ui_client_data=[]
    selected_client_data = {}
    
    # Extract start and end year and month
    start_year, start_month = from_date.year, from_date.month
    end_year, end_month = to_date.year, to_date.month

    # Check if the date range spans multiple years
    if start_year == end_year:
        # Query for the same year
        query = Q(date__year=start_year, date__month__range=[start_month, end_month])
    else:
        # Query for the range spanning multiple years
        query = (
            Q(date__year=start_year, date__month__gte=start_month) |
            Q(date__year=end_year, date__month__lte=end_month)
        )
    # if Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month]).exists():
    #     # Use the contracted_hours model to query the database
    #     all = Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month])
        
    if Client_contract_work.objects.filter(client_id=client_id).filter(query).exists():
        all = Client_contract_work.objects.filter(client_id=client_id).filter(query)
        # Iterate over each record in the queryset
        for record in all:
            first_record = record
            ui_final_cost=first_record.cost
            date1=first_record
            date=date1.date
            target_month=date.month
            work_json_str = first_record.working_input

            # Parse the JSON string
            work_dict = json.loads(work_json_str)

            import calendar
            from datetime import datetime
            if target_month < start_date.month:  # If target_month is earlier in the year
                target_year = start_date.year + 1  # Next year
            else:
                target_year = start_date.year  # Same year

            # Calculate target_month_start
            target_month_start = start_date.replace(year=target_year, month=target_month, day=1)

            # Determine the start_date_in_target_month
            start_date_in_target_month = max(start_date, target_month_start)

            # Ensure target_month is in the correct year
            if start_date_in_target_month.month == target_month:
                if target_month == 12:
                    next_month_date = start_date_in_target_month.replace(year=start_date_in_target_month.year + 1, month=1, day=1)
                else:
                    next_month_date = start_date_in_target_month.replace(month=target_month + 1, day=1)

                target_month_end = min(next_month_date - timedelta(days=1), end_date)
            else:
                if target_month < start_date_in_target_month.month:
                    target_year = start_date_in_target_month.year + 1
                else:
                    target_year = start_date_in_target_month.year

                target_month_start = datetime(target_year, target_month, 1)
                target_month_end = min(target_month_start - datetime.resolution, end_date)

            if target_month_end.month == start_date_in_target_month.month:
                total_days_between = (target_month_end - start_date_in_target_month).days + 1
            else:
                total_days_between = (target_month_end - start_date_in_target_month).days

            date_difference=total_days_between

            days_in_month = calendar.monthrange(date.year, date.month)[1]
            ui_total_weeks = round(days_in_month / 7, 2)

            if date_difference==days_in_month:
                # weeks=4.3
                weeks = round(days_in_month / 7, 2)
                weeks=round(weeks,2)
                cost_new=first_record.cost
            else:
                weeks = date_difference / 7
                weeks=round(weeks,2)
                c=round((first_record.cost * weeks) , 2)
                cost_new = round((c) / ui_total_weeks, 2)


            formatted_date = date.strftime("%B, %Y")
            working_days = count_working_days_in_month(date.month, date.year)
            # Formatting the time
            ui_client_data1 = {
                'ui_cost': first_record.cost,
                'ui_weeks': weeks,
                'ui_total_weeks': ui_total_weeks,
                'ui_date_difference':date_difference,
                'working_days': working_days,
                'date': formatted_date
            }
            unique_client_key = f"{date.year}_{date.month}_{client_detail.id}"

                # Append this dictionary to the list
            ui_client_data.append(ui_client_data1)
            selected_client_data[unique_client_key] = ui_client_data1
    else:
        print("No contracted hours found for the specified client.")

    # vinod test end

    # Filtering timesheets based on client_id and date range
    timesheets = timeSheet.objects.filter(client_id=client_id, time_entries_start_date__range=(start_date, end_date))

    # Dictionary to store employee IDs and their total time worked
    employee_data = {}
    ui = {}

    # Calculate total time worked by each employee for the client
    for timesheet1 in timesheets:
        employee_id = timesheet1.employee_id
        time_worked_seconds = timesheet1.time_entries_seconds
        entry_date = timesheet1.time_entries_start_date

        # Extracting year and month from the entry date
        year_month = (entry_date.year, entry_date.month)

        # Ensure year_month is in employee_data
        if year_month not in employee_data:
            employee_data[year_month] = {}

        # Ensure employee_id is in employee_data[year_month]
        if employee_id not in employee_data[year_month]:
            employee_data[year_month][employee_id] = {'time_worked': 0, 'salary': 0, 'date': entry_date}

        # Update total time worked for the employee
        employee_data[year_month][employee_id]['time_worked'] += time_worked_seconds

    # Check if there are any Client_contract_work records for the client within the given date range
    # if Client_contract_work.objects.filter(client_id=client_id, date__year=current_year, date__month__range=[start_month, end_month]).exists():
    #     # Query the Client_contract_work model for the relevant records
    #     all_contracts = Client_contract_work.objects.filter(client_id=client_id, date__year=current_year, date__month__range=[start_month, end_month])

    if Client_contract_work.objects.filter(client_id=client_id).filter(query).exists():
        all_contracts = Client_contract_work.objects.filter(client_id=client_id).filter(query)
        # Iterate over each record in the queryset
        for record in all_contracts:
            first_record = record

            # Access the 'working_input' attribute
            work_json_str = first_record.working_input

            # Parse the JSON string into a dictionary
            work_dict = json.loads(work_json_str)

            # Update employee_data with any missing employee IDs
            for employee_id in work_dict.keys():
                employee_id_int = int(employee_id)
                if employee_id_int not in employee_data:
                    employee_data[employee_id_int] = {'time_worked': 0, 'salary': 0, 'date': first_record.date}

    # Process employee data for UI output
    for key, value in employee_data.items():
        # Check if the key is a tuple (year, month), indicating nested employee data
        if isinstance(key, tuple):
            year_month, employees = key, value
            year, month = year_month

            for employee_id, employee_info in employees.items():
                # Generate a unique key combining year, month, and employee_id
                unique_key = f"{year}_{month}_{employee_id}"

                employee1 = employee.objects.get(id=employee_id)
                entry_date = employee_info['date']

                # Calculate salary if the employee has one
                if employee1.salary:
                    emp_salary = get_salary_for_date(employee1, entry_date)
                    employee_info['salary'] = emp_salary
                    salary = emp_salary
                else:
                    employee_info['salary'] = 0
                    salary = 0

                # Convert time worked from seconds to hours
                time_worked_hours = employee_info['time_worked'] / 3600

                # Construct employee's full name
                if employee1.first_name and employee1.last_name:
                    name = employee1.first_name + ' ' + employee1.last_name
                else:
                    name = employee1.user_name

                # Format the date for UI display
                formatted_date = entry_date.strftime("%B, %Y")
                working_days = count_working_days_in_month(month, current_year)

                days_in_month = calendar.monthrange(current_year, month)[1]
                ui_total_weeks = round(days_in_month / 7, 2)

                # Store the data for the UI
                ui[unique_key] = {
                    'ui_employee_name': name,
                    'ui_employee_salary': salary,
                    'ui_working_hours': time_worked_hours,
                    'working_days': working_days,
                    'ui_total_weeks': ui_total_weeks,
                    'date': formatted_date
                }

        # Handle the case where the employee ID is at the top level
        elif isinstance(key, int):
            employee_id = key
            employee_info = value
            entry_date = employee_info['date']

            # Generate a unique key combining year, month, and employee_id
            year, month = entry_date.year, entry_date.month
            unique_key = f"{year}_{month}_{employee_id}"

            employee1 = employee.objects.get(id=employee_id)

            # Calculate salary if the employee has one
            if employee1.salary:
                emp_salary = get_salary_for_date(employee1, entry_date)
                employee_info['salary'] = emp_salary
                salary = emp_salary
            else:
                employee_info['salary'] = 0
                salary = 0

            # Convert time worked from seconds to hours
            time_worked_hours = employee_info['time_worked'] / 3600

            # Construct employee's full name
            if employee1.first_name and employee1.last_name:
                name = employee1.first_name + ' ' + employee1.last_name
            else:
                name = employee1.user_name

            # Format the date for UI display
            formatted_date = entry_date.strftime("%B, %Y")
            working_days = count_working_days_in_month(month, current_year)
            days_in_month = calendar.monthrange(current_year, month)[1]
            ui_total_weeks = round(days_in_month / 7, 2)
            # Store the data for the UI
            ui[unique_key] = {
                'ui_employee_name': name,
                'ui_employee_salary': salary,
                'ui_working_hours': time_worked_hours,
                'working_days': working_days,
                'ui_total_weeks': ui_total_weeks,
                'date': formatted_date
            }
    
    employee_salary_dict = {}
    ui_data=[]

    # if Client_contract_work.objects.filter(client_id=client_id,date__month__range=[start_month, end_month],date__year=current_year).exists():
    #     contracted_client1 = Client_contract_work.objects.filter(client_id=client_id,date__year=current_year,date__month__range=[start_month, end_month])

    if Client_contract_work.objects.filter(client_id=client_id).filter(query).exists():
        contracted_client1 = Client_contract_work.objects.filter(client_id=client_id).filter(query)

        for contracted_client in contracted_client1:
            date1=contracted_client
            date=date1.date
            target_month=date.month
            import ast
            from decimal import Decimal
            import calendar
            from datetime import datetime
            # target_month_start = start_date.replace(month=target_month, day=1)

            # # Ensure that the start date is within the target month
          
            #     total_days_between = (target_month_end - start_date_in_target_month).days
            if target_month < start_date.month:  # If target_month is earlier in the year
                target_year = start_date.year + 1  # Next year
            else:
                target_year = start_date.year  # Same year

            # Calculate target_month_start
            target_month_start = start_date.replace(year=target_year, month=target_month, day=1)

            # Determine the start_date_in_target_month
            start_date_in_target_month = max(start_date, target_month_start)

            # Ensure target_month is in the correct year
            if start_date_in_target_month.month == target_month:
                if target_month == 12:
                    next_month_date = start_date_in_target_month.replace(year=start_date_in_target_month.year + 1, month=1, day=1)
                else:
                    next_month_date = start_date_in_target_month.replace(month=target_month + 1, day=1)

                target_month_end = min(next_month_date - timedelta(days=1), end_date)
            else:
                if target_month < start_date_in_target_month.month:
                    target_year = start_date_in_target_month.year + 1
                else:
                    target_year = start_date_in_target_month.year

                target_month_start = datetime(target_year, target_month, 1)
                target_month_end = min(target_month_start - datetime.resolution, end_date)

            if target_month_end.month == start_date_in_target_month.month:
                total_days_between = (target_month_end - start_date_in_target_month).days + 1
            else:
                total_days_between = (target_month_end - start_date_in_target_month).days

            date_difference=total_days_between

            # Get the number of days in that month
            days_in_month = calendar.monthrange(date.year, date.month)[1]

            if date_difference==days_in_month:
                weeks= round(days_in_month / 7, 2)
            else:
                weeks = date_difference / 7

            ui_total_weeks = round(days_in_month / 7, 2)

            contracted_working_hours_1_str = contracted_client.working_input
            contracted_working_hours_1 = ast.literal_eval(contracted_working_hours_1_str)

            for employee_id, working_hours in contracted_working_hours_1.items():
                # Fetch the employee from the Employee table
                employee3 = employee.objects.get(id=employee_id)
                # Calculate salary per hour
                emp3_salary = get_salary_for_date(employee3, date)
                ui_employee_salary=float(emp3_salary)
                salary_per_hour = float(emp3_salary) / (working_days * 8)
                salary_per_hour=round(salary_per_hour,2)
                # Convert working hours to float
                working_hours = float(working_hours)
                ui_working_hours=working_hours

                if employee3.first_name and employee3.last_name:
                    name=employee3.first_name + ' ' + employee3.last_name
                else:
                    name=employee3.user_name

                weeks=round(weeks,2)
                formatted_date = date.strftime("%B, %Y")
                selected_month = date.month
                selected_year = date.year
                working_days = count_working_days_in_month(selected_month, selected_year)
                year, month = entry_date.year, entry_date.month
                unique_employee_key = f"{current_year}_{selected_month}_{employee3.id}"
                ui_employee_data = {
                    'ui_employee_id': unique_employee_key,
                    'ui_employee_name': name,
                    'ui_employee_salary': emp3_salary,
                    'ui_working_hours': working_hours,
                    'ui_weeks': weeks,
                    'ui_total_weeks': ui_total_weeks,
                    'working_days': working_days,
                    'date': formatted_date
                }

                ui_data.append(ui_employee_data)

    total_time_spent_formatted={}
    project_names={}
    project_user_dict={}
    employee_rate_per_hour={}

    count_days = count_working_days(start_date_str, end_date_str)

    # data = [
    #     ['Employee Name','Client Name','Month','Monthly Salary','Total no of working days', 'Hourly Employee cost','Contracted weekly working hours for employee','Total no of weeks from Start date and end date','Total weekly hours contracted','Time spent from Start date and end date(in hours from timer)','Contracted Employee Cost','Total actual cost','Total Client Revenue']    
    # ]
    data = []

    total_contracted_cost = 0
    total_cost = 0
    processed_employee_ids = set()
    data.append([''] * 15)
    for entry_data in ui_data:    
        # Convert the string to a datetime object
        date_obj = datetime.strptime(entry_data['date'], '%B, %Y')        
        # Get the month as a number
        month_number = date_obj.month
        year = date_obj.year
        working_days = entry_data['working_days']
        ui_total_weeks = float(entry_data['ui_total_weeks'])
        
        generate_unique_key = f'{year}_{month_number}_{client_detail.id}'
        revenue = selected_client_data.get(generate_unique_key, {})
        cost = float(revenue['ui_cost'])
        weeks = float(revenue['ui_weeks'])
        cal = round((cost * weeks), 2)
        total_revenue = round((cal / ui_total_weeks), 2)

        ui_employee_id = str(entry_data['ui_employee_id'])
        employee_name = entry_data['ui_employee_name']
        employee_salary = float(entry_data['ui_employee_salary'])
        working_hours = float(entry_data['ui_working_hours'])
        weeks = float(entry_data['ui_weeks'])
        processed_employee_ids.add(ui_employee_id)
        
        totalWorkingHours = round(weeks * working_hours, 2)
        working_time = round(employee_salary / (working_days * 8), 2)
        total = round(totalWorkingHours * working_time, 2)
        total_contracted_cost +=total

        ui_entry = ui.get(ui_employee_id, {})    
        if ui_entry:
            working_hours2 = ui_entry.get('ui_working_hours', 0.0)
        else:
            working_hours2 = 0.0
        working_time2 = round((employee_salary / (working_days * 8)), 2)
        total2 = round((working_time2 * working_hours2), 2)
        total_cost += total2

        data.append([
            employee_name,
            client_detail.client_name,
            str(entry_data['date']),
            employee_salary,
            f"{working_days}",
            working_time,
            working_hours,
            weeks,
            totalWorkingHours,
            cost,
            working_hours2,
            ui_total_weeks,
            '',
            ''
            ''
        ])
    for employee_id, data1 in ui.items():
        if employee_id not in processed_employee_ids:
            # Convert the string to a datetime object
            date_obj = datetime.strptime(entry_data['date'], '%B, %Y')        
            # Get the month as a number
            month_number = date_obj.month
            year = date_obj.year
            
            generate_unique_key = f'{year}_{month_number}_{client_detail.id}'
            revenue = selected_client_data.get(generate_unique_key, {})
            cost = float(revenue['ui_cost'])
            weeks = float(revenue['ui_weeks'])
            ui_total_weeks = float(entry_data['ui_total_weeks'])

            employee_name = data1['ui_employee_name']
            employee_salary = float(data1['ui_employee_salary'])
            working_hours = float(data1['ui_working_hours'])
            
            working_time = round((employee_salary / (working_days * 8)), 2)
            total = round((working_time * working_hours), 2)
            total_cost += total
            data.append([
                employee_name,
                client_detail.client_name,
                data1['date'],
                employee_salary,
                f"{working_days}",
                working_time,
                0,
                weeks,
                '',
                cost,
                working_hours,
                ui_total_weeks,
                '',
                ''
                ''
            ])    

    data.append([''] * 15)
    headers = [
        ['Employee Name','Client Name','Month','Monthly Salary','Total no of working days', 'Hourly Employee cost','Contracted weekly working hours for employee','Total no of weeks from Start date and end date','Total weekly hours contracted','Monthly client revenue','Time spent from Start date and end date(in hours from timer)','Total no of weeks in selected month','Contracted Employee Cost','Actual Employee Cost','Client Revenue']    
    ]
    data_with_headers = headers + data
    sheet_name = 'Total Client Data'

    spreadsheet_record = SheetRecord.objects.filter(client_id=client_id, sheet_name=sheet_name,record_type = 'client',google_email=google_email).first()
    if not spreadsheet_record:
        # Create a new spreadsheet if not found
        today_date = timezone.now().strftime('%Y-%m-%d')
        service = build('sheets', 'v4', credentials=credentials)
        spreadsheet = service.spreadsheets().create(body={
            'properties': {'title': sheet_name},
            'sheets': [
                {
                    'properties': {
                        'title': today_date  # Create the first sheet with today's date
                    }
                }
            ]}).execute()
        spreadsheet_id = spreadsheet['spreadsheetId']
        
        if spreadsheet_id:
            spreadsheet_url = f"https://docs.google.com/spreadsheets/d/{spreadsheet_id}"
            spreadsheet_record = SheetRecord.objects.create(
                client_id=client_id,
                google_email=google_email,
                spreadsheet_id=spreadsheet_id,
                sheet_name=sheet_name,
                record_type = 'client'
            )
        else:
            return HttpResponse("Failed to create a new spreadsheet.", status=500)

    today_date = timezone.now().strftime('%Y-%m-%d')
    service = build('sheets', 'v4', credentials=credentials)

    existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_record.spreadsheet_id).execute()
    # Find the sheet with the title matching today's date (tab name)
    sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

    # # If the sheet does not exist, create it
    if not sheet:
        print('Test Sheet Record111')
        print(spreadsheet_record.spreadsheet_id)
        add_sheet_request = {
            "requests": [{
                "addSheet": {
                    "properties": {
                        "title": today_date
                    }
                }
            }]
        }
        service.spreadsheets().batchUpdate(spreadsheetId=spreadsheet_record.spreadsheet_id, body=add_sheet_request).execute()

        existing_sheets = service.spreadsheets().get(spreadsheetId=spreadsheet_record.spreadsheet_id).execute()
        sheet = next((s for s in existing_sheets['sheets'] if s['properties']['title'] == today_date), None)

    sheet_id = sheet['properties']['sheetId']
    # Clear the existing data in the sheet (from A1 onwards)
    clear_range = f'{today_date}!A1:Z1000'  # Adjust the range as needed
    service.spreadsheets().values().clear(spreadsheetId=spreadsheet_record.spreadsheet_id, range=clear_range).execute()


    range_name = f'{today_date}!A1'
    body = {'values': data_with_headers}

    # Write the data to the newly created sheet
    service.spreadsheets().values().update(
        spreadsheetId=spreadsheet_record.spreadsheet_id,
        range=range_name,
        valueInputOption='RAW',
        body=body
    ).execute()

    # Prepare formulas for batch update
    last_row = len(data) + 1
    
    batch_update_body = {
        'requests': [
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': 1,
                        'endRowIndex': last_row - 1,  # Exclude the last row
                        'startColumnIndex': 5,
                        'endColumnIndex': 6
                    },
                    'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND(D{i}/(E{i}*8), 2)'}}]} for i in range(2, last_row)],
                    'fields': 'userEnteredValue'
                }
            },
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': 1,
                        'endRowIndex': last_row - 1,  # Exclude the last row
                        'startColumnIndex': 8,
                        'endColumnIndex': 9
                    },
                    'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND(G{i}*H{i}, 2)'}}]} for i in range(2, last_row)],
                    'fields': 'userEnteredValue'
                }
            },
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': 1,
                        'endRowIndex': last_row - 1,  # Exclude the last row
                        'startColumnIndex': 12,
                        'endColumnIndex': 13
                    },
                    'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND(I{i}*(F{i}), 2)'}}]} for i in range(2, last_row)],
                    'fields': 'userEnteredValue'
                }
            },            
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': 1,
                        'endRowIndex': last_row - 1,  # Exclude the last row
                        'startColumnIndex': 13,
                        'endColumnIndex': 14
                    },
                    'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND(F{i}*(K{i}), 2)'}}]} for i in range(2, last_row)],
                    'fields': 'userEnteredValue'
                }
            },
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': 1,
                        'endRowIndex': last_row - 1,  # Exclude the last row
                        'startColumnIndex': 14,
                        'endColumnIndex': 15
                    },
                    # 'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=ROUND(J{i}*(H{i})/L{i}, 2)'}}]} for i in range(2, last_row)],
                    'rows': [{'values': [{'userEnteredValue': {
                        'formulaValue': f'=IF(I{i}=0, 0, ROUND(J{i}*(H{i})/L{i}, 2))'
                    }}]} for i in range(2, last_row)],
                    'fields': 'userEnteredValue'
                }
            },            
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': last_row - 1,
                        'endRowIndex': last_row,
                        'startColumnIndex': 12,
                        'endColumnIndex': 13
                    },
                    'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=SUM(M2:M{last_row - 1})'}}]}],
                    'fields': 'userEnteredValue'
                }
            },
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': last_row - 1,
                        'endRowIndex': last_row,
                        'startColumnIndex': 13,
                        'endColumnIndex': 14
                    },
                    'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=SUM(N2:N{last_row - 1})'}}]}],
                    'fields': 'userEnteredValue'
                }
            },
            {
                'updateCells': {
                    'range': {
                        'sheetId': sheet_id,
                        'startRowIndex': last_row - 1,
                        'endRowIndex': last_row,
                        'startColumnIndex': 14,
                        'endColumnIndex': 15
                    },
                    'rows': [{'values': [{'userEnteredValue': {'formulaValue': f'=SUM(O2:O{last_row - 1})'}}]}],
                    'fields': 'userEnteredValue'
                }
            }
        ]
    }

    # Execute batch update
    service.spreadsheets().batchUpdate(spreadsheetId=spreadsheet_record.spreadsheet_id, body=batch_update_body).execute()
    merge_cells_request = {
        "requests": [
            # Merge columns E1 to H1 for "Monthly Hours Contracted"
            {
                "mergeCells": {
                    "range": {
                        "sheetId": sheet_id,
                        "startRowIndex": 0,
                        "endRowIndex": 1,  # Row 1
                        "startColumnIndex": 6,  # Column F
                        "endColumnIndex": 9  # Column H (Exclusive)
                    },
                    "mergeType": "MERGE_ALL"
                }
            },
            {
                "updateCells": {
                    "range": {
                        "sheetId": sheet_id,
                        "startRowIndex": 0,
                        "endRowIndex": 1,  # Row 1
                        "startColumnIndex": 0,  # Start clearing at Column A
                        "endColumnIndex": 6  # Clear up to Column E
                    },
                    # "rows": [{"values": [{"userEnteredValue": None}]} for _ in range(5)],
                    "rows": [{
                        "values": [{
                            "userEnteredValue": {"stringValue": None},
                        }]
                    }],
                    "fields": "userEnteredValue"
                }
            },
            {
                "updateCells": {
                    "range": {
                        "sheetId": sheet_id,
                        "startRowIndex": 0,
                        "endRowIndex": 1,  # Row 1
                        "startColumnIndex": 9,  # Start clearing at Column A
                        "endColumnIndex": 15  # Clear up to Column E
                    },
                    # "rows": [{"values": [{"userEnteredValue": None}]} for _ in range(5)],
                    "rows": [{
                        "values": [{
                            "userEnteredValue": {"stringValue": None},
                        }]
                    }],
                    "fields": "userEnteredValue"
                }
            },
            # Set text alignment and bold formatting for merged cells in row 1
            {
                "updateCells": {
                    "range": {
                        "sheetId": sheet_id,
                        "startRowIndex": 0,
                        "endRowIndex": 1,
                        "startColumnIndex": 6,
                        "endColumnIndex": 9
                    },
                    "rows": [{
                        "values": [{
                            "userEnteredValue": {"stringValue": "Monthly Working Hours Contracted"},
                            "userEnteredFormat": {
                                "horizontalAlignment": "CENTER",
                                "textFormat": {"bold": True}
                            }
                        }]
                    }],
                    "fields": "userEnteredValue,userEnteredFormat"
                }
            }
        ]
    }

    # Add headers in row 2
    # Define the columns to make bold (indices start at 0)
    bold_columns = [5,8,9, 10,11,12, 13,14]  # Example: Columns A, B, E, H, and K

    headers_request = {
        "requests": [
            {
                "updateCells": {
                    "range": {
                        "sheetId": sheet_id,
                        "startRowIndex": 1,  # Row 2
                        "endRowIndex": 2,
                        "startColumnIndex": 0,
                        "endColumnIndex": len(headers[0])  # Total number of columns
                    },
                    "rows": [{
                        "values": [
                            {
                                "userEnteredValue": {"stringValue": header},
                                "userEnteredFormat": {
                                    "textFormat": {"bold": True}  # Apply bold only for specific columns
                                } if col_idx in bold_columns else {
                                    "textFormat": {"bold": False}  # Non-bold formatting
                                }
                            }
                            for col_idx, header in enumerate(headers[0])
                        ]
                    }],
                    "fields": "userEnteredValue,userEnteredFormat.textFormat.bold"
                }
            }
        ]
    }


    # Execute the merge cells and headers requests
    service.spreadsheets().batchUpdate(
        spreadsheetId=spreadsheet_record.spreadsheet_id,
        body={"requests": merge_cells_request["requests"] + headers_request["requests"]}
    ).execute()
    # Redirect to the newly created Google Sheet
    return redirect(f'https://docs.google.com/spreadsheets/d/{spreadsheet_record.spreadsheet_id}/edit#gid={sheet_id}')


from google.oauth2 import id_token
from google.auth.transport import requests


@csrf_exempt
def auth_receiver(request):
    """
    Google calls this URL after the user has signed in with their Google account.
    """
    print('Inside')
    token = request.POST['credential']
    c_id = "338920935761-qo45770jjhdg2q2e80aldv9t1kia578k.apps.googleusercontent.com"
    # return HttpResponse(f'{token}:{id_token}:{requests.Request()} INSIDE')
    request_info = str(requests.Request())
    id_token_info = id_token.__name__
    # return HttpResponse(f'Request Info: {request_info}, ID Token Module: {id_token_info}')
    try:
        user_data = id_token.verify_oauth2_token(
            token, requests.Request(), c_id,clock_skew_in_seconds=300,
        )
        # return HttpResponse(f'{user_data}')
    except Exception as e:
        return HttpResponse(f'{e}:TESTING:Request Info: {request_info}, ID Token Module: {id_token_info}')

    # In a real app, I'd also save any new user here to the database.
    # You could also authenticate the user here using the details from Google (https://docs.djangoproject.com/en/4.2/topics/auth/default/#how-to-log-a-user-in)
    request.session['google_user_data'] = user_data

    email = user_data.get('email')
    if email:
        try:
            # Check if a user with the given email exists
            user = User.objects.get(email=email)
            # Authenticate and log in the user
            auth.login(request, user)
            # You can also store user data in the session if needed
            request.session['google_user_data'] = user_data
            employee1 = employee.objects.get(email=user_data['email'])
            if employee1:
                request.session['first_name'] = employee1.first_name
                request.session['last_name'] = employee1.last_name
                request.session['user_image_url'] = employee1.image_url
                request.session['user_name'] = employee1.user_name
                request.session['user_id'] = employee1.id
            print(f"User {user.username} logged in via Google authentication.")
            return redirect('admin-dashboard')  # Redirect to the appropriate dashboard
        except User.DoesNotExist:
            messages.info(request, 'User with this email does not exist Please Register.')
            return redirect('login')

    return redirect('login')


def test_google_auth(request):
    try:
        
        response = {
            "google_auth_installed": True,
            "id_token_available": True,
            "requests_available": True,
        }
    except ImportError as e:
        response = {
            "google_auth_installed": False,
            "error": str(e),
        }
    except Exception as e:
        response = {
            "google_auth_installed": False,
            "unexpected_error": str(e),
        }
    return JsonResponse(response)



def update_email_view(request):
    try:
        # Update auth_user table
        user = User.objects.filter(id=37, email='jharna.agrawal@brickwin.com').first()


        return JsonResponse({"status": "success", "message": "Emails updated successfully."})
    except Exception as e:
        return JsonResponse({"status": "error", "message": str(e)})

def get_project_data(request, project_id):
    import ast
    project_data = project.objects.filter(id=project_id).first()
    print("Vinod")
    print(project_data)

    working_role = ast.literal_eval(project_data.working_role)

    leader_ids = [employee_id for employee_id, role in working_role.items() if role == 'L']
    support_ids = [employee_id for employee_id, role in working_role.items() if role == 'S']
    advisor_ids = [employee_id for employee_id, role in working_role.items() if role == 'A']
    
    employee_list = employee.objects.filter(status=1).all()


    data = {
        'id': project_data.id,
        'project_name': project_data.project_name,
        'company': project_data.company,
        'client_id': project_data.client_id,
        'start_date': project_data.start_date,
        'end_date': project_data.end_date,
        'rate': project_data.rate,
        'rate_type': project_data.rate_type,
        'working_hours': project_data.working_hours,
        'working_hours_type': project_data.working_hours_type,
        'description': project_data.description,
        'duration': project_data.duration,
        'duration_type': project_data.duration_type,
        'status': project_data.status,
        'leader_ids': leader_ids,
        'support_ids': support_ids,
        'advisor_ids': advisor_ids,
        'employee_list': [{'id': e.id, 'first_name': e.first_name, 'last_name': e.last_name, 'image_url': e.image_url} for e in employee_list]
    }
    return JsonResponse(data)

@login_required(login_url='/')
def delete_project(request):
    if request.method == 'GET':
        project_id = request.GET.get('project_id')
        try:
            project_to_delete = project.objects.get(id=project_id)
            project_to_delete.delete()
            status = 1
            print("project deleted successfully.")
        except project.DoesNotExist:
            status = 0
            print("project with the given ID does not exist.")

        return JsonResponse({'status': status})

def check_project_name(request):
    project_name = request.GET.get('project_name', '').strip()
    
    exists = project.objects.filter(project_name=project_name).exists()
    return JsonResponse({'exists': exists})

def update_project_status(request):
    if request.method == 'GET':
        print("search")
        # Retrieve the project_type from the query parameters
        project_id = request.GET.get('project_id', None)
        project_status = request.GET.get('project_status', None)

        if project_id:
            try:
                check_project = project.objects.get(id=project_id)
                if check_project:
                    check_project.status = project_status
                    check_project.save()
                    status = 1
            except Exception as e:
                status = 0
            # Return the result as JSON
            return JsonResponse({'status': status})
        else:
            return JsonResponse({'status': 'No project specified'})
    else:
        # Handle other HTTP methods if needed
        return JsonResponse({'error': 'Invalid request method'})


from django.core.mail import send_mail

def leave_daterange(start_date, end_date):
    """Generate all dates between start_date and end_date (inclusive)."""
    for n in range((end_date - start_date).days + 1):
        yield start_date + timedelta(n)

@csrf_exempt
@login_required(login_url='/')
def short_mail(request):
    if request.user.groups.all()[0].name == "admin":

        # Get current week range (Monday to Thursday)
        if request.method == 'POST':

            employee_ids = request.POST.getlist('employees')
            message = request.POST.get('message')

            print(employee_ids, message)
            employee_ids = [int(emp_id) for emp_id in employee_ids]
            today = datetime.now().date()
            start_of_week = today - timedelta(days=today.weekday())  # Monday
            end_of_week = start_of_week + timedelta(days=3)  # Thursday

            print(start_of_week, end_of_week)
            # Get all employees
            employees = employee.objects.filter(status=1, id__in=employee_ids)
            print(employees, 'TEST EMPLOYEE OBJECT')
            for emp in employees:
                try:
                    emp_status = ShortWorkEmail.objects.get(employee_id=emp.id, start_date=start_of_week,
                                                            end_date=end_of_week, status__gt=0)
                    continue
                except Exception as e:
                    print(e, 'ERROR')
                # Get time entries for the employee within the week
                time_entries = timeSheet.objects.filter(
                    employee_id=emp.id,
                    time_entries_start_date__range=(start_of_week, end_of_week)
                ).aggregate(total_seconds=Sum('time_entries_seconds'))

                # Convert total seconds to hours
                hours_worked = (time_entries['total_seconds'] or 0) / 3600

                # # Calculate leave days in the week
                # leave_days = leave.objects.filter(
                #     employee_id=emp.id,
                #     start_date__lte=end_of_week,
                #     end_date__gte=start_of_week
                # ).count()
                # # Adjust minimum required hours
                # minimum_hours = 32 - (leave_days * 8)

                leave_entries = leave.objects.filter(
                    employee_id=emp.id,
                    start_date__lte=end_of_week,
                    end_date__gte=start_of_week
                ).values_list('start_date', 'end_date')

                # Expand leave days to include all days within the leave period
                leave_days = set()
                for start_date1, end_date1 in leave_entries:
                    leave_days.update(leave_daterange(start_date1, end_date1))
                leave_days = {date for date in leave_days if start_of_week <= date <= end_of_week}

                print('EMPLOYEE', emp.first_name)
                print('LEAVE', leave_days)
                # Fetch holidays in the employee's country within the week
                holidays = Holiday.objects.filter(
                    country_id=emp.country_id,  # Assuming employee has a country_id field
                    date__range=(start_of_week, end_of_week)
                ).values_list('date', flat=True)
                print('HOLIDAYS', holidays)
                # Convert to sets for easy comparison
                leave_days = set(leave_days)
                holidays = set(holidays)

                # Count unique leave and holiday days (without double counting overlapping days)
                unique_leave_holiday_days = leave_days | holidays
                print('UNIQUE', unique_leave_holiday_days)
                # Calculate minimum required hours
                minimum_hours = 32 - (len(unique_leave_holiday_days) * 8)
                # Ensure minimum hours are not negative
                minimum_hours = max(minimum_hours, 0)

                # Check if total working hours meet the requirement
                if hours_worked < minimum_hours / 2:
                    # Send short notice email
                    if emp.id:
                        send_short_notice_email(emp, hours_worked, minimum_hours, message)
                        try:
                            total_working_in_sec = time_entries['total_seconds']
                        except Exception as e:
                            total_working_in_sec = 0
                        try:
                            total_minimum_work_in_sec = int(minimum_hours) * 3600
                        except Exception as e:
                            total_minimum_work_in_sec = 0
                        print('ASHOKKK')
                        ShortWorkEmail.objects.update_or_create(employee_id=emp.id, start_date=start_of_week,
                                                                end_date=end_of_week,
                                                                minimum_work=total_minimum_work_in_sec,

                                                                defaults={
                                                                    'status': 1,
                                                                    'total_working': total_working_in_sec,
                                                                })

                print(emp.id, emp.first_name, minimum_hours, hours_worked)
            # return HttpResponse('OK')
        try:
            # search_date = request.GET.get('search_to_date')
            search_date = request.GET.get('from_to_date')
            print(search_date, 'DATE CHECK1')

            if search_date:
                # Split the date range into start and end dates
                date_range = search_date.split(" - ")
                start_date = datetime.strptime(date_range[0], "%m/%d/%Y").date()
                end_date = datetime.strptime(date_range[1], "%m/%d/%Y").date()

                print(start_date, end_date, 'DATE CHECK2')
                today = start_date  # Use the start of the range as the reference date
                history_data = True

                start_of_week = today  # SELECTED START DATE
                end_of_week = end_date  # SELECTED END DATE
                end_of_week_sunday = start_of_week + timedelta(days=6)  # Sunday
            else:
                today = datetime.now().date()
                history_data = False
                start_of_week = today - timedelta(days=today.weekday())  # Monday
                end_of_week = start_of_week + timedelta(days=3)  # Thursday
                end_of_week_sunday = start_of_week + timedelta(days=6)  # Sunday

            # search_date = datetime.strptime(search_date, "%d-%m-%Y")
            # print(search_date, 'DATE CHECK2')
            # today = search_date.date()
            # history_data = True
        except Exception as e:
            today = datetime.now().date()
            history_data = False
            start_of_week = today - timedelta(days=today.weekday())  # Monday
            end_of_week = start_of_week + timedelta(days=3)  # Thursday
            end_of_week_sunday = start_of_week + timedelta(days=6)  # Thursday
        if history_data:
            if datetime.now().date() <= end_of_week_sunday and datetime.now().date() >= start_of_week:
                history_data = False
            else:
                history_data = True

        print(start_of_week, end_of_week,history_data,'history')

        working_days_count = 0

        # Iterate over the date range
        current_date = start_of_week
        while current_date <= end_of_week:
            if current_date.weekday() in (0, 1, 2, 3):  # Monday is 0, Sunday is 6
                working_days_count += 1
            current_date += timedelta(days=1)

        # Get all employees
        employees = employee.objects.filter(status=1)

        short_notice_employee = []
        employee_data = []

        for emp in employees:
            # Get time entries for the employee within the week
            time_entries = timeSheet.objects.filter(
                employee_id=emp.id,
                time_entries_start_date__range=(start_of_week, end_of_week)
            ).aggregate(total_seconds=Sum('time_entries_seconds'))

            # Convert total seconds to hours
            hours_worked = round((time_entries['total_seconds'] or 0) / 3600, 2)

            # Calculate leave days in the week
            # leave_days = leave.objects.filter(
            #     employee_id=emp.id,
            #     start_date__lte=end_of_week,
            #     end_date__gte=start_of_week
            # ).count()

            # Adjust minimum required hours
            # minimum_hours = 32 - (leave_days * 8)

            leave_entries = leave.objects.filter(
                employee_id=emp.id,
                start_date__lte=end_of_week,
                end_date__gte=start_of_week
            ).values_list('start_date', 'end_date')

            # Expand leave days to include all days within the leave period
            leave_days = set()
            for start_date1, end_date1 in leave_entries:
                leave_days.update(leave_daterange(start_date1, end_date1))
            leave_days = {date for date in leave_days if start_of_week <= date <= end_of_week}

            # print('EMPLOYEE', emp.first_name)
            # print('LEAVE', leave_days)
            # Fetch holidays in the employee's country within the week
            holidays = Holiday.objects.filter(
                country_id=emp.country_id,  # Assuming employee has a country_id field
                date__range=(start_of_week, end_of_week)
            ).values_list('date', flat=True)
            # print('HOLIDAYS', holidays)
            # Convert to sets for easy comparison
            leave_days = set(leave_days)
            holidays = set(holidays)

            # Count unique leave and holiday days (without double counting overlapping days)
            unique_leave_holiday_days = leave_days | holidays
            # print('UNIQUE', unique_leave_holiday_days)
            # Calculate minimum required hours
            minimum_hours = (working_days_count * 8) - (len(unique_leave_holiday_days) * 8)
            # Ensure minimum hours are not negative
            minimum_hours = max(minimum_hours, 0)

            try:
                emp_status = ShortWorkEmail.objects.get(employee_id=emp.id, start_date__gte=start_of_week,
                                                        end_date__lte=end_of_week)
                status = emp_status.status
            except Exception as e:
                status = 0
            print(hours_worked, minimum_hours)
            if hours_worked < minimum_hours / 2:
                if status == 0:
                    employee_data.append({'id': emp.id, 'name': f"{emp.first_name} {emp.last_name}", 'status': 1})
                    # employee_data.append([emp.id, f"{emp.first_name} {emp.last_name}", True])
                else:
                    employee_data.append({'id': emp.id, 'name': f"{emp.first_name} {emp.last_name}", 'status': 0})
                short_notice_employee.append({
                    'emp_id': emp.id,
                    'emp_name': f"{emp.first_name} {emp.last_name}",
                    'image_url': emp.image_url,
                    'start_date': start_of_week,
                    'end_date': end_of_week,
                    'hours_worked': hours_worked,
                    'hours_work_in_sec': time_entries.get('total_seconds', 0),
                    'total_hours': minimum_hours,
                    'status': status
                })
            else:
                employee_data.append({'id': emp.id, 'name': f"{emp.first_name} {emp.last_name}", 'status': 0})

        sent_email_user_count = ShortWorkEmail.objects.filter(start_date__gte=start_of_week, end_date__lte=end_of_week,
                                                              status=1).count()
        cancel_email_user_count = ShortWorkEmail.objects.filter(start_date__gte=start_of_week, end_date__lte=end_of_week,
                                                                status=2).count()
        pending_email_user_count = len(short_notice_employee) - sent_email_user_count - cancel_email_user_count

        total_email_user_count = len(short_notice_employee)

        return render(request, 'email.html',
                      {'short_notice_employee': short_notice_employee, 'employee_data': employee_data,
                       'sent_email_user_count': sent_email_user_count,
                       'cancel_email_user_count': cancel_email_user_count,
                       'pending_email_user_count': pending_email_user_count,
                       'total_email_user_count': total_email_user_count, 'history_data': history_data})
    else:
        return redirect("admin-dashboard")



from django.utils.html import strip_tags

def send_short_notice_email(employee, total_hours, minimum_hours, message):
    subject = "Short Notice: Insufficient Working Hours"
  
    html_message = message.format(username=employee.first_name, minimum_hours=minimum_hours, total_hours=total_hours)
    recipient = employee.email
    plain_message = strip_tags(html_message)

    if recipient:
        send_mail(
            subject,
            plain_message,
            "developers@brickwin.com",  # Replace with your HR email
            [recipient],
            html_message=html_message,
            fail_silently=False,

        )
        print(f"Email sent to {employee.first_name} ({recipient})")


@csrf_exempt
def email_status(request):
    if request.method == 'POST':
        try:
            # Get data from the request
            emp_id = request.POST.get('emp_id')
            status = request.POST.get('status')
            minimum_work = request.POST.get('minimum_work')
            # total_working = request.POST.get('total_working')
            start_date1 = request.POST.get('start_date')
            # end_date = request.POST.get('end_date')
            if start_date1:
                start_date1 = datetime.strptime(start_date1, '%b. %d, %Y').strftime('%Y-%m-%d')
                start_date1 = datetime.strptime(start_date1, "%Y-%m-%d").date()
            # if end_date:
            #     end_date = datetime.strptime(end_date, '%b. %d, %Y').strftime('%Y-%m-%d')

            today = datetime.now().date()
            start_date = today - timedelta(days=today.weekday())  # Monday
            end_date = start_date + timedelta(days=3)  # Thursday
            print(start_date1,start_date,type(start_date1),type(start_date))
            if start_date1 != start_date:
                return JsonResponse({'success': False, 'error': 'History Data Can Not Be Changed'})

            time_entries = timeSheet.objects.filter(
                employee_id=emp_id,
                time_entries_start_date__range=(start_date, end_date)
            ).aggregate(total_seconds=Sum('time_entries_seconds'))
            try:
                total_working_in_sec = time_entries['total_seconds']
            except Exception as e:
                total_working_in_sec = 0
            try:
                total_minimum_work_in_sec = int(minimum_work) * 3600
            except Exception as e:
                total_minimum_work_in_sec = 0

            print(emp_id, start_date, minimum_work, total_minimum_work_in_sec)
            # Check if the record exists, update it if found; otherwise, create a new one
            obj, created = ShortWorkEmail.objects.update_or_create(
                employee_id=emp_id,
                minimum_work=total_minimum_work_in_sec,
                start_date=start_date,
                end_date=end_date,
                defaults={
                    'status': status,
                    'total_working': total_working_in_sec,
                }
            )

            # Respond with success
            return JsonResponse({'success': True, 'created': created})
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})
    return JsonResponse({'success': False, 'error': 'Invalid request method'})






def test_notice_email(request):
    subject = "Short Notice: Insufficient Working Hours"
    message = f"""
    Dear Test,

    We noticed that your working hours for this week (Monday to Thursday) are below the required minimum.

    Minimum Required Hours: 
    Your Total Hours: 

    Please ensure that you meet the minimum working hours for compliance.

    Regards,
    HR Team
    """

    recipient = 'ashok.kumar@brickwin.net'

    if recipient:
        send_mail(
            subject,
            message,
            "ashok.kumar@brickwin.net",  # Replace with your HR email
            [recipient],
            fail_silently=False,
        )
        print(f"Email sent to")
    return HttpResponse('OK')


@login_required(login_url='/')
def update_gmail_in_timesheets(request):
    try:
        # Define the start date filter (January 1, 2026)
        start_date_filter = datetime(2026, 1, 1)

        # Get timeSheet entries where is_google=1 and start date is after Jan 1, 2026
        timesheets = timeSheet.objects.filter(is_google=1, time_entries_start_date__gte=start_date_filter)

        updated_count = 0

        for entry in timesheets:
            try:
                # Fetch the corresponding employee
                emp_ob = employee.objects.get(id=entry.employee_id)

                # Update the gmail field with the correct email
                if entry.gmail != emp_ob.auth_gmail:
                    entry.gmail = emp_ob.auth_gmail
                    entry.save()
                    updated_count += 1

            except employee.DoesNotExist:
                continue  # Skip if employee is not found

        return JsonResponse({'status': 'success', 'updated_entries': updated_count})
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': str(e)})



def get_event_projects(request):
    client_id = request.GET.get('client_id')
    projects = project.objects.filter(client_id=client_id).values('id', 'project_name')
    print(projects,'TEST HIT')
    return JsonResponse(list(projects), safe=False)

@csrf_exempt
@login_required(login_url='/')
def add_client_contract_work(request):
    import csv
    from django.shortcuts import render
    # return HttpResponse('pp')
    if request.method == 'POST':

        client_id = request.POST.get('client_id')
        cost = request.POST.get('monthly_cost')
        current_month = int(request.POST.get('month'))
        current_year = int(request.POST.get('year'))
        import calendar

        if request.POST.get('add_new_client') == 'true':
            client_name = request.POST.get('client_name','').strip()
            company_name = request.POST.get('company_name','').strip()
            email = request.POST.get('email','').strip()
            address = request.POST.get('address','').strip()
            gender = request.POST.get('gender','').title().strip()
            dob = request.POST.get('dob','').strip()
            phone = request.POST.get('phone','').strip()
            designation = request.POST.get('designation','').strip()
            company_size = request.POST.get('company_size','').strip()
            country = request.POST.get('country','').strip()
            industry = request.POST.get('industry','').strip()
            level = request.POST.get('level','').strip()
            location = request.POST.get('location','').strip()
            region = request.POST.get('region','').strip()

            if dob:
                try:
                    dob = datetime.strptime(dob, '%Y-%m-%d').date()
                except ValueError:
                    return HttpResponse("Invalid date format. Please use YYYY-MM-DD.")
            else:
                dob = None

            if not client_name or not company_name:
                return JsonResponse({"error": "Client name and Company are required when adding a new client."}, status=400)
            
            existing_client = client.objects.filter(client_name=client_name, company_name=company_name).first()

            if existing_client:
                return JsonResponse({"error": "This client name already exists."}, status=400)
            else:
                toggl_client_name = f"{company_name}, {client_name}"

                new_client = client.objects.create(
                    client_name=client_name,
                    company_name=company_name,
                    toggl_client_name=toggl_client_name,
                    gender=gender,
                    company_size=company_size,
                    country=country,
                    industry=industry,
                    level=level,
                    location=location,
                    region=region,
                    email=email,
                    address=address,
                    date_of_birth=dob,
                    phone=phone,
                    designation=designation,
                    status=1
                )

                client_id = new_client.id
                new_client.toggl_client_id = client_id
                new_client.save()

        elif not client_id:
            return JsonResponse({"error": "Client must be selected."}, status=400)
        else:
            if not client.objects.filter(id=client_id).exists():
                return JsonResponse({"error": "Selected client does not exist."}, status=400)        
        try:
            cost = float(cost)
            if cost <= 0:
                return JsonResponse({"error": "Amount must be a positive value."}, status=400)
        except ValueError:
            return JsonResponse({"error": "Invalid amount value."}, status=400)
        
        buddies = request.POST.getlist('buddy')
        advisors = request.POST.getlist('advisor')
        consultants = request.POST.getlist('consultant[]')
        times = request.POST.getlist('consultant_time[]')

        working_input = {}
        working_roles = {}

        buddies = request.POST.getlist('buddy')
        if buddies:
            for buddy in buddies:
                working_input[buddy] = 0
                working_roles[buddy] = "B"

        if advisors:
            for advisor in advisors:
                working_input[advisor] = 0
                working_roles[advisor] = "A"

        consultants = request.POST.getlist('consultant[]')
        times = request.POST.getlist('consultant_time[]')
        # if consultants and times:
        #     for consultant, time in zip(consultants, times):
        #         working_input[consultant] = time
        #         working_roles[consultant] = "C"

        if consultants and times:
            for consultant, time in zip(consultants, times):
                if consultant:
                    working_input[consultant] = time
                    working_roles[consultant] = "C"

        no_of_people_on_account = len(working_input)

        total_working_hours = sum(float(value) for value in working_input.values())

        print('working_input ',working_input)
        print('working_roles ',working_roles)

        json_working_input = json.dumps(working_input)
        json_working_roles = json.dumps(working_roles)
        
        if client_id:
            try:
                try:
                    start_date = date(current_year, current_month, 1)
                    import calendar
                    input_dt = datetime(current_year, current_month, 13)
                    res = calendar.monthrange(input_dt.year, input_dt.month)
                    last_day = res[1]

                    end_date = date(current_year, current_month, last_day)

                    client_details = Client_contract_work.objects.filter(
                        client_id=client_id,
                        date__range=(start_date, end_date)
                    ).first()
                except Exception as e:
                    client_details = ''

                if json_working_input and json_working_roles:
                    if client_details:
                        client_details.working_input = json_working_input
                        client_details.total_working_hours = total_working_hours
                        client_details.no_of_people_on_account = no_of_people_on_account
                        client_details.working_role = json_working_roles
                        client_details.cost = cost

                        client_details.save()
                    else:
                        new_client_details = Client_contract_work(
                            client_id=client_id,
                            working_input = json_working_input,
                            total_working_hours = total_working_hours,
                            no_of_people_on_account = no_of_people_on_account,
                            working_role = json_working_roles,
                            cost=cost,
                            date=end_date,
                            status=1
                        )
                        new_client_details.save()

                        for employee_id, role in working_roles.items():
                            if not Client_contract_employee.objects.filter(employee_id=employee_id,date__range=(start_date, end_date)).exists():
                                new_employee_details = Client_contract_employee(
                                    employee_id=employee_id,
                                    support=1 if role == 'B' else 0,
                                    advisor=1 if role == 'A' else 0,
                                    account_manager=1 if role == 'C' else 0,
                                    total=1,
                                    date=end_date
                                )
                                new_employee_details.save()
                            else:
                                contract_employee_detail = Client_contract_employee.objects.filter(employee_id=employee_id,date__range=(start_date, end_date)).first()
                                if contract_employee_detail:
                                    contract_employee_detail.total += 1

                                    if role == "A":
                                        contract_employee_detail.advisor += 1
                                    elif role == "B":
                                        contract_employee_detail.support += 1  # Increment buddy count
                                    elif role == "C":  # If role is Consultant
                                        contract_employee_detail.account_manager += 1  # Increment consultant count
                                    else:
                                        pass

                                    contract_employee_detail.save()

            except Exception as e:
                print(e)

            for employee_id, role in working_roles.items():
                if not Client_contract_employee.objects.filter(employee_id=employee_id,date__range=(start_date, end_date)).exists():
                    new_employee_details = Client_contract_employee(
                        employee_id=employee_id,
                        support=1 if role == 'B' else 0,
                        advisor=1 if role == 'A' else 0,
                        account_manager=1 if role == 'C' else 0,
                        total=1,
                        date=end_date
                    )
                    new_employee_details.save()
                else:
                    contract_employee_detail = Client_contract_employee.objects.filter(employee_id=employee_id,date__range=(start_date, end_date)).first()
                    if contract_employee_detail:
                        contract_employee_detail.total += 1

                        if role == "A":
                            contract_employee_detail.advisor += 1
                        elif role == "B":
                            contract_employee_detail.support += 1  # Increment buddy count
                        elif role == "C":  # If role is Consultant
                            contract_employee_detail.account_manager += 1  # Increment consultant count
                        else:
                            pass

                        contract_employee_detail.save()

        return redirect("excel_sheet")


@csrf_exempt
@login_required(login_url='/')
def delete_client_contract_work(request,contract_work_id):
    from django.shortcuts import get_object_or_404
    # return HttpResponse(contract_work_id);

    if not contract_work_id:
        return JsonResponse({"error": "Contract work ID is required."}, status=400)

    try:
        contract_work = get_object_or_404(Client_contract_work, id=contract_work_id)
        client_id = contract_work.client_id

        start_date = contract_work.date.replace(day=1)
        import calendar
        input_dt = contract_work.date
        res = calendar.monthrange(input_dt.year, input_dt.month)
        last_day = res[1]
        end_date = date(input_dt.year, input_dt.month, last_day)

        contract_work.delete()

        for employee_id, role in json.loads(contract_work.working_role).items():
            contract_employee = Client_contract_employee.objects.filter(
                employee_id=employee_id, date__range=(start_date, end_date)
            ).first()

            if contract_employee:
                if role == "B":
                    contract_employee.support -= 1
                elif role == "A":
                    contract_employee.advisor -= 1
                elif role == "C":
                    contract_employee.account_manager -= 1

                contract_employee.total -= 1

                contract_employee.save()

        return JsonResponse({"success": "Client contract work deleted and employee counts updated."}, status=200)

    except Exception as e:
        print(str(e))
        return JsonResponse({"error": "An error occurred while deleting the contract work."}, status=500)

def check_contracted_client(request):
    month = request.GET.get('month', '').strip()
    year = request.GET.get('year', '').strip()
    client_id = request.GET.get('client_id', '').strip()
    # exists =None
    if client_id:
        exists = Client_contract_work.objects.filter(
            client_id=client_id,
            date__year=year,
            date__month=month
        ).exists()
        
    return JsonResponse({'exists': exists})





@csrf_exempt
def save_timezone(request):
    if request.method == "GET":
        employee_id = request.session.get('user_id')
        employee_ob = employee.objects.get(id=int(employee_id))

        if employee_ob.token:
            google_credentials = json.loads(employee_ob.token)
            creds = Credentials.from_authorized_user_info(google_credentials, SCOPES)
            service = build('calendar', 'v3', credentials=creds)
            calendar_info = service.calendars().get(calendarId=employee_ob.auth_gmail).execute()

            employee_ob.timezone = calendar_info.get("timeZone")
            employee_ob.manual_timezone = calendar_info.get("timeZone")
            employee_ob.save()

            return JsonResponse({"status": True, "timezone": employee_ob.timezone})
        return JsonResponse({"status": False, "message": "No Google token found."})

    elif request.method == "POST":
        try:
            data = json.loads(request.body)
            employee_id = request.session.get('user_id')
            employee_ob = employee.objects.get(id=int(employee_id))
            employee_ob.manual_timezone = data.get("timezone")
            employee_ob.timezone = None
            employee_ob.save()
            return JsonResponse({"status": True, "message": "Timezone updated successfully"})
        except Exception as e:
            return JsonResponse({"status": False, "message": str(e)})

    return JsonResponse({"status": False, "message": "Invalid request"})


def get_default_timezone(request):
    try:
        employee_id = request.session.get('user_id')
        employee_ob = employee.objects.get(id=employee_id)

        employee_country = Country.objects.get(id=employee_ob.country_id)
        country_code = employee_country.code

        default_timezones = {
            'US': 'America/New_York',
            'SA': 'Africa/Johannesburg',
            'UK': 'Europe/London',
            'PH': 'Asia/Manila'
        }
        country_city = default_timezones.get(country_code, 'America/New_York')

        return JsonResponse({"status": True, "timezone": country_city})
    except Exception as e:
        return JsonResponse({"status": False, "message": str(e)})


@csrf_exempt
def upload_image(request):
    if request.method == 'POST' and request.FILES.get('image'):
        image = request.FILES['image']
        filename = image.name
        save_path = os.path.join(settings.STATICFILES_DIRS[0],'img', 'client', filename)

        # Save the file
        with open(save_path, 'wb+') as destination:
            for chunk in image.chunks():
                destination.write(chunk)
        image_url = f"/static/img/client/{filename}"
        # return redirect('upload_success')
        return render(request, 'upload_image.html',{'image_url': image_url})
    return render(request, 'upload_image.html')

@csrf_exempt
@login_required(login_url='/')
def add_client(request):
    from django.shortcuts import get_object_or_404
    if request.method == 'POST':
        import calendar

        client_id = request.POST.get('client_id', '').strip()
        client_name = request.POST.get('client_name','').strip()
        company_name = request.POST.get('company_name','').strip()
        email = request.POST.get('email','').strip()
        address = request.POST.get('address','').strip()
        gender = request.POST.get('gender','').title().strip()
        dob = request.POST.get('dob','').strip()
        phone = request.POST.get('phone','').strip()
        designation = request.POST.get('designation','').strip()
        company_size = request.POST.get('company_size','').strip()
        country = request.POST.get('country','').strip()
        industry = request.POST.get('industry','').strip()
        level = request.POST.get('level','').strip()
        location = request.POST.get('location','').strip()
        region = request.POST.get('region','').strip()
        cost = request.POST.get('monthly_cost')
        current_month = int(request.POST.get('month'))
        current_year = int(request.POST.get('year'))

        if dob:
            try:
                dob = datetime.strptime(dob, '%Y-%m-%d').date()
            except ValueError:
                return HttpResponse("Invalid date format. Please use YYYY-MM-DD.")
        else:
            dob = None

        if not client_name or not company_name:
            return JsonResponse({"error": "Client name and Company are required when adding a new client."}, status=400)
        
        if client_id:
            existing_client = client.objects.filter(client_name=client_name, company_name=company_name).exclude(id=client_id).first()
            if existing_client:
                return JsonResponse({"error": "This client already exists."}, status=400)
            existing_client = get_object_or_404(client, id=client_id)
        else:
            existing_client = client.objects.filter(client_name=client_name, company_name=company_name).first()
            if existing_client:
                return JsonResponse({"error": "This client already exists."}, status=400)

        try:
            cost = float(cost)
            if cost <= 0:
                return JsonResponse({"error": "Amount must be a positive value."}, status=400)
        except ValueError:
            return JsonResponse({"error": "Invalid amount value."}, status=400)
        uploaded_file = request.FILES.get('client_image')
        print("Vinod 4 March")
        print(uploaded_file)
        # return HttpResponse(uploaded_file)
        if uploaded_file:
            base_filename = os.path.basename(uploaded_file.name)

            base_filename = base_filename.replace('/', '_')

            filename = f'{client_name}_{base_filename}'
            filename = filename.replace('/', '_')

            destination_path = os.path.join(settings.STATICFILES_DIRS[0], 'img', 'client', filename)

            try:
                with open(destination_path, 'wb+') as destination:
                    for chunk in uploaded_file.chunks():
                        destination.write(chunk)
            except Exception as e:
                print(e)

        if uploaded_file:
            uploaded_file_path = os.path.join(settings.STATIC_URL, 'assets', 'img', 'client', filename)
        else:
            uploaded_file_path =''

        toggl_client_name = f"{company_name}, {client_name}"
        if existing_client:
            if email:
                if client.objects.filter(email=email).exclude(id=existing_client.id).exists():
                    return JsonResponse({"error": f"Client with email {email} already exists."}, status=400)
            
            existing_client.client_name = client_name
            existing_client.company_name = company_name
            existing_client.email = email
            existing_client.address = address
            existing_client.gender = gender
            existing_client.date_of_birth = dob
            existing_client.phone = phone
            existing_client.designation = designation
            existing_client.company_size = company_size
            existing_client.country = country
            existing_client.industry = industry
            existing_client.level = level
            existing_client.location = location
            existing_client.region = region
            existing_client.image_url = uploaded_file_path if uploaded_file else existing_client.image_url  # Keep old image if not uploading a new one
            existing_client.save()

            client_id = existing_client.id
        else:
            if email:
                if client.objects.filter(email=email).exists():
                    return JsonResponse({"error": f"Client with email {email} already exists."}, status=400)
            
            new_client = client.objects.create(
                client_name=client_name,
                company_name=company_name,
                toggl_client_name=toggl_client_name,
                gender=gender,
                company_size=company_size,
                country=country,
                industry=industry,
                level=level,
                location=location,
                region=region,
                email=email,
                image_url=uploaded_file_path,
                address=address,
                date_of_birth=dob,
                phone=phone,
                designation=designation,
                status=1
            )

            client_id = new_client.id
            new_client.toggl_client_id = client_id
            new_client.save()
            
        
        buddies = request.POST.getlist('buddy')
        advisors = request.POST.getlist('advisor')
        consultants = request.POST.getlist('consultant[]')
        times = request.POST.getlist('consultant_time[]')

        working_input = {}
        working_roles = {}

        buddies = request.POST.getlist('buddy')
        if buddies:
            for buddy in buddies:
                working_input[buddy] = 0
                working_roles[buddy] = "B"

        if advisors:
            for advisor in advisors:
                working_input[advisor] = 0
                working_roles[advisor] = "A"

        consultants = request.POST.getlist('consultant[]')
        times = request.POST.getlist('consultant_time[]')

        if consultants and times:
            for consultant, time in zip(consultants, times):
                if consultant:
                    working_input[consultant] = time
                    working_roles[consultant] = "C"

        no_of_people_on_account = len(working_input)

        total_working_hours = sum(float(value) for value in working_input.values())

        print('working_input ',working_input)
        print('working_roles ',working_roles)

        json_working_input = json.dumps(working_input)
        json_working_roles = json.dumps(working_roles)
        
        if client_id:
            try:
                try:
                    start_date = date(current_year, current_month, 1)
                    import calendar
                    input_dt = datetime(current_year, current_month, 13)
                    res = calendar.monthrange(input_dt.year, input_dt.month)
                    last_day = res[1]

                    end_date = date(current_year, current_month, last_day)

                    client_details = Client_contract_work.objects.filter(
                        client_id=client_id,
                        date__range=(start_date, end_date)
                    ).first()
                except Exception as e:
                    client_details = ''

                if json_working_input and json_working_roles:
                    if client_details:
                        client_details.working_input = json_working_input
                        client_details.total_working_hours = total_working_hours
                        client_details.no_of_people_on_account = no_of_people_on_account
                        client_details.working_role = json_working_roles
                        client_details.cost = cost

                        client_details.save()
                    else:
                        new_client_details = Client_contract_work(
                            client_id=client_id,
                            working_input = json_working_input,
                            total_working_hours = total_working_hours,
                            no_of_people_on_account = no_of_people_on_account,
                            working_role = json_working_roles,
                            cost=cost,
                            date=end_date,
                            status=1
                        )
                        new_client_details.save()

                        for employee_id, role in working_roles.items():
                            if not Client_contract_employee.objects.filter(employee_id=employee_id,date__range=(start_date, end_date)).exists():
                                new_employee_details = Client_contract_employee(
                                    employee_id=employee_id,
                                    support=1 if role == 'B' else 0,
                                    advisor=1 if role == 'A' else 0,
                                    account_manager=1 if role == 'C' else 0,
                                    total=1,
                                    date=end_date
                                )
                                new_employee_details.save()
                            else:
                                contract_employee_detail = Client_contract_employee.objects.filter(employee_id=employee_id,date__range=(start_date, end_date)).first()
                                if contract_employee_detail:
                                    contract_employee_detail.total += 1

                                    if role == "A":
                                        contract_employee_detail.advisor += 1
                                    elif role == "B":
                                        contract_employee_detail.support += 1  # Increment buddy count
                                    elif role == "C":  # If role is Consultant
                                        contract_employee_detail.account_manager += 1  # Increment consultant count
                                    else:
                                        pass

                                    contract_employee_detail.save()

            except Exception as e:
                print(e)

            # for employee_id, role in working_roles.items():
            #     if not Client_contract_employee.objects.filter(employee_id=employee_id,date__range=(start_date, end_date)).exists():
            #         new_employee_details = Client_contract_employee(
            #             employee_id=employee_id,
            #             support=1 if role == 'B' else 0,
            #             advisor=1 if role == 'A' else 0,
            #             account_manager=1 if role == 'C' else 0,
            #             total=1,
            #             date=end_date
            #         )
            #         new_employee_details.save()
            #     else:
            #         contract_employee_detail = Client_contract_employee.objects.filter(employee_id=employee_id,date__range=(start_date, end_date)).first()
            #         if contract_employee_detail:
            #             contract_employee_detail.total += 1

            #             if role == "A":
            #                 contract_employee_detail.advisor += 1
            #             elif role == "B":
            #                 contract_employee_detail.support += 1  # Increment buddy count
            #             elif role == "C":  # If role is Consultant
            #                 contract_employee_detail.account_manager += 1  # Increment consultant count
            #             else:
            #                 pass

            #             contract_employee_detail.save()

            if not working_input:
                admins_and_managers = [
                    {"username": "Vinod", "email": "vinod.sharma@brickwin.net"},
                    {"username": "Sonal", "email": "sonal.agrawal@brickwin.net"},
                ]

                subject = f"Missing Assignments for Client {client_name} {company_name}"

                for user in admins_and_managers:
                    username = user['username']
                    recipient_email = user['email']

                    message = f"""
                    Hi {username},<br/><br/>

                    We have noticed that the Client <b>{client_name} {company_name}</b> does not have a Buddy, Advisor, and Consultant assigned. 
                    Kindly ensure that the data is updated accordingly at your earliest convenience.
                    <br/><br/>
                    Regards,<br/>
                    DEC Application
                    """

                    # Using send_mail with html_message argument
                    send_mail(
                        subject,
                        message,  # plain text message, if you need to send a text-only version as fallback
                        "developers@brickwin.com",
                        [recipient_email],
                        fail_silently=False,
                        html_message=message  # HTML content
                    )

        return redirect("client-profile",client_id)

@csrf_exempt
@login_required(login_url='/')
def get_client_details(request, client_id):
    try:
        client_obj = client.objects.get(id=client_id)
        client_data = {
            "client_name": client_obj.client_name,
            "company_name": client_obj.company_name,
            "email": client_obj.email,
            "address": client_obj.address,
            "gender": client_obj.gender,
            "dob": client_obj.date_of_birth.strftime('%Y-%m-%d') if client_obj.date_of_birth else '',
            "phone": client_obj.phone,
            "designation": client_obj.designation,
            "company_size": client_obj.company_size,
            "country": client_obj.country,
            "industry": client_obj.industry,
            "level": client_obj.level,
            "location": client_obj.location,
            "region": client_obj.region,
            "image_url": client_obj.image_url,
        }
        return JsonResponse(client_data)
    except client.DoesNotExist:
        return JsonResponse({"error": "Client not found"}, status=404)

@csrf_exempt
@login_required(login_url='/')
def delete_client(request):
    if request.method == 'GET':
        client_id = request.GET.get('client_id')
        try:
            client_to_delete = client.objects.get(id=client_id)
            client_to_delete.delete()
            status = 1
            print("Client deleted successfully.")
        except project.DoesNotExist:
            status = 0
            print("Client with the given ID does not exist.")

        return JsonResponse({'status': status})

@csrf_exempt
@login_required(login_url='/')
def update_client_with_contracted(request):
    if request.method == "POST":
        client_id = request.POST.get('client_id', '').strip()
        email = request.POST.get('email','').strip()
        address = request.POST.get('address','').strip()
        gender = request.POST.get('gender','').title().strip()
        dob = request.POST.get('dob','').strip()
        phone = request.POST.get('phone','').strip()
        designation = request.POST.get('designation','').strip()
        company_size = request.POST.get('company_size','').strip()
        country = request.POST.get('country','').strip()
        industry = request.POST.get('industry','').strip()
        level = request.POST.get('level','').strip()
        location = request.POST.get('location','').strip()
        region = request.POST.get('region','').strip()
        cost = request.POST.get('monthly_cost')
        current_month = int(request.POST.get('month'))
        current_year = int(request.POST.get('year'))

        if dob:
            try:
                dob = datetime.strptime(dob, '%Y-%m-%d').date()
            except ValueError:
                return HttpResponse("Invalid date format. Please use YYYY-MM-DD.")
        else:
            dob = None

        
        if client_id:
            existing_client = get_object_or_404(client, id=client_id)
        else:
            existing_client =''

        try:
            cost = float(cost)
            if cost <= 0:
                return JsonResponse({"error": "Amount must be a positive value."}, status=400)
        except ValueError:
            return JsonResponse({"error": "Invalid amount value."}, status=400)
        uploaded_file = request.FILES.get('client_image')
        client_name = existing_client.client_name
        company_name = existing_client.company_name
        if uploaded_file:
            base_filename = os.path.basename(uploaded_file.name)

            base_filename = base_filename.replace('/', '_')

            filename = f'{client_name}_{base_filename}'
            filename = filename.replace('/', '_')

            destination_path = os.path.join(settings.STATICFILES_DIRS[0], 'img', 'client', filename)

            try:
                with open(destination_path, 'wb+') as destination:
                    for chunk in uploaded_file.chunks():
                        destination.write(chunk)
            except Exception as e:
                print(e)

        if uploaded_file:
            uploaded_file_path = os.path.join(settings.STATIC_URL, 'assets', 'img', 'client', filename)
        else:
            uploaded_file_path =''

        if existing_client:
            if email:
                if client.objects.filter(email=email).exclude(id=existing_client.id).exists():
                    return JsonResponse({"error": f"Client with email {email} already exists."}, status=400)
            
            existing_client.email = email
            existing_client.address = address
            existing_client.gender = gender
            existing_client.date_of_birth = dob
            existing_client.phone = phone
            existing_client.designation = designation
            existing_client.company_size = company_size
            existing_client.country = country
            existing_client.industry = industry
            existing_client.level = level
            existing_client.location = location
            existing_client.region = region
            existing_client.image_url = uploaded_file_path if uploaded_file else existing_client.image_url  # Keep old image if not uploading a new one
            existing_client.save()

            client_id = existing_client.id
            print('existing_client : ',existing_client)
            print('existing_client : ',client_id)
            
        
            buddies = request.POST.getlist('buddy')
            advisors = request.POST.getlist('advisor')
            consultants = request.POST.getlist('consultant[]')
            times = request.POST.getlist('consultant_time[]')

            working_input = {}
            working_roles = {}

            buddies = request.POST.getlist('buddy')
            if buddies:
                for buddy in buddies:
                    working_input[buddy] = 0
                    working_roles[buddy] = "B"

            if advisors:
                for advisor in advisors:
                    working_input[advisor] = 0
                    working_roles[advisor] = "A"

            consultants = request.POST.getlist('consultant[]')
            times = request.POST.getlist('consultant_time[]')

            if consultants and times:
                for consultant, time in zip(consultants, times):
                    if consultant:
                        working_input[consultant] = time
                        working_roles[consultant] = "C"

            no_of_people_on_account = len(working_input)

            total_working_hours = sum(float(value) for value in working_input.values())

            print('working_input ',working_input)
            print('working_roles ',working_roles)

            json_working_input = json.dumps(working_input)
            json_working_roles = json.dumps(working_roles)

            start_date = date(current_year, current_month, 1)
            last_day = calendar.monthrange(current_year, current_month)[1]
            end_date = date(current_year, current_month, last_day)
            print('start_date ',start_date)
            print('end_date ',end_date)
            # return HttpResponse(working_roles)

            client_contract = Client_contract_work.objects.filter(
                client_id=client_id, date__range=(start_date, end_date)
            ).first()

            print('client_contract ',client_contract)
            if client_contract:
                previous_employee_role = json.loads(client_contract.working_role)
                client_contract.working_input = json_working_input
                client_contract.total_working_hours = total_working_hours
                client_contract.no_of_people_on_account = no_of_people_on_account
                client_contract.working_role = json_working_roles
                client_contract.cost = cost
                client_contract.save()
            else:
                previous_employee_role = {}
                new_client_details = Client_contract_work(
                    client_id=client_id,
                    working_input = json_working_input,
                    total_working_hours = total_working_hours,
                    no_of_people_on_account = no_of_people_on_account,
                    working_role = json_working_roles,
                    cost=cost,
                    date=end_date,
                    status=1
                )
                new_client_details.save()

            for employee_id, previous_role in previous_employee_role.items():
                contract_employee = Client_contract_employee.objects.filter(
                    employee_id=employee_id, date__range=(start_date, end_date)
                ).first()
                print(employee_id)
                print('contract_employee ',contract_employee)
                # return HttpResponse('pp')
                if previous_role:
                    if previous_role == "A":
                        contract_employee.advisor -= 1
                    elif previous_role == "B":
                        contract_employee.support -= 1
                    elif previous_role == "C":
                        contract_employee.account_manager -= 1

                    contract_employee.total -= 1

                    contract_employee.save()

            # return HttpResponse('pp')
            print('working_roles ',working_roles)
            for employee_id, new_role in working_roles.items():
                contract_employee = Client_contract_employee.objects.filter(
                    employee_id=employee_id, date__range=(start_date, end_date)
                ).first()

                if contract_employee:

                    if new_role == "A":
                        contract_employee.advisor += 1
                    elif new_role == "B":
                        contract_employee.support += 1
                    elif new_role == "C":
                        contract_employee.account_manager += 1

                    contract_employee.total += 1

                    contract_employee.save()

                else:
                    Client_contract_employee.objects.create(
                        employee_id=employee_id,
                        support=1 if new_role == "B" else 0,
                        advisor=1 if new_role == "A" else 0,
                        account_manager=1 if new_role == "C" else 0,
                        total=1,
                        date=end_date
                    )

            if not working_input:
                admins_and_managers = [
                    {"username": "Vinod", "email": "vinod.sharma@brickwin.net"},
                    {"username": "Sonal", "email": "sonal.agrawal@brickwin.net"},
                ]

                subject = f"Missing Assignments for Client {client_name} {company_name}"

                for user in admins_and_managers:
                    username = user['username']
                    recipient_email = user['email']

                    message = f"""
                    Hi {username},<br/><br/>

                    We have noticed that the Client <b>{client_name} {company_name}</b> does not have a Buddy, Advisor, and Consultant assigned. 
                    Kindly ensure that the data is updated accordingly at your earliest convenience.
                    <br/><br/>
                    Regards,<br/>
                    DEC Application
                    """

                    # Using send_mail with html_message argument
                    send_mail(
                        subject,
                        message,  # plain text message, if you need to send a text-only version as fallback
                        "developers@brickwin.com",
                        [recipient_email],
                        fail_silently=False,
                        html_message=message  # HTML content
                    )

            messages.success(request, 'Client updated successfully!')
        else:
            messages.error(request, 'Error updating client.')
        return redirect("client-profile",client_id)


        
    return JsonResponse({"error": "Invalid request method"}, status=400)

   
        

@csrf_exempt
@login_required(login_url='/')
def upload_document(request):
    import mimetypes
    if request.method == 'POST':
        uploaded_file = request.FILES.get('uploaded_file')
        entity_type = request.POST.get('entity_type')
        employee_id = request.POST.get('employee_id')
        client_id = request.POST.get('client_id')
        description = request.POST.get('description')
        category_id = request.POST.get('file_category', None)
        try:
            category_ob = File_Category.objects.get(id=category_id)
            category_name = category_ob.name
        except Exception as e:
            category_id = None
            pass
        if not employee_id and not client_id:
            return JsonResponse({"error": "Employee Id or Client Id are required when uploading document."}, status=400)

        if uploaded_file:
            base_filename = os.path.basename(uploaded_file.name)
            base_filename = base_filename.replace('/', '_')
            current_time = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')

            _, file_extension = os.path.splitext(base_filename)
            file_extension = file_extension.lstrip('.').lower()

            mime_type, encoding = mimetypes.guess_type(uploaded_file.name)
            if mime_type:
                if mime_type.startswith('image'):
                    file_type = 'image'
                elif mime_type.startswith('application/pdf'):
                    file_type = 'pdf'
                elif mime_type.startswith('application/msword') or mime_type.startswith(
                        'application/vnd.openxmlformats-officedocument.wordprocessingml.document'):
                    file_type = 'docx'
                elif mime_type.startswith('application/vnd.ms-powerpoint') or mime_type.startswith(
                        'application/vnd.openxmlformats-officedocument.presentationml.presentation'):
                    file_type = 'pptx'
                else:
                    file_type = 'other'
            else:
                file_type = 'other'

            new_filename = f'{current_time}_{base_filename}'
            new_filename = new_filename.replace('/', '_')

            # Define the destination path
            # destination_path = os.path.join(settings.STATICFILES_DIRS[0], 'img', 'client', filename)
            if category_id:
                destination_dir = os.path.join(settings.STATICFILES_DIRS[0], 'img', 'client', 'documents',
                                               f'{category_name}')
            else:
                destination_dir = os.path.join(settings.STATICFILES_DIRS[0], 'img', 'client', 'documents')

            if not os.path.exists(destination_dir):
                try:
                    os.makedirs(destination_dir)
                except Exception as e:
                    print(f"Error creating directory: {e}")
                    return

            destination_path = os.path.join(destination_dir, new_filename)

            print("Vinod 17 March", destination_path, destination_dir)
            print(file_type)
            # return HttpResponse(destination_path)

            try:
                with open(destination_path, 'wb+') as destination:
                    for chunk in uploaded_file.chunks():
                        destination.write(chunk)
            except Exception as e:
                print(e)

        if uploaded_file:
            if category_id:
                uploaded_file_path = os.path.join(settings.STATIC_URL, 'assets', 'img', 'client', 'documents',
                                                  f'{category_name}', new_filename)
            else:
                uploaded_file_path = os.path.join(settings.STATIC_URL, 'assets', 'img', 'client', 'documents',
                                                  new_filename)
            # uploaded_file_path = os.path.join('uploaded_files', new_filename)

            gallery = FileManager(
                entity_type=entity_type,
                employee_id=employee_id,
                client_id=client_id,
                category_id=category_id,
                file=uploaded_file_path,
                description=description,
                file_type=file_extension,
                uploaded_by=request.user.id
            )
            gallery.save()
        else:
            uploaded_file_path = ''

        messages.success(request, "Files uploaded and saved successfully.")

        if (entity_type == 'employee'):
            return redirect("profile", employee_id)
        else:
            return redirect("client-profile", client_id)


@csrf_exempt
@login_required(login_url='/')
def create_category(request):
    if request.method == 'POST':
        entity_type = request.POST.get('entity_type')
        employee_id = request.POST.get('employee_id')
        client_id = request.POST.get('client_id')
        client_id = request.POST.get('client_id')
        created_category = request.POST.get('created_category')

        if request.POST.get('add_new_category') == 'true':
            file_name = request.POST.get('file_name')
        else:
            file_category = File_Category.objects.filter(id=created_category).first()
            file_name = file_category.name

        if file_name:
            File_Category.objects.create(name=file_name,entity_type=entity_type,employee_id=employee_id,client_id=client_id)
            messages.success(request, 'Category created successfully!')
        else:
            messages.error(request, 'Error in creating category.')
    else:
        return JsonResponse({"error": "Action not allowed."}, status=500)

    if entity_type == 'employee':
        return redirect("profile", employee_id)
    else:
        return redirect("client-profile", client_id)


@csrf_exempt
@login_required(login_url='/')
def delete_document(request, document_id):
    try:
        document = FileManager.objects.get(pk=document_id)
        file_url = document.file.url
        import urllib.parse
        # file_path = os.path.join(settings.STATICFILES_DIRS[0], file_url)
        # Decode the URL to get the actual file name
        decoded_file_url = urllib.parse.unquote(file_url)
        print(decoded_file_url)
        relative_path = decoded_file_url.replace('/static/assets/', '', 1)

        # Construct the full absolute file system path
        file_path = os.path.join(settings.STATICFILES_DIRS[0], relative_path)

        try:
            os.remove(file_path)
        except OSError as e:
            print(e, 'PATH ERROR2')
            pass

        document.delete()

        if document.entity_type == 'employee':
            return redirect("profile", document.employee_id)
        else:
            return redirect("client-profile", document.client_id)


    except Exception as e:
        print(e)
        pass
        # logger.error(f"Failed to delete document: {type(e).__name__}, {str(e)}")
        return JsonResponse({"error": f"Failed to delete document.{e}"}, status=500)


import urllib.parse

@csrf_exempt
@login_required(login_url='/')
def rename_document(request, document_id):
    if request.method == "POST":
        # try:
        data = json.loads(request.body)
        new_name = data.get("new_name").strip()  # Remove leading/trailing spaces

        if not new_name:
            return JsonResponse({"error": "Invalid file name."}, status=400)

        document = FileManager.objects.get(pk=document_id)
        file_url = document.file.url  # Get file URL from database

        # Decode URL in case of special characters
        decoded_file_url = urllib.parse.unquote(file_url)
        print("Decoded file URL:", decoded_file_url)

        # Extract the directory and old file name
        file_dir = os.path.dirname(decoded_file_url)
        old_file_name = os.path.basename(decoded_file_url)
        old_file_without_name = "_".join(old_file_name.split("_")[:2]) + "_"
        # Extract the file extension (e.g., .jpg, .pdf)
        file_extension = os.path.splitext(old_file_name)[1]

        new_name_without_extension = os.path.splitext(new_name)[0]

        print(old_file_without_name, new_name, 'CHECK NEW NAME')
        # Generate new file name with the same extension
        new_file_name = f"{old_file_without_name}{new_name_without_extension}.{document.file_type}"

        # Construct old and new file paths
        old_file_path = os.path.join(settings.BASE_DIR, "dec", file_dir.strip('/'), old_file_name)
        new_file_path = os.path.join(settings.BASE_DIR, "dec", file_dir.strip('/'), new_file_name)

        print(f"Old File Path: {old_file_path}")
        print(f"New File Path: {new_file_path}")

        # Rename the actual file
        os.rename(old_file_path, new_file_path)

        # Update database entry with the new file name
        document.file.name = os.path.join(file_dir, new_file_name).replace('\\', '/')
        document.save()

        return JsonResponse({"success": True, "new_name": new_file_name})


def check_file_name(request):
    file_name = request.GET.get('file_name', '').strip()
    client_id = request.GET.get('client_id', '').strip()
    if(client_id != ''):
        exists = File_Category.objects.filter(name__iexact=file_name,client_id=client_id).exists()
        if(exists):
            return JsonResponse({'success': True,"message":"You have already created this category."})
    else:
        exists = File_Category.objects.filter(name__iexact=file_name).exists()
        if(exists):
            return JsonResponse({'success': True,"message":"This file name already exists. Please select this."})
    
    return JsonResponse({'success': False,"message":"Success."})

    




from .drive_utils import get_flow, get_drive_service
import json


def start_auth(request):
    flow = get_flow()
    auth_url, state = flow.authorization_url(access_type='offline', prompt='consent', include_granted_scopes='true')
    request.session['state'] = state
    return redirect(auth_url)


def gd_callback(request):
    flow = get_flow()

    absolute_url = request.build_absolute_uri()
    print(absolute_url, 'CHECK ABSOLUTE URI1')
    if absolute_url.startswith('http://'):
        absolute_url = 'https://' + absolute_url[len('http://'):]
        print(absolute_url, 'CHECK ABSOLUTE URI2')

    flow.fetch_token(authorization_response=absolute_url)
    # flow.fetch_token(authorization_response=request.build_absolute_uri())

    creds = flow.credentials
    try:
        user_info_service = build('oauth2', 'v2', credentials=creds)
        user_info = user_info_service.userinfo().get().execute()
        authenticated_email = user_info.get('email')
        print(authenticated_email, 'EMAIL')
    except Exception as e:
        authenticated_email = None

    google_drive_credentials_json = json.dumps({
        'access_token': creds.token,
        'refresh_token': creds.refresh_token,
        'token_uri': creds.token_uri,
        'client_id': creds.client_id,
        'client_secret': creds.client_secret,
        'scopes': creds.scopes
    })
    employee_id = request.session.get('user_id')
    employee_ob = employee.objects.get(id=employee_id)
    employee_ob.gd_token = google_drive_credentials_json
    employee_ob.gd_gmail = authenticated_email
    employee_ob.save()

    # START RESUME UPLOAD FROM DRIVE
    # Check if we came from an upload
    if request.session.get('auth_from') == 'upload':
        upload_data = request.session.pop('pending_drive_upload', None)
        request.session.pop('auth_from', None)

        if upload_data:
            # Store upload data in session and redirect to a resume view
            request.session['resume_upload'] = upload_data
            return redirect('resume_upload_from_drive')
    # END RESUME UPLOAD FROM DRIVE



    url = reverse('profile_with_optional', kwargs={'employee_id': int(employee_id), 'my_profile_tab': '3'})
    # url = reverse('profile', kwargs={'employee_id': int(employee_id)})
    print(url)
    response = HttpResponseRedirect(url)  # Redirect to a home page or a login pag
    return response  # Redirect user to a login or home page after signout


from googleapiclient.http import MediaIoBaseDownload
from io import BytesIO



def extract_folder_id(drive_url):
    if 'folders/' in drive_url:
        return drive_url.split('folders/')[1].split('?')[0]
    return None


def download_and_save(service, file_id, file_name, local_folder_path, employee_id, client_id, entity_type, description,
                      file_cat_ob_id):
    if not os.path.exists(local_folder_path):
        os.makedirs(local_folder_path)

    # request = service.files().get_media(fileId=file_id)
    fh = BytesIO()
    # downloader = MediaIoBaseDownload(fh, request)

    file_metadata = service.files().get(fileId=file_id, fields='mimeType, name, webViewLink').execute()
    mime_type = file_metadata['mimeType']
    web_view_link = file_metadata.get('webViewLink')

    if mime_type == 'application/vnd.google-apps.document':
        request = service.files().export_media(fileId=file_id, mimeType='application/pdf')
        file_ext = '.pdf'
    elif mime_type == 'application/vnd.google-apps.spreadsheet':
        request = service.files().export_media(fileId=file_id,
                                               mimeType='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
        file_ext = '.xlsx'
    elif mime_type == 'application/vnd.google-apps.presentation':
        request = service.files().export_media(fileId=file_id,
                                               mimeType='application/vnd.openxmlformats-officedocument.presentationml.presentation')
        file_ext = '.pptx'
    else:
        # It's a normal downloadable binary file (like image, PDF, zip)
        request = service.files().get_media(fileId=file_id)
        file_ext = ''

    # Construct full path
    file_name = file_name + file_ext if file_ext else file_name
    # file_path = os.path.join(local_folder_path, file_name)

    downloader = MediaIoBaseDownload(fh, request)
    done = False
    current_time = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
    file_name = f'{current_time}_{file_name}'
    file_name = file_name.replace('/', '_')
    while not done:
        status, done = downloader.next_chunk()
    static_folder_path = local_folder_path.replace(os.path.join(settings.BASE_DIR, "dec"), '')
    static_file_path = os.path.join(static_folder_path, file_name)

    local_file_path = os.path.join(local_folder_path, file_name)

    _, file_extension = os.path.splitext(file_name)
    file_extension = file_extension.lstrip('.').lower()
    emp_ob = employee.objects.get(id=employee_id)

    gallery = FileManager(
        entity_type=entity_type,
        employee_id=employee_id,
        client_id=client_id,
        category_id=file_cat_ob_id,
        file=static_file_path,
        description=description,
        file_type=file_extension,
        uploaded_by=emp_ob.user_id,
        google_drive_file_url=web_view_link
    )
    gallery.save()

    with open(local_file_path, 'wb') as f:
        f.write(fh.getbuffer())
    return local_file_path


def fetch_drive_folder(service, folder_id, local_root_path, employee_id, client_id, entity_type, description,
                       parent_name=''):
    files_to_upload = []
    folders = []

    query = f"'{folder_id}' in parents and trashed=false"
    results = service.files().list(q=query, fields="files(id, name, mimeType)").execute()
    items = results.get('files', [])

    for item in items:
        if item['mimeType'] == 'application/vnd.google-apps.folder':
            folders.append(item)
        else:
            files_to_upload.append(item)

    # Set upload folder path
    upload_path = os.path.join(local_root_path, parent_name) if parent_name else local_root_path

    if parent_name:
        try:
            file_cat_ob = File_Category.objects.get(name__iexact=parent_name, client_id=client_id,
                                                    entity_type=entity_type)  # WE HAVE TO IMPLEMENT THIS FOR EMPLOYEE ID ALSO
            file_cat_ob_id = file_cat_ob.id
        except Exception as e:
            file_cat_ob = File_Category.objects.create(name=parent_name, entity_type=entity_type, client_id=client_id)
            file_cat_ob_id = file_cat_ob.id
    else:
        file_cat_ob_id = None
    # Download files
    for file in files_to_upload:
        download_and_save(service, file['id'], file['name'], upload_path, employee_id, client_id, entity_type,
                          description, file_cat_ob_id)

    # Recursively handle subfolders
    for folder in folders:
        fetch_drive_folder(service, folder['id'], local_root_path, employee_id, client_id, entity_type, description,
                           parent_name or folder['name'])


@csrf_exempt
@login_required(login_url='/')
def upload_from_drive(request):
    if request.method == 'POST':
        drive_url = request.POST.get('drive_url')
        description = request.POST.get('description')
        client_id = request.POST.get('client_id')
        entity_type = request.POST.get('entity_type')
        employee_id = request.session.get('user_id')
        # creds_data = request.session.get('creds')
        employee_ob = employee.objects.get(id=employee_id)

        try:
            if not employee_ob.gd_token:
                request.session['pending_drive_upload'] = {
                    'drive_url': drive_url,
                    'description': description,
                    'client_id': client_id,
                    'entity_type': entity_type
                }
                request.session['auth_from'] = 'upload'
                return redirect('start_auth')
            else:
                creds_data = json.loads(employee_ob.gd_token)
        except Exception as e:
            print(e, 'CRED ERROR')

        folder_id = extract_folder_id(drive_url)
        if not folder_id:
            return JsonResponse({'error': 'Invalid Google Drive folder URL'}, status=400)

        try:
            service = get_drive_service(creds_data)
            base_upload_path = os.path.join(settings.STATICFILES_DIRS[0], 'img', 'client', 'documents')
            # base_upload_path = os.path.join(settings.STATIC_URL, 'img', 'client', 'documents')

            # Fetch and store drive files/folders
            fetch_drive_folder(service, folder_id, base_upload_path, employee_id, client_id, entity_type, description)

            # return JsonResponse({'success': 'Files uploaded successfully from Drive!'})
            messages.success(request, "Files uploaded and saved successfully from Drive.")

            url = reverse('client-profile', kwargs={'client_id': int(client_id)})
            # url = reverse('profile', kwargs={'employee_id': int(employee_id)})
            print(url)
            response = HttpResponseRedirect(url)  # Redirect to a home page or a login pag
            print('UPLOAD HO GYA HE')
            return response  # Redirect user to a login or home page after signout
        except Exception as e:
            print('UPLOAD ERROR HE')
            messages.success(request, f"Files not uploaded from Drive. {e}")
            url = reverse('client-profile', kwargs={'client_id': int(client_id)})
            response = HttpResponseRedirect(url)  # Redirect to a home page or a login pag
            return response  # Redirect user to a login or home page after signout
            # return JsonResponse({'error': str(e)}, status=500)

    # print(os.path.join(settings.STATICFILES_DIRS[0], 'img', 'client', 'documents'))
    # print(os.path.join(settings.STATIC_URL, 'img', 'client', 'documents'))
    # print(os.path.join(settings.BASE_DIR, "dec"))
    return JsonResponse({'error': "GET REQUEST NOT ALLOWED"}, status=500)


@csrf_exempt
@login_required(login_url='/')
def resume_upload_from_drive(request):
    upload_data = request.session.pop('resume_upload', None)
    if not upload_data:
        return JsonResponse({'error': "No pending upload data found."}, status=400)

    # Simulate the upload_from_drive logic here
    drive_url = upload_data.get('drive_url')
    description = upload_data.get('description')
    client_id = upload_data.get('client_id')
    entity_type = upload_data.get('entity_type')
    employee_id = request.session.get('user_id')

    try:
        employee_ob = employee.objects.get(id=employee_id)
        creds_data = json.loads(employee_ob.gd_token)

        folder_id = extract_folder_id(drive_url)
        if not folder_id:
            return JsonResponse({'error': 'Invalid Google Drive folder URL'}, status=400)

        service = get_drive_service(creds_data)
        base_upload_path = os.path.join(settings.STATICFILES_DIRS[0], 'img', 'client', 'documents')

        fetch_drive_folder(service, folder_id, base_upload_path, employee_id, client_id, entity_type, description)
        messages.success(request, "Files uploaded and saved successfully from Drive.")
    except Exception as e:
        messages.error(request, f"Upload failed after auth: {e}")

    return redirect(reverse('client-profile', kwargs={'client_id': int(client_id)}))





def gd_remove(request):
    employee_id = request.session.get('user_id')
    emp_ob = employee.objects.get(id=int(employee_id))
    if emp_ob.gd_token:
        emp_ob.gd_token = None
        emp_ob.gd_gmail = None
        emp_ob.save()

    url = reverse('profile_with_optional', kwargs={'employee_id': int(employee_id), 'my_profile_tab': '3'})
    # url = reverse('profile', kwargs={'employee_id': int(employee_id)})
    print(url)
    response = HttpResponseRedirect(url)  # Redirect to a home page or a login pag
    return response  # Redirect user to a login or home page after signout



@csrf_exempt
@login_required(login_url='/')
def delete_category(request):
    import urllib.parse
    if request.method == 'POST':
        entity_type = request.POST.get('entity_type')
        employee_id = request.POST.get('employee_id')
        client_id = request.POST.get('client_id')
        deleted_category = request.POST.get('deleted_category')

        cat_ob = File_Category.objects.get(id=deleted_category)
   
        cat_ob.delete()
        messages.success(request, 'Category Deleted successfully!')

    else:
        return JsonResponse({"error": "Action not allowed."}, status=500)

    if entity_type == 'employee':
        return redirect("profile", employee_id)
    else:
        return redirect("client-profile", client_id)

@csrf_exempt
@login_required(login_url='/')
def upload_airtable_sheet(request):
    if request.method == 'POST':
        file = request.FILES.get('airtable_sheet')
        if file:
            reader = csv.reader(file.read().decode('utf-8').splitlines())
            headers = next(reader, None)  # Skip header row if present
            for row in reader:
                try:
                    client_info = client.objects.get(client_name=row[0].strip())
                    client_id = client_info.id
                except client.DoesNotExist:
                    client_id = None

                # Helper function to convert field values
                def convert_value(value, default=None):
                    value = value.strip() if value else ''
                    if value == '' or value.upper() == 'N/A':
                        return default
                    return value

                # Handle date field
                contract_start_date = None
                if row[6].strip() and row[6].strip().upper() != 'N/A':
                    try:
                        contract_start_date = row[6].strip()
                    except ValueError:
                        contract_start_date = None

                # Create the Airtable object with proper value handling
                Airtable.objects.create(
                    client_name = row[0].strip(),
                    client_id = client_id,
                    company_name = row[1].strip(),
                    reporting_month = convert_value(row[2], None),
                    reporting_year = convert_value(row[3], None),
                    linkedin_url = convert_value(row[4], ''),
                    twitter_url = convert_value(row[5], ''),                    
                    contract_start_date = contract_start_date,                    
                    twitter_follower_count = convert_value(row[7], None),
                    twitter_following_count = convert_value(row[8], None),
                    twitter_tweet_count = convert_value(row[9], None),
                    twitter_like_count = convert_value(row[10], None),
                    twitter_retweet_count = convert_value(row[11], None),
                    twitter_reply_count = convert_value(row[12], None),
                    twitter_engagement_count = convert_value(row[13], None),
                    twitter_engagement_rate = convert_value(row[14], None),
                    twitter_sent_count = convert_value(row[15], None),
                    twitter_posted_count = convert_value(row[16], None),

                    linkedin_connection_count = convert_value(row[17], None),
                    linkedin_follower_count = convert_value(row[18], None),
                    linkedin_profile_view_count = convert_value(row[19], None),
                    linkedin_profile_search_count = convert_value(row[20], None),
                    linkedin_ssi_score = convert_value(row[21], None),
                    linkedin_post_count = convert_value(row[22], None),
                    linkedin_sent_post_count = convert_value(row[23], None),
                    linkedin_used_post_count = convert_value(row[24], None),
                    linkedin_usage_percentage = convert_value(row[25], None),
                    linkedin_view_count = convert_value(row[26], None),
                    linkedin_views_per_post = convert_value(row[27], None),
                    linkedin_repost_count = convert_value(row[28], None),
                    linkedin_reaction_count = convert_value(row[29], None),
                    linkedin_comment_count = convert_value(row[30], None),
                    linkedin_engagement_count = convert_value(row[31], None),
                    linkedin_engagement_rate = convert_value(row[32], None)
                )
    return render(request, "excel/upload_airtable_sheet.html", {})

@csrf_exempt
@login_required(login_url='/')
def upload_linkedinpost(request):
    if request.method == 'POST':
        file = request.FILES.get('linkedin_post')
        if file:
            reader = csv.reader(file.read().decode('utf-8').splitlines())
            headers = next(reader, None)  # Skip header row

            for row_num, row in enumerate(reader, start=2):  # start=2 for correct row number (after header)
                def convert_value(value, default=None):
                    value = value.strip() if value else ''
                    return default if value == '' or value.upper() == 'N/A' else value

                client_id = convert_value(row[0], None)
                # company_name = convert_value(row[1])
                reporting_month = convert_value(row[1], None)
                reporting_year = convert_value(row[2], None)

                # Match Airtable
                airtable_entry = Airtable.objects.filter(
                    client_id=client_id,
                    reporting_month=reporting_month,
                    reporting_year=reporting_year
                ).first()

                if not airtable_entry:
                    print(f"[Row {row_num}] No Airtable match for: {client_name}, {company_name}, {reporting_month}, {reporting_year}")
                    continue
                print(f"[Row {row_num}] Airtable data : ")
                print(row)

                # Match client
                client_entry = client.objects.get(id=client_id)

                if not client_entry:
                    print(f"[Row {row_num}] No Client found")
                    continue

                published_str = convert_value(row[10], None)
                published_date = None
                if published_str:
                    try:
                        published_date = datetime.strptime(published_str, '%Y-%m-%d').date()
                    except ValueError:
                        continue

                try:
                    LinkedinPost.objects.create(
                        client_id=client_entry.id,
                        airtable_id=airtable_entry.id,
                        # post_count=convert_value(row[4]),
                        post_url=convert_value(row[3], ''),
                        post_content=convert_value(row[4], ''),
                        view_count=convert_value(row[5], None),
                        reaction_count=convert_value(row[6], None),
                        comment_count=convert_value(row[7], None),
                        repost_count=convert_value(row[8], None),
                        engagement_rate=convert_value(row[9], None),
                        published_date=published_date,
                        tonality=convert_value(row[11], None),
                    )
                    print(f"[Row {row_num}] LinkedIn post saved for client: {client_name}")
                except Exception as e:
                    print(f"[Row {row_num}] Error saving post: {e}")

            return render(request, "excel/upload_linkedinpost.html")
        else:
            return render(request, "excel/upload_linkedinpost.html")
    return render(request, "excel/upload_linkedinpost.html")


def safe_subtract(a, b):
    return (a or 0) - (b or 0)

def safe_growth_percentage(current, old):
    if old is None:
        return None
    if old == 0:
        if current and current > 0:
            return 100.0
        else:
            return 0.0
    return ((current or 0) - (old or 0)) / old * 100


def get_6_month_follower_growth(client_id):
    airtable_details = Airtable.objects.filter(client_id=client_id).order_by('-id').first()

    if airtable_details:
        latest_year = airtable_details.reporting_year
        latest_month = airtable_details.reporting_month
        now = datetime(year=latest_year, month=latest_month, day=1)
    else:
        now = datetime.now()

    six_months_ago = subtract_months(now, 5)

    try:
        current_data = Airtable.objects.get(
            client_id=client_id,
            reporting_month=now.month,
            reporting_year=now.year
        )
    except Airtable.DoesNotExist:
        current_data = None

    try:
        old_data = Airtable.objects.get(
            client_id=client_id,
            reporting_month=six_months_ago.month,
            reporting_year=six_months_ago.year
        )
    except Airtable.DoesNotExist:
        old_data = None

    def compute_6_month_avg_engagement_and_impressions(client_id, reference_date):
        total_engagement = 0
        total_views = 0
        total_posts = 0
        shared_total = 0

        for i in range(6):
            target_date = subtract_months(reference_date, i)
            try:
                data = Airtable.objects.get(
                    client_id=client_id,
                    reporting_month=target_date.month,
                    reporting_year=target_date.year
                )
                total_engagement += data.linkedin_engagement_count or 0
                total_views += data.linkedin_view_count or 0
                total_posts += data.linkedin_post_count or 0
                shared_total += data.shared_post_count or 0
            except Airtable.DoesNotExist:
                continue

        if total_posts > 0:
            avg_engagement = total_engagement / total_posts
            avg_impressions = total_views / total_posts

            total_post_count = total_posts+shared_total
            reshared_percent = round((shared_total / total_post_count) * 100, 2)
            original_percent = round(100 - reshared_percent, 2)
        else:
            avg_engagement = None
            avg_impressions = None
            reshared_percent = 0
            original_percent = 100

        return avg_engagement, avg_impressions, original_percent, reshared_percent

    if current_data and old_data:
        linkedin_growth = safe_subtract(current_data.linkedin_follower_count, old_data.linkedin_follower_count)
        twitter_growth = safe_subtract(current_data.twitter_follower_count, old_data.twitter_follower_count)

        linkedin_growth_percentage = safe_growth_percentage(current_data.linkedin_follower_count, old_data.linkedin_follower_count)
        twitter_growth_percentage = safe_growth_percentage(current_data.twitter_follower_count, old_data.twitter_follower_count)

        avg_engagement, avg_impressions, original_percent, reshared_percent = compute_6_month_avg_engagement_and_impressions(client_id, now)

        return {
            'linkedin_growth': linkedin_growth,
            'linkedin_growth_percentage': linkedin_growth_percentage,
            'twitter_growth': twitter_growth,
            'twitter_growth_percentage': twitter_growth_percentage,
            'avg_engagement': avg_engagement,
            'avg_impressions': avg_impressions,
            'original_percent': original_percent,
            'reshared_percent': reshared_percent
        }
    else:
        return None






# from dateutil.relativedelta import relativedelta

def subtract_months(dt, months):
    y, m = divmod(dt.year * 12 + dt.month - months - 1, 12)
    return dt.replace(year=y, month=m + 1, day=1)

def get_monthly_heatmap_data(client_id):
    airtable_details = Airtable.objects.filter(client_id=client_id).order_by('-id').first()

    if airtable_details:
        latest_year = airtable_details.reporting_year
        latest_month = airtable_details.reporting_month
        now = datetime(year=latest_year, month=latest_month, day=1)
    else:
        now = datetime.now()

    # start_month = now - relativedelta(months=3)
    start_month = subtract_months(now, 3)

    
    posts = LinkedinPost.objects.filter(
        client_id=client_id,
        published_date__gte=start_month,
        engagement_rate__isnull=False
    )

    month_labels = []
    month_indices = {}
    for i in range(3, -1, -1):
        m = (subtract_months(now, i)).replace(day=1)
        label = m.strftime('%b')
        month_labels.append(label)
        month_indices[m.month] = 3 - i

    matrix = [[{'likes': 0, 'shares': 0, 'comments': 0, 'total': 0, 'count': 0} for _ in range(4)] for _ in range(7)]

    for post in posts:
        date = post.published_date
        month = date.month
        day = date.weekday()
        if month in month_indices:
            x = month_indices[month]
            cell = matrix[day][x]
            cell['likes'] += post.reaction_count or 0
            cell['shares'] += post.repost_count or 0
            cell['comments'] += post.comment_count or 0
            cell['total'] += post.engagement_rate or 0
            cell['count'] += 1

    return matrix, month_labels

def dashboard(request, linkedin_user):
    # now = datetime.now()
    # six_months_ago = now - relativedelta(months=6)

    airtable_details = Airtable.objects.filter(linkedin_url__icontains=f'/in/{linkedin_user}').order_by('-id').first()
    client_id = airtable_details.client_id
    if not client_id:
        return HttpResponse("Client not exist!")
    client_details = client.objects.get(id=client_id)

    if airtable_details:
        latest_year = airtable_details.reporting_year
        latest_month = airtable_details.reporting_month
        now = datetime(year=latest_year, month=latest_month, day=1)
    else:
        now = datetime.now()

    # six_months_ago = now - relativedelta(months=6)
    six_months_ago = now - timedelta(days=180)

 

    result = get_6_month_follower_growth(client_id)

    linkedin_growth = None
    linkedin_growth_percentage = None
    twitter_growth = None
    twitter_growth_percentage = None
    avg_engagement = None
    avg_impressions = None
    original_percent =  100
    reshared_percent =  0

    if result:
        linkedin_growth = result.get('linkedin_growth')
        linkedin_growth_percentage = result.get('linkedin_growth_percentage')
        twitter_growth = result.get('twitter_growth')
        twitter_growth_percentage = result.get('twitter_growth_percentage')
        avg_engagement = result.get('avg_engagement')
        avg_impressions = result.get('avg_impressions')
        original_percent =  result.get('original_percent')
        reshared_percent =  result.get('reshared_percent')

    # Airtable records for last 6 months
    airtable_records = Airtable.objects.filter(
        client_id=client_id,
        reporting_year__gte=six_months_ago.year
    ).order_by('reporting_year', 'reporting_month')

    monthly_labels = []
    monthly_post_frequency = []
    monthly_profile_searches = []
    monthly_new_followers = []
    monthly_new_connections = []

    monthly_engagement = []
    monthly_impressions = []
    monthly_profile_views = []

    for record in airtable_records:
        if record.reporting_year == now.year or (record.reporting_year == six_months_ago.year and record.reporting_month >= six_months_ago.month):
            month_name = record.get_reporting_month_display()
            monthly_labels.append(month_name)
            monthly_post_frequency.append(record.linkedin_post_count or 0)
            monthly_profile_searches.append(record.linkedin_profile_search_count or 0)
            monthly_new_followers.append(record.linkedin_follower_count or 0)
            monthly_new_connections.append(record.linkedin_connection_count or 0)

            monthly_engagement.append(record.linkedin_engagement_count or 0)
            monthly_impressions.append(record.linkedin_view_count or 0)
            monthly_profile_views.append(record.linkedin_profile_view_count or 0)

    # --- Quarterly Aggregation
    quarters = {
        'Q1': {'months': [1, 2, 3], 'postFrequency': 0, 'profileSearches': 0, 'newFollowers': 0, 'newConnections': 0,
               'engagement': 0, 'impressions': 0, 'profileViews': 0},
        'Q2': {'months': [4, 5, 6], 'postFrequency': 0, 'profileSearches': 0, 'newFollowers': 0, 'newConnections': 0,
               'engagement': 0, 'impressions': 0, 'profileViews': 0}
    }

    for record in airtable_records:
        if record.reporting_year == now.year or (record.reporting_year == six_months_ago.year and record.reporting_month >= six_months_ago.month):
            month = record.reporting_month
            for quarter, data in quarters.items():
                if month in data['months']:
                    data['postFrequency'] += record.linkedin_post_count or 0
                    data['profileSearches'] += record.linkedin_profile_search_count or 0
                    data['newFollowers'] += record.linkedin_follower_count or 0
                    data['newConnections'] += record.linkedin_connection_count or 0
                    data['engagement'] += record.linkedin_engagement_count or 0
                    data['impressions'] += record.linkedin_profile_view_count or 0
                    data['profileViews'] += record.linkedin_view_count or 0

    print('data ',data)
    quarterly_labels = list(quarters.keys())
    quarterly_post_frequency = [quarters[q]['postFrequency'] for q in quarterly_labels]
    quarterly_profile_searches = [quarters[q]['profileSearches'] for q in quarterly_labels]
    quarterly_new_followers = [quarters[q]['newFollowers'] for q in quarterly_labels]
    quarterly_new_connections = [quarters[q]['newConnections'] for q in quarterly_labels]
    quarterly_engagement = [quarters[q]['engagement'] for q in quarterly_labels]
    quarterly_impressions = [quarters[q]['impressions'] for q in quarterly_labels]
    quarterly_profile_views = [quarters[q]['profileViews'] for q in quarterly_labels]

    # --- Semi-Annually Aggregation
    h1 = {'months': [1, 2, 3], 'postFrequency': 0, 'profileSearches': 0, 'newFollowers': 0, 'newConnections': 0,
          'engagement': 0, 'impressions': 0, 'profileViews': 0}
    h2 = {'months': [4, 5, 6], 'postFrequency': 0, 'profileSearches': 0, 'newFollowers': 0, 'newConnections': 0,
          'engagement': 0, 'impressions': 0, 'profileViews': 0}

    for record in airtable_records:
        if record.reporting_year == now.year or (record.reporting_year == six_months_ago.year and record.reporting_month >= six_months_ago.month):
            month = record.reporting_month
            if month in h1['months']:
                h1['postFrequency'] += record.linkedin_post_count or 0
                h1['profileSearches'] += record.linkedin_profile_search_count or 0
                h1['newFollowers'] += record.linkedin_follower_count or 0
                h1['newConnections'] += record.linkedin_connection_count or 0
                h1['engagement'] += record.linkedin_engagement_count or 0
                h1['impressions'] += record.linkedin_profile_view_count or 0
                h1['profileViews'] += record.linkedin_view_count or 0
            elif month in h2['months']:
                h2['postFrequency'] += record.linkedin_post_count or 0
                h2['profileSearches'] += record.linkedin_profile_search_count or 0
                h2['newFollowers'] += record.linkedin_follower_count or 0
                h2['newConnections'] += record.linkedin_connection_count or 0
                h2['engagement'] += record.linkedin_engagement_count or 0
                h2['impressions'] += record.linkedin_profile_view_count or 0
                h2['profileViews'] += record.linkedin_view_count or 0

    semiannually_labels = ['H1', 'H2']
    semiannually_post_frequency = [h1['postFrequency'], h2['postFrequency']]
    semiannually_profile_searches = [h1['profileSearches'], h2['profileSearches']]
    semiannually_new_followers = [h1['newFollowers'], h2['newFollowers']]
    semiannually_new_connections = [h1['newConnections'], h2['newConnections']]
    semiannually_engagement = [h1['engagement'], h2['engagement']]
    semiannually_impressions = [h1['impressions'], h2['impressions']]
    semiannually_profile_views = [h1['profileViews'], h2['profileViews']]

    # -----
    # Chart data for Bar Chart (already done before)
    chart_data = {
        'Monthly': {
            'labels': monthly_labels,
            'postFrequency': monthly_post_frequency,
            'profileSearches': monthly_profile_searches,
            'newFollowers': monthly_new_followers,
            'newConnections': monthly_new_connections
        },
        'Quarterly': {
            'labels': quarterly_labels,
            'postFrequency': quarterly_post_frequency,
            'profileSearches': quarterly_profile_searches,
            'newFollowers': quarterly_new_followers,
            'newConnections': quarterly_new_connections
        },
        'SemiAnnually': {
            'labels': semiannually_labels,
            'postFrequency': semiannually_post_frequency,
            'profileSearches': semiannually_profile_searches,
            'newFollowers': semiannually_new_followers,
            'newConnections': semiannually_new_connections
        }
    }

    # Chart data for Flot Line Chart
    chart_data_line = {
        'Monthly': {
            'labels': monthly_labels,
            'engagement': monthly_engagement,
            'impressions': monthly_impressions,
            'profileViews': monthly_profile_views
        },
        'Quarterly': {
            'labels': quarterly_labels,
            'engagement': quarterly_engagement,
            'impressions': quarterly_impressions,
            'profileViews': quarterly_profile_views
        },
        'SemiAnnually': {
            'labels': semiannually_labels,
            'engagement': semiannually_engagement,
            'impressions': semiannually_impressions,
            'profileViews': semiannually_profile_views
        }
    }

    from django.db.models import Q

    months = []
    dt_pointer = six_months_ago.replace(day=1)
    while dt_pointer <= now:
        months.append((dt_pointer.year, dt_pointer.month))
        dt_pointer += timedelta(days=30)
    print('six_months_ago')
    print(six_months_ago)
    print(dt_pointer)
    print(months)

    post_filter = Q()
    for year, month in months:
        post_filter |= Q(published_date__year=year, published_date__month=month)

    linkedin_posts = LinkedinPost.objects.filter(
        client_id=str(client_id),  # match your stored client_id type
    ).filter(post_filter)

    top_performing_posts = linkedin_posts.order_by('-engagement_rate')[:3]
    under_performing_posts = linkedin_posts.order_by('engagement_rate')[:3]


    tonality_filter = Q()
    dt_pointer = six_months_ago.replace(day=1)
    while dt_pointer <= now:
        tonality_filter |= Q(published_date__year=dt_pointer.year, published_date__month=dt_pointer.month)
        dt_pointer += timedelta(days=30)

    posts = LinkedinPost.objects.filter(client_id=str(client_id)).filter(tonality_filter)

    tonality_counts = Counter(post.tonality.lower() if post.tonality else 'unknown' for post in posts)

    total = tonality_counts['positive'] + tonality_counts['neutral'] + tonality_counts['negative']
    if total > 0:
        tonality_percentages = {
            'positive': round((tonality_counts['positive'] / total) * 100, 2),
            'neutral': round((tonality_counts['neutral'] / total) * 100, 2),
            'negative': round((tonality_counts['negative'] / total) * 100, 2),
        }
    else:
        tonality_percentages = {'positive': 0, 'neutral': 0, 'negative': 0}

    from calendar import month_abbr
    dt_pointer = subtract_months(now, 5)
    sentiment_monthly = []

    # Start from 6 months ago and loop until now
    # dt_pointer = six_months_ago.replace(day=1)
    while dt_pointer <= now:
        monthly_posts = LinkedinPost.objects.filter(
            client_id=str(client_id),
            published_date__year=dt_pointer.year,
            published_date__month=dt_pointer.month
        )

        counts = Counter(
            post.tonality.lower() if post.tonality else 'unknown'
            for post in monthly_posts
        )
        
        total = counts['positive'] + counts['neutral'] + counts['negative']
        sentiment_monthly.append({
            'month': month_abbr[dt_pointer.month],
            'positive': round((counts['positive'] / total) * 100, 2) if total else 0,
            'neutral': round((counts['neutral'] / total) * 100, 2) if total else 0,
            'negative': round((counts['negative'] / total) * 100, 2) if total else 0,
        })

        dt_pointer += timedelta(days=30)






    full_url = request.build_absolute_uri(reverse('dashboard', args=[linkedin_user]))


    weekly = get_weekly_heatmap_data(client_id)
    monthly, month_labels = get_monthly_heatmap_data(client_id)
    print('month_labels1')
    print(month_labels)



    predefined_colors = [
        'rgb(155, 135, 245)',  # 1st topic
        'rgb(142, 145, 150)',  # 2nd topic
        'rgb(234, 56, 76)',    # 3rd topic
        'rgb(126, 105, 171)',  # 4th topic
        'rgb(217, 70, 239)',   # 5th topic
        'rgb(51, 195, 240)'    # 6th topic
    ]

    topic_counter = Counter()
    for post in posts:
        for topic in [post.topic_1, post.topic_2, post.topic_3]:
            if topic:
                topic_counter[topic] += 1

    most_common_topics = topic_counter.most_common(6)

    topic_color_map = {}
    for i, (topic, _) in enumerate(most_common_topics):
        topic_color_map[topic] = predefined_colors[i]

    total_valid = sum([count for _, count in most_common_topics])
    topic_breakdown = []

    if total_valid > 0:
        for topic, count in most_common_topics:
            percentage = round((count / total_valid) * 100, 2)
            topic_breakdown.append({
                'label': topic,
                'value': percentage,
                'color': topic_color_map[topic]
            })

    topic_breakdown.sort(key=lambda x: x['value'], reverse=True)


    all_domains = LinkedinPost.objects.values_list('domain', flat=True)

    domain_list = []
    for d in all_domains:
        if not d:
            continue  # skip empty

        if isinstance(d, str):
            # Handle strings like '{linkedin,ey}' or 'linkedin,ey'
            cleaned = d.strip('{}')
            domain_list.extend([item.strip() for item in cleaned.split(',') if item.strip()])
        elif isinstance(d, list):
            domain_list.extend([item.strip() for item in d if isinstance(item, str) and item.strip()])

    # Get top 3 domains
    top_domains = Counter(domain_list).most_common(3)


    context = {
        'client_details': client_details,
        # 'matrix': json.dumps(matrix),
        'original_percent': original_percent,
        'reshared_percent': reshared_percent,
        'weekly_data': json.dumps(weekly),
        'top_domains': top_domains,
        'monthly_data': json.dumps(monthly),
        'month_labels': json.dumps(month_labels),
        'topic_breakdown': json.dumps(topic_breakdown),
        'tonality_monthly': json.dumps(sentiment_monthly),
        'full_dashboard_url': full_url,
        'linkedin_user': linkedin_user,
        'airtable_details': airtable_details,
        'linkedin_growth': linkedin_growth,
        'linkedin_growth_percentage': linkedin_growth_percentage,
        'twitter_growth': twitter_growth,
        'twitter_growth_percentage': twitter_growth_percentage,
        'avg_engagement': avg_engagement,
        'avg_impressions': avg_impressions,
        'chart_data_json': json.dumps(chart_data),
        'chart_data_line_json': json.dumps(chart_data_line),
        'top_performing_posts': top_performing_posts,
        'under_performing_posts': under_performing_posts,
        'tonality_percentages': tonality_percentages,
    }

    return render(request, "airtable.html", context)


@csrf_exempt
def submit_post_generate_data(request):

    """
    View to receive form data and forward it to n8n webhook.
    This view accepts POST requests with JSON data containing topic_name, company_include,
    domain_source, and exclude_content fields and forwards them to the n8n webhook URL.
    """
    try:
        # Parse the incoming JSON data
        data = json.loads(request.body)

        # Ensure all required fields are present
        print(data, 'DATA TEST')
        required_fields = ['topic_name', 'company_include', 'domain_source']
        for field in required_fields:
            if field not in data or not data[field]:
                return JsonResponse({
                    'success': False,
                    'message': f'Missing required field: {field}'
                }, status=400)


      

        if int(data['client_id1']) == 262:
            data['asst_id'] = "asst_LEMO5CIRD4HHMRUai1RJMFyT"
            # webhook_url = 'https://n8n.educatedapp.com/webhook-test/dec_common'
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 240:
            data['asst_id'] = "asst_GgQvH10LEQe7smNWKrZVdu6L"
            # webhook_url = 'https://n8n.educatedapp.com/webhook-test/dec_common'
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 228:
            data['asst_id'] = "asst_cJeKJlrWmNodKMp7VDfff0t9"
            # webhook_url = 'https://n8n.educatedapp.com/webhook-test/dec_common'
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 290:
            data['asst_id'] = "asst_kq1qF3dnnNxWiuZtK0rUwZ6u"
            # webhook_url = 'https://n8n.educatedapp.com/webhook-test/dec_common'
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'

        elif int(data['client_id1']) == 12:
            data['asst_id'] = "asst_BaTyDioIrDxYzz6Qe6SzFhcJ"
            # webhook_url = 'https://n8n.educatedapp.com/webhook-test/dec_common'
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 179:
            data['asst_id'] = "asst_QlTy3BqJFTy9LznEc4DLkFd5"
            # webhook_url = 'https://n8n.educatedapp.com/webhook-test/dec_common'
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 261:
            data['asst_id'] = "asst_Vb6CnnImCIufVZeqyOJzhJUS"
            # webhook_url = 'https://n8n.educatedapp.com/webhook-test/dec_common'
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 243:
            data['asst_id'] = "asst_1ECPfIOOTxMwfUUve7fbWYoe"
            # webhook_url = 'https://n8n.educatedapp.com/webhook-test/dec_common'
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 11:
            data['asst_id'] = "asst_W3B4v3bK1H5rTSKuI3hJw6xf"
            # webhook_url = 'https://n8n.educatedapp.com/webhook-test/dec_common'
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 3:
            data['asst_id'] = "asst_yuGFYW0AwEwPoKqqqoWpaLxx"
            # webhook_url = 'https://n8n.educatedapp.com/webhook-test/dec_common'
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 230:
            data['asst_id'] = "asst_KZtuCoe2cT5iP9EeipQr9ut2"
            # webhook_url = 'https://n8n.educatedapp.com/webhook-test/dec_common'
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 211:
            data['asst_id'] = "asst_xKtgKktXAR01zt4c59H66UYH"
            # webhook_url = 'https://n8n.educatedapp.com/webhook-test/dec_common'
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'



        elif int(data['client_id1']) == 79:
            data['asst_id'] = "asst_94oxLFO72WyzPWfjn8zGXVp8"
            # webhook_url = 'https://n8n.educatedapp.com/webhook-test/dec_common'
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 80:
            data['asst_id'] = "asst_nhnl76Z1AwWw32XMbX6rq36x"
            # webhook_url = 'https://n8n.educatedapp.com/webhook-test/dec_common'
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 88:
            data['asst_id'] = "asst_fTzPSGLWDjPQCssPtGlfnQlb"
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 289:
            data['asst_id'] = "asst_8Q5J5taUSCqrW3Xk3l8VrRQ5"
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 281:
            data['asst_id'] = "asst_s2NmJEOQVZcpoFw9Xg9xAqSp"
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 166:
            data['asst_id'] = "asst_KYpkxjOALR88PV2Ddz7OG5eD"
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'
        elif int(data['client_id1']) == 122:
            data['asst_id'] = "asst_q22sBxtkLt0BbEYL8AfAo2Bg"
            webhook_url = 'https://n8n.educatedapp.com/webhook/dec_common'

        response = requests.post(
            webhook_url,
            json=data,
            headers={'Content-Type': 'application/json'}
        )

        print(response.status_code, 'TEST RESPONSE', response)
        print("Text:", response.text)  # The full body as a string
        print(response.headers)
        #
        # # Check if the webhook call was successful
        if response.status_code in [200, 201, 202]:
            print(data['topic_name'])
            print(request.user.id)
            print(data['client_id1'])
            print(data['company_include'])
            print(data['domain_source'])
            print(data['exclude_content'])
            print(data['exclude_domain'])
            SocialMedia.objects.create(topic_name=data['topic_name'], employee_id=request.user.id,
                                       client_id=data['client_id1'], company_include=data['company_include'],
                                       domain_source=data['domain_source'], exclude_content=data['exclude_content'],
                                       exclude_domain=data['exclude_domain'], top_post_text=response.text)

        return JsonResponse({
            'success': True,
            'message': 'Data successfully sent to webhook'
        })

    except Exception as e:
        print(e)
        return JsonResponse({
            'success': False,
            'message': f'Invalid JSON data {e}'
        }, status=400)


@csrf_exempt
def receive_post_data(request):
    if request.method == "POST":
        try:
            data = json.loads(request.body.decode("utf-8"))
            print("Received data:", data)
            client_id = data.get("client_id")
            date_str = data.get("date")  # e.g., "2026-06-16"
            linkedin_post = data.get("linkedin_post")
            twitter_post = data.get("twitter_post")

            social_post = SocialMedia.objects.filter(client_id=int(client_id)).last()
            print(social_post.id)
            if social_post:
                social_post.selected_linkedin_post = linkedin_post
                social_post.selected_twitter_post = twitter_post
                try:
                    social_post.date = date.today()
                except Exception as e:
                    pass
                social_post.save()
                return JsonResponse({"status": "success", "message": "Post updated."})
            else:
                return JsonResponse({"error": "No records found for this client_id."}, status=404)
        except Exception as e:
            return JsonResponse({"received": False, "error": str(e)}, status=400)
    else:
        return JsonResponse({"error": "Only POST allowed"}, status=405)

def add_holidays_2026(request):

    HOLIDAYS_2026 = [
        # -------- US Holidays (country_id = 1) --------
        {"country_id": 1, "name": "New Year", "date": date(2026, 1, 1)},
        {"country_id": 1, "name": "Martin Luther King Day", "date": date(2026, 1, 19)},
        {"country_id": 1, "name": "Washington's Birthday", "date": date(2026, 2, 16)},
        {"country_id": 1, "name": "Memorial Day", "date": date(2026, 5, 25)},
        {"country_id": 1, "name": "Juneteenth", "date": date(2026, 6, 19)},
        {"country_id": 1, "name": "Independence Day", "date": date(2026, 7, 4)},
        {"country_id": 1, "name": "Labor Day", "date": date(2026, 9, 7)},
        {"country_id": 1, "name": "Columbus Day", "date": date(2026, 10, 12)},
        {"country_id": 1, "name": "Thanksgiving Day", "date": date(2026, 11, 26)},
        {"country_id": 1, "name": "Day After Thanksgiving holiday", "date": date(2026, 11, 27)},
        {"country_id": 1, "name": "Christmas Day", "date": date(2026, 12, 25)},

        # -------- UK Holidays (country_id = 3) --------
        {"country_id": 3, "name": "New Year", "date": date(2026, 1, 1)},
        {"country_id": 3, "name": "Good Friday", "date": date(2026, 4, 3)},
        {"country_id": 3, "name": "Easter Monday", "date": date(2026, 4, 6)},
        {"country_id": 3, "name": "Early May bank holiday", "date": date(2026, 5, 4)},
        {"country_id": 3, "name": "Spring bank holiday", "date": date(2026, 5, 25)},
        {"country_id": 3, "name": "Summer bank holiday", "date": date(2026, 8, 31)},
        {"country_id": 3, "name": "Christmas Day", "date": date(2026, 12, 25)},
        {"country_id": 3, "name": "Boxing Day", "date": date(2026, 12, 26)},
    ]
    holiday_objects = [
        Holiday(
            country_id=h["country_id"],
            name=h["name"],
            date=h["date"],
            description=""
        )
        for h in HOLIDAYS_2026
    ]

    Holiday.objects.bulk_create(holiday_objects)
    messages.success(request, "All 2026 US & UK holidays added successfully.")
    return JsonResponse("HOLIDAYS SAVED", safe=False)












# Create your views here.
@csrf_exempt
def login(request):
    # Check if the user is already logged in
    logging.info("Accessed login view")
    if request.user.is_authenticated:
        print(f"User {request.user.username} is already authenticated. Redirecting to admin dashboard.")
        return redirect("admin-dashboard")

    base_url = f"{request.scheme}://{request.get_host()}/auth-receiver"
    if request.method == 'POST':
        
        uname = request.POST.get("username")
        print("myyyy")
        print(uname)
        password = request.POST.get('password')
        print('Password')
        print(password)
        logging.info(f"Received login data: username={uname}, password={'*' * len(password) if password else None}")

        # Attempt authentication with the original email
        user = auth.authenticate(username=uname, password=password)

        # If authentication fails, attempt authentication with the first letter lowercase
        try:
            if not user:
                uname_lower = uname[0].lower() + uname[1:]
                user = auth.authenticate(username=uname_lower, password=password)

            # If authentication fails again, attempt authentication with the first letter uppercase
            if not user:
                uname_upper = uname[0].upper() + uname[1:]
                user = auth.authenticate(username=uname_upper, password=password)
        except:
            pass

        if user is not None:
            # print("if")
            auth.login(request, user)
            request.session['user_email'] = user.email
            print(request.session['user_email'])
            group = None

            if request.user.groups.exists():
                group = request.user.groups.all()
                print("exist group")
                print(group)

                if group[0].name == 'admin' or group[0].name == 'super_admin'or group[0].name == 'super_user':
                    print("admin")
                    employee1 = employee.objects.get(user_name=request.user.username)
                    if employee1:
                        request.session['first_name'] = employee1.first_name
                        request.session['last_name'] = employee1.last_name
                        request.session['user_image_url'] = employee1.image_url
                        request.session['user_name'] = employee1.user_name
                        request.session['user_id'] = employee1.id
                        return redirect("admin-dashboard")

            else:
                print("User is not in any admin group. Checking for employee record.")
                print("employee")
                employee1 = employee.objects.get(user_name=request.user.username)
                print("sgvfbhjnmk,,,,;l/////////////////////////////////////")
                print(employee1)
                if employee1:
                    request.session['first_name'] = employee1.first_name
                    request.session['last_name'] = employee1.last_name
                    request.session['user_image_url'] = employee1.image_url
                    request.session['user_name'] = employee1.user_name
                    request.session['user_id'] = employee1.id
                    print(user.email)
                    print(employee1.image_url)
                    print("employee done")
                return redirect("admin-dashboard")

    # Default return statement if none of the conditions are met
    return render(request, "login.html", {'google_client_id': settings.GOOGLE_OAUTH_CLIENT_ID,'base_url':base_url})


def logout(request):
    auth.logout(request)
    return redirect('login')


@csrf_exempt
def register(request):
    logging.info("Accessed register view")
    if request.method == 'POST':
        
        uname = request.POST.get("username")
        pass1 = request.POST.get("password")
        pass2 = request.POST.get("repeat_password")
        logging.info(f"Received registration data: username={uname}, pass1={pass1 }, pass2={pass2}")

        if pass1 != pass2:
            messages.error(request, "Passwords do not match.")
            return redirect("register")  # Redirect back to the registration page

        # Check if the email is already in use
        if User.objects.filter(username=uname).exists():
            messages.error(request, "This email is already in use.")
            return redirect("register")

        # Create a new user
        try:

            my_user = User.objects.create_user(username=uname, password=pass1,email=uname)
            my_user.save()
            my_employee=employee.objects.create(user_name=uname, first_name=uname,user_id=my_user.id, country_id=1, email=uname)
            logging.info(f"Created user: {my_user}, employee record: {my_employee}")
            return redirect("login")
        except Exception as e:
            logging.error(f"Error creating user: {e}")
        
            messages.error(request, "An error occurred during registration. Please try again later.")
        # messages.success(request, "Registration successful.")
        return redirect("admin-dashboard")

    return render(request, "register.html",{})
@csrf_exempt
def forgot_password(request):
        if request.method == 'POST':
            email = request.POST.get('email')
            try:
                user = User.objects.get(email=email)
            except User.DoesNotExist:
                user = None

            if user:
                # Generate a temporary password
                temp_password = ''.join(random.choices(string.ascii_letters + string.digits, k=12))
                user.set_password(temp_password)
                user.save()

                # Send an email with the temporary password
                send_mail(
                    'Password Reset',
                    f'Your new password: {temp_password}',
                    'your_email@example.com',  # Replace with your email
                    [email],
                    fail_silently=False,
                )

                messages.success(request, 'Password reset email sent. Check your inbox.')
                return redirect('login')  # Redirect to the login page
            else:
                messages.error(request, 'No user found with this email address.')

        return render(request, 'forgot_password.html',{})
